{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1520324480000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1520324480000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1520324480000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1520324480000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1520324480000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1520324480000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1520324480000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1520324480000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1520324480000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1520324480000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1520324480000},{"_id":"themes/next/README.en.md","hash":"32d6cdfec1447f54aae1d7f1365ce6733dfcec8f","modified":1520324480000},{"_id":"themes/next/_config.yml","hash":"ad953b7cdfe51f7e4a0671f2273ec6386fc803b8","modified":1520324480000},{"_id":"themes/next/bower.json","hash":"7d7938f9da896fe710aa0e9120140e528bf058df","modified":1520324480000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1520324480000},{"_id":"themes/next/package.json","hash":"193dad6f59a588908fac082cc46fe067dac1b84d","modified":1520324480000},{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock.md","hash":"25cacd2213d492af34a3beb9102a5bfcb9f7f3ed","modified":1520324480000},{"_id":"source/_posts/Cobar-Database-Scales.md","hash":"c76b925a18a9d406e9f5eb720e9a2094e5c82086","modified":1520324480000},{"_id":"source/_posts/Cobar-Enhance-cobar-dataSource-with-dataHost.md","hash":"024dfee585945b728f81032b538d0f867c49a3f7","modified":1520324480000},{"_id":"source/_posts/Cobar-Enhance-cobar-driver-with-high-availability.md","hash":"d52fb6c369c769d9ddd91bbdab661bd6537d272f","modified":1520324480000},{"_id":"source/_posts/Cobar-Enhance-cobar-mysql-heartbeat.md","hash":"31f482654ba3408a974490750b74e80da8901623","modified":1520324480000},{"_id":"source/_posts/Cobar-FAQ.md","hash":"c284655bba6f8561ad1f9fcd60fcbbf2d704834e","modified":1520324480000},{"_id":"source/_posts/Cobar-How-to-monitor-cobar.md","hash":"4bc59489ad21ca7b42448bc2fe1b26755e8c1384","modified":1520324480000},{"_id":"source/_posts/Cobar-Performance-Test-With-Sysbench.md","hash":"04728a5fdd793cad02cdbaac5582884715ac6313","modified":1529055887000},{"_id":"source/_posts/Cobar-NIO-client.md","hash":"e724361a2aea9af70ceda90a5d4afacfa9040a60","modified":1520324480000},{"_id":"source/_posts/Cobar-How-sql-executes-in-cobar.md","hash":"65ab30dce7a236b1e560837e35e74e4c00f51308","modified":1520324480000},{"_id":"source/_posts/Cobar-NIO-server.md","hash":"8e16fe3c0615adc4608f426394c651448c0c84c4","modified":1520324480000},{"_id":"source/_posts/Cobar-Reactor-design-pattern.md","hash":"89af190aa6466ce5c0bc789d2f2f004ad2e71695","modified":1520324480000},{"_id":"source/_posts/Curator-Distributed-lock.md","hash":"4ce7ecbc35261132da1e63a5a877d340349937c5","modified":1520324480000},{"_id":"source/_posts/Distributed-Consensus-Raft.md","hash":"c1a9ed77ae882f4d52f5612d636201875d66c00f","modified":1520324480000},{"_id":"source/_posts/Curator-sync-and-mutual-exclusion-between-thread-and-process.md","hash":"adfb453524a26e4a44034718c4564ae02f55f2e8","modified":1520324480000},{"_id":"source/_posts/Distributed-Transaction-TCC.md","hash":"cf9bec2c4b64876dc17faf9baaec72b9619d8d94","modified":1520324480000},{"_id":"source/_posts/Distributed-Unique-id.md","hash":"9251d391cad3597140c12cecb7f24ad8a4d49f8b","modified":1520324480000},{"_id":"source/_posts/Distributed-Transaction.md","hash":"45df09aa76c88d30e2913be4cca7250c8927ef76","modified":1520324480000},{"_id":"source/_posts/Guava-Black-techs.md","hash":"2e51a2c282b32bb6661c54007a76c4e09982ebc2","modified":1520324480000},{"_id":"source/_posts/Interview-Questions.md","hash":"7b42be70e626e188797b70bea7a93312a57ebe8d","modified":1520324480000},{"_id":"source/_posts/JVM-Atomic-operation.md","hash":"0ccc0331a673e525e65bb3027b33a1fdbfb72d39","modified":1520324480000},{"_id":"source/_posts/JVM-CAS-Campare-and-swap.md","hash":"ba68978c50138649b6e89570bdc1e15600d8756f","modified":1520324480000},{"_id":"source/_posts/JVM-Crash-Log-Analysis.md","hash":"31cb1beff89e15bbdf48f6b21fff08adbc9c0aaf","modified":1520324480000},{"_id":"source/_posts/JVM-Debug-Openjdk-On-Mac.md","hash":"edaa1a59c86bc1a1d04719aed91cea40c68845ac","modified":1520324480000},{"_id":"source/_posts/JVM-Lock.md","hash":"ebc3271b10ccae41bd57ff2103d8f84bafed4700","modified":1520324480000},{"_id":"source/_posts/JVM-Off-Heap-Memory.md","hash":"a2514f63e386900e396ab42239efb92691a0fe4b","modified":1520324480000},{"_id":"source/_posts/JVM-Optimization.md","hash":"bef2606f42930f00d24c9fde2f4db8bc21723edf","modified":1520324480000},{"_id":"source/_posts/JVM-Profiling.md","hash":"8b9e1ce6f2d59c5cd527df9b1e7017ce5a64aa5e","modified":1520324480000},{"_id":"source/_posts/JVM-Thread-interupt.md","hash":"d6b0d69bceb8489d3995c2aed22181f87bdeb94c","modified":1520324480000},{"_id":"source/_posts/Kafka-FAQ.md","hash":"89d27def8a1482cf9cb83d61713159aa7eba3743","modified":1520324480000},{"_id":"source/_posts/Linux-Useful-command.md","hash":"81173a021d3519b46f98e69575d707ae2239b220","modified":1526702861000},{"_id":"source/_posts/Linux-Kernel-space-and-User-space.md","hash":"34df2ae8c7353b5a219c3fd49b5b32637dfe3a3b","modified":1520324480000},{"_id":"source/_posts/Kafka-High-performance-design-with-pagecache.md","hash":"9aea0b6ce9c1bb9ccbe51fbfcd227a349bb7a03b","modified":1520324480000},{"_id":"source/_posts/Linux-Mmap.md","hash":"8dd784e06617dd2570d4b94263d5c2b9bd372268","modified":1520324480000},{"_id":"source/_posts/Linux-sync-async-blocking-noblocking.md","hash":"8e301b3ccf3c6b75a9e46554a245a1b80b3625f3","modified":1520324480000},{"_id":"source/_posts/Linux-Zero-Copy.md","hash":"b2b5f51dc2095d9b4a8107ecfac7bb83a8fae352","modified":1520324480000},{"_id":"source/_posts/MySQL-Explain.md","hash":"8222c73362db2d7ea268314f0485b2337b83d32d","modified":1520324480000},{"_id":"source/_posts/Netty-Bind-Port.md","hash":"dbbec87f86abc89fa82cb324c7ff4467dc3d2168","modified":1520324480000},{"_id":"source/_posts/Netty-Buffer-Allocator.md","hash":"62b359381afb64c0947490b22b19123c322bda58","modified":1520324480000},{"_id":"source/_posts/Netty-ChannelOption-Backlog.md","hash":"e66c4b7cb2d2a9ff28c73af255886779dd10c458","modified":1520324480000},{"_id":"source/_posts/Netty-ChannelOption.md","hash":"c80e51a1707cab52569842f09ffe3faa344b1df3","modified":1520324480000},{"_id":"source/_posts/Netty-FAQ.md","hash":"332953ebed894616d9572b2058c5c801fef42e10","modified":1520324480000},{"_id":"source/_posts/OSAHS.md","hash":"d9bfcd01d4441264ea1290e4e3aa2a22599915c0","modified":1530516730000},{"_id":"source/_posts/Netty-Performance-Test.md","hash":"9ad441f9fc5e1ec4859f2217811d989ebb98756a","modified":1520324480000},{"_id":"source/_posts/Netty-Jemalloc.md","hash":"637ea7fac1ff1090ca94075da66ee2eb96eb64a0","modified":1520324480000},{"_id":"source/_posts/Redis-SourceCode-Analysis.md","hash":"5eaf0c9ee4a09beb84614a9d1a616c41fbe62e82","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Consumer-rebalance.md","hash":"1991347d1fb4e8279fb224f3a0aa519d332fd4d2","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Debug-with-intellij.md","hash":"2eafec8f43c7b38e3af97f8c21cb427c97c5bfa6","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Delay-message-delivery.md","hash":"90c1dc23d003496f2326db87233e413868b83f3a","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Index-service.md","hash":"d3402cce575c215bc0aae7aeb3ae6dfceb6aec1f","modified":1520324480000},{"_id":"source/_posts/RocketMQ-FAQ.md","hash":"32855a75383d28f46e85a71388c72c9916545b9f","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Master-slave-high-availability.md","hash":"a528a5a68efcf7aa26fa47f985ede482f54fa08f","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Netty-imp-sync-and-async-invoke.md","hash":"2c5fe3afb630894f98c782d82eebeb3ae1c89a37","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Message-send-and-persistence.md","hash":"2b0af70614a1f3fcd2dde43aeb0bc3230cf30ce3","modified":1531366275000},{"_id":"source/_posts/RocketMQ-Pull-message-with-long-polling.md","hash":"705aef0084f5c53f3dda8e4ce52555d09fd728bf","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Remote-communication-protocol-and-serialization.md","hash":"6ad95fbfebf431b4006dcb3caea35a6f3bdac147","modified":1520324480000},{"_id":"source/_posts/Serialization-Hessian.md","hash":"47dcc1676849cb6520cfe359fe79e052130d002a","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Transactional-message.md","hash":"2d09f4fbd448438d8c0870d3c7ef29bfcf2faa11","modified":1520324480000},{"_id":"source/_posts/SourceCode-Future.md","hash":"acf533ee38e5815036968106b62f111f3198aff8","modified":1520324480000},{"_id":"source/_posts/SourceCode-AbstractQueuedSynchronizer.md","hash":"56dc807b5064dca3523c2fd4b7bec9e098caad55","modified":1520324480000},{"_id":"source/_posts/SourceCode-Map.md","hash":"61765b0430bdc7f0085d50f142056de7a5bba06d","modified":1520324480000},{"_id":"source/_posts/Thread-FAQ.md","hash":"b1c7bf7a1792aee9d0bafb533fbf59b48281a9a8","modified":1520324480000},{"_id":"source/_posts/tree-cache-single-thread-event-handler-in-curator.md","hash":"8b3e23dfb61e75106ed43aa07cf9dd1bdbd8060f","modified":1520324480000},{"_id":"source/_posts/TCP-Protocol-Analyzer.md","hash":"1e9c30d43a890714192dea23c4e6df5619d41f4f","modified":1520324480000},{"_id":"source/tags/index.md","hash":"5c890fd947e675abc3ce2371a6ff2ff409362311","modified":1520324480000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1520324480000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"b56c01cdfc6ee7ffea8a8a9fa149263f368caef6","modified":1520324480000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"37bd0ec1d655c601946fc5f5ac2fe8ed1e529b77","modified":1520324480000},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1520324480000},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1520324480000},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1520324480000},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1520324480000},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1520324480000},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1520324480000},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1520324480000},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1520324480000},{"_id":"themes/next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1520324480000},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1520324480000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1520324480000},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1520324480000},{"_id":"themes/next/layout/_layout.swig","hash":"06b1eab2e00273e0b94bd32dc682bd92c1e0a747","modified":1520324480000},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1520324480000},{"_id":"themes/next/layout/archive.swig","hash":"383f64deab105724fd5512371963bd9e9aafbffd","modified":1520324480000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1520324480000},{"_id":"themes/next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1520324480000},{"_id":"themes/next/layout/page.swig","hash":"37c874cd720acf0eda8d26e063278f2b6ae8d3a6","modified":1520324480000},{"_id":"themes/next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1520324480000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1520324480000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1520324480000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1520324480000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1520324480000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1520324480000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1520324480000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1520324480000},{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock/sign.gif","hash":"999dfe3ed086bd56471bddb697dd2dd70157cb31","modified":1520324480000},{"_id":"source/_posts/Cobar-Database-Scales/cobar-rule-reload.gif","hash":"f22fc213ac979074b93952f9f9371d79d5441b55","modified":1520324480000},{"_id":"source/_posts/Cobar-Reactor-design-pattern/NioSign.gif","hash":"6c1b820c2c71938b240d4bc5ac56691f2c538dca","modified":1520324480000},{"_id":"source/_posts/JVM-Lock/biased_lock_convert_flow.jpg","hash":"437ba37b1e9acdac50b4d813ddd6b44199cd035c","modified":1520324480000},{"_id":"source/_posts/Kafka-High-performance-design-with-pagecache/disk_read_write_speed.jpg","hash":"3a3bcb8193115780dd7568721270a217ba4499e9","modified":1520324480000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520324480000},{"_id":"source/_posts/Cobar-Database-Scales/binlog-sync.gif","hash":"ea89adb683aae42bcb5382e86b2cf79a6aabb609","modified":1520324480000},{"_id":"source/_posts/Cobar-Database-Scales/backup-and-replay.gif","hash":"0a0d6a449b889101bba7f512f8126b9b244f8a93","modified":1520324480000},{"_id":"source/_posts/Cobar-Reactor-design-pattern/CobarReactorSign.gif","hash":"17ac291d666654f13097a9ab729adf5d329bd37a","modified":1520324480000},{"_id":"source/_posts/JVM-Lock/markword_state.jpg","hash":"59b1e2cd4dd8962ab1657d79ac8db8a8cd980d95","modified":1520324480000},{"_id":"source/_posts/Kafka-High-performance-design-with-pagecache/read_write.gif","hash":"d8b58d9570bbe1056bbbb54d8e1d1b54f1c4870e","modified":1520324480000},{"_id":"source/_posts/Netty-Jemalloc/jemalloc.jpg","hash":"350568c3a6c2abff13fb244a3e78e7f758fd99c2","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Index-service/index-file.gif","hash":"4ccabf0aed972624fd7a8c4648430c975af70f3c","modified":1520324480000},{"_id":"source/_posts/TCP-Protocol-Analyzer/mySql-handshake.gif","hash":"9f1b58afc5332c49f53b88e2e3ec081d5dd886f9","modified":1520324480000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1520324480000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1520324480000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1520324480000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"53d4f83b2b7fb4387dfc9fe81519abd56fbce4ae","modified":1520324480000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"5d5f70deb6074cb4dd0438463e14ccf89213c282","modified":1520324480000},{"_id":"themes/next/layout/_macro/post.swig","hash":"911363776867d9523a3e322cdf591d49cd166403","modified":1520324480000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1520324480000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"faa7886ccf986890cd776f4e9d70cb89fe9fda5f","modified":1520324480000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"ce7094ee05878161e7568a6dfae5b56ff3fbd6e1","modified":1520324480000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1520324480000},{"_id":"themes/next/layout/_partials/head.swig","hash":"1f14d3f494b2dbbcee802fd6f6d1abd5b7e2304c","modified":1520324480000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1520324480000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1520324480000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1520324480000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1520324480000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1520324480000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1520324480000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1520324480000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1520324480000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1520324480000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1520324480000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1520324480000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1520324480000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1520324480000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1520324480000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1520324480000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1520324480000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1520324480000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1520324480000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1520324480000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1520324480000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1520324480000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1520324480000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1520324480000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1520324480000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1520324480000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1520324480000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1520324480000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1520324480000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1520324480000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1520324480000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1520324480000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1520324480000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1520324480000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1520324480000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1520324480000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1520324480000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1520324480000},{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock/abnormal.gif","hash":"c2da1c2fc71056fb224ef0c0a276805206c7cbc6","modified":1520324480000},{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock/normal.gif","hash":"65ce3f933e03889174067eba323f00a55b13129e","modified":1520324480000},{"_id":"source/_posts/Cobar-Enhance-cobar-driver-with-high-availability/after-cobar-driver.gif","hash":"76597fd5ef32d8ebdf1dee82ab29e1fe092c810a","modified":1520324480000},{"_id":"source/_posts/Cobar-Enhance-cobar-driver-with-high-availability/before-cobar-driver.gif","hash":"75a442326aecac7ad3d959ef816cddec8b32dca4","modified":1520324480000},{"_id":"source/_posts/Cobar-Reactor-design-pattern/NioRegister.gif","hash":"4aec07220806ec8f3168d58ef8ff62b885bba9c6","modified":1520324480000},{"_id":"source/_posts/Distributed-Transaction/transaction_rocketmq.gif","hash":"9a6c9cd908a78d62a435afdea7ac7bac702f4cd0","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Transactional-message/transaction_rocketmq.gif","hash":"9a6c9cd908a78d62a435afdea7ac7bac702f4cd0","modified":1520324480000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520324480000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520324480000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520324480000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520324480000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520324480000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520324480000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520324480000},{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock/datasource-swithch-with-zk-event-sender.gif","hash":"4a199f1a2930ed182c8eab7dabfdd489fe7f69df","modified":1520324480000},{"_id":"source/_posts/Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datahost.gif","hash":"60fea3fcc8b92bcac7b5e6449e8c3bdcf0a35104","modified":1520324480000},{"_id":"source/_posts/JVM-Lock/light_lock_flow.jpg","hash":"8e5801eb0ba5786d871c495188a81eb2f21508a0","modified":1520324480000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1520324480000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1520324480000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1520324480000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1520324480000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1520324480000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1520324480000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1520324480000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1520324480000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1520324480000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1520324480000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1520324480000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1520324480000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1520324480000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1520324480000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1520324480000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1520324480000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"ee63aa2e49507b884a2d56778479cf01c723d751","modified":1520324480000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1520324480000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1520324480000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1520324480000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1520324480000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1520324480000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1520324480000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1520324480000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1520324480000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1520324480000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"eaedfaf06dae94ba77a8f4893e2e434bf8859bac","modified":1520324480000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1520324480000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"49b5210fa62d6cbc6a98f57d89d5067a06ab3561","modified":1520324480000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1520324480000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"cfee25d790e4f9b7d57f0dc7e2ea9c1649f08f11","modified":1520324480000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d477196c5699c8261b08e993a77ef67054d86166","modified":1520324480000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1520324480000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1520324480000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1520324480000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1520324480000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1520324480000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1520324480000},{"_id":"themes/next/source/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1520324480000},{"_id":"themes/next/source/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1520324480000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1520324480000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1520324480000},{"_id":"themes/next/source/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1520324480000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1520324480000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1520324480000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1520324480000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1520324480000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1520324480000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1520324480000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1520324480000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1520324480000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1520324480000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1520324480000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1520324480000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1520324480000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1520324480000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1520324480000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1520324480000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1520324480000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1520324480000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1520324480000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1520324480000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1520324480000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1520324480000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1520324480000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1520324480000},{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock/zk-distributed-lock.gif","hash":"f8f28db26e293ca5eb4c9f357707e5866cecea4b","modified":1520324480000},{"_id":"source/_posts/Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datanode.gif","hash":"8a219316b10fe6c514b0baa83585f23298404d8a","modified":1520324480000},{"_id":"source/_posts/JVM-Lock/biased_lock_flow.jpg","hash":"79d27d2fbe382878f0af70a4694657573ad4cc47","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Message-send-and-persistence/disc-fall.gif","hash":"c365fc98e4f8e66420abcaea0474846ae6978533","modified":1520324480000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1520324480000},{"_id":"source/_posts/Cobar-Reactor-design-pattern/CobarReactor.gif","hash":"7ab7adf110a40c2820cd40110d653d44a1e97c3d","modified":1520324480000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1520324480000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1520324480000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"2915df7152ea095a6290ef69157fd67669e0e793","modified":1520324480000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1520324480000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1520324480000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"86b6fd7f1b1be3ae98f8af6b23a6b1299c670ce9","modified":1520324480000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1520324480000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1520324480000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d026c8489f66ab6c12ad04bd37f1d5b6f2f3f0d1","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"bc8c388553bbcf95897459a466ba35bffd5ec5f0","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1520324480000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1520324480000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1520324480000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1520324480000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1520324480000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1520324480000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1520324480000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1520324480000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Netty-imp-sync-and-async-invoke/invokeSync.png","hash":"f5462e215665696a7867fc6d4ca8d0722c4fe72a","modified":1520324480000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1520324480000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1520324480000},{"_id":"source/_posts/RocketMQ-Netty-imp-sync-and-async-invoke/invokeAsync.png","hash":"65984a036bbd1af9b8b862e80d2f765fc3e19a17","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"65a64d5662637b66e2f039a5f58217afe7a6e800","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"57d2c8a060f5e4e1a0aef9aae11a0016cf7ac5ba","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ed88c8b51d0517759c777e71a6bfbe2907bcd994","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ee554b1031ef0070a5916477939021800e3c9d27","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"4fda5d38c6c8d910e3bf5c74a48a8d4a3f3dc73d","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"51eca243220cf57133a4becae9b78514bcfdc723","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"45df0cf4c97b47e05573bcd41028ee50f3fdf432","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1520324480000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1520324480000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1520324480000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1520324480000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1520324480000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1520324480000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1520324480000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1520324480000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1520324480000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1520324480000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1520324480000},{"_id":"source/.DS_Store","hash":"5f5b1ac3c4db4dd77972997d7d5684e05813be04","modified":1531063455000},{"_id":"source/_posts/.DS_Store","hash":"4c0a29dd23d96555b17ed83ca45d0d8e19608544","modified":1531060983000}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2017-10-12T11:33:19.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-10-12 19:33:19\ntype: \"tags\"\n---\n","updated":"2018-03-06T08:21:20.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjj3wcsxi00013iq2r23rb1tn","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Cobar——用分布式锁增强Cobar在集群环境的数据源切换","date":"2017-10-09T09:31:06.000Z","_content":"\nCobar集群部署时是无状态的，只是集群中会相互发送对等的心跳让每一台Cobar都保存完整集群列表。但网络存在的情况是非常复杂的。\n\n### 场景\n\n列举一种场景，有一个Cobar集群Cobar_Cluster，内部有两台机器，Cobar_A和Cobar_B，8台MySQL，MySQL1-8，MySQL1-4配置作Master，MySQL5-8台配置为Slave。\n\n![](Cobar-Cluster-datasource-switch-design-with-distributed-lock/sign.gif)\n\n![](Cobar-Cluster-datasource-switch-design-with-distributed-lock/normal.gif)\n\nCobarA和CobarB初始启动后，后端的数据源都指向MySQL1-4。如果CobarA和MySQL_2之间的网络抖了下，但CobarB和MySQL_2的网络没有抖动。于是CobarA切到了MySQL_6上，CobarB还是在MySQL_2上。\n\n![](Cobar-Cluster-datasource-switch-design-with-distributed-lock/abnormal.gif)\n\n### 问题\n\nCobar_B上执行insert，Cobar_A上执行select，binlog如果出现延迟，那数据就会短期内查不出来。\n\n### 改进\n\n![](Cobar-Cluster-datasource-switch-design-with-distributed-lock/datasource-swithch-with-zk-event-sender.gif)\n\n![](Cobar-Cluster-datasource-switch-design-with-distributed-lock/zk-distributed-lock.gif)","source":"_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock.md","raw":"---\ntitle: Cobar——用分布式锁增强Cobar在集群环境的数据源切换\ndate: 2017-10-09 17:31:06\ntags: Cobar\n---\n\nCobar集群部署时是无状态的，只是集群中会相互发送对等的心跳让每一台Cobar都保存完整集群列表。但网络存在的情况是非常复杂的。\n\n### 场景\n\n列举一种场景，有一个Cobar集群Cobar_Cluster，内部有两台机器，Cobar_A和Cobar_B，8台MySQL，MySQL1-8，MySQL1-4配置作Master，MySQL5-8台配置为Slave。\n\n![](Cobar-Cluster-datasource-switch-design-with-distributed-lock/sign.gif)\n\n![](Cobar-Cluster-datasource-switch-design-with-distributed-lock/normal.gif)\n\nCobarA和CobarB初始启动后，后端的数据源都指向MySQL1-4。如果CobarA和MySQL_2之间的网络抖了下，但CobarB和MySQL_2的网络没有抖动。于是CobarA切到了MySQL_6上，CobarB还是在MySQL_2上。\n\n![](Cobar-Cluster-datasource-switch-design-with-distributed-lock/abnormal.gif)\n\n### 问题\n\nCobar_B上执行insert，Cobar_A上执行select，binlog如果出现延迟，那数据就会短期内查不出来。\n\n### 改进\n\n![](Cobar-Cluster-datasource-switch-design-with-distributed-lock/datasource-swithch-with-zk-event-sender.gif)\n\n![](Cobar-Cluster-datasource-switch-design-with-distributed-lock/zk-distributed-lock.gif)","slug":"Cobar-Cluster-datasource-switch-design-with-distributed-lock","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsxe00003iq2gzdelso7","content":"<p>Cobar集群部署时是无状态的，只是集群中会相互发送对等的心跳让每一台Cobar都保存完整集群列表。但网络存在的情况是非常复杂的。</p>\n<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><p>列举一种场景，有一个Cobar集群Cobar_Cluster，内部有两台机器，Cobar_A和Cobar_B，8台MySQL，MySQL1-8，MySQL1-4配置作Master，MySQL5-8台配置为Slave。</p>\n<p><img src=\"/2017/10/09/Cobar-Cluster-datasource-switch-design-with-distributed-lock/sign.gif\" alt=\"\"></p>\n<p><img src=\"/2017/10/09/Cobar-Cluster-datasource-switch-design-with-distributed-lock/normal.gif\" alt=\"\"></p>\n<p>CobarA和CobarB初始启动后，后端的数据源都指向MySQL1-4。如果CobarA和MySQL_2之间的网络抖了下，但CobarB和MySQL_2的网络没有抖动。于是CobarA切到了MySQL_6上，CobarB还是在MySQL_2上。</p>\n<p><img src=\"/2017/10/09/Cobar-Cluster-datasource-switch-design-with-distributed-lock/abnormal.gif\" alt=\"\"></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>Cobar_B上执行insert，Cobar_A上执行select，binlog如果出现延迟，那数据就会短期内查不出来。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p><img src=\"/2017/10/09/Cobar-Cluster-datasource-switch-design-with-distributed-lock/datasource-swithch-with-zk-event-sender.gif\" alt=\"\"></p>\n<p><img src=\"/2017/10/09/Cobar-Cluster-datasource-switch-design-with-distributed-lock/zk-distributed-lock.gif\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Cobar集群部署时是无状态的，只是集群中会相互发送对等的心跳让每一台Cobar都保存完整集群列表。但网络存在的情况是非常复杂的。</p>\n<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><p>列举一种场景，有一个Cobar集群Cobar_Cluster，内部有两台机器，Cobar_A和Cobar_B，8台MySQL，MySQL1-8，MySQL1-4配置作Master，MySQL5-8台配置为Slave。</p>\n<p><img src=\"/2017/10/09/Cobar-Cluster-datasource-switch-design-with-distributed-lock/sign.gif\" alt=\"\"></p>\n<p><img src=\"/2017/10/09/Cobar-Cluster-datasource-switch-design-with-distributed-lock/normal.gif\" alt=\"\"></p>\n<p>CobarA和CobarB初始启动后，后端的数据源都指向MySQL1-4。如果CobarA和MySQL_2之间的网络抖了下，但CobarB和MySQL_2的网络没有抖动。于是CobarA切到了MySQL_6上，CobarB还是在MySQL_2上。</p>\n<p><img src=\"/2017/10/09/Cobar-Cluster-datasource-switch-design-with-distributed-lock/abnormal.gif\" alt=\"\"></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>Cobar_B上执行insert，Cobar_A上执行select，binlog如果出现延迟，那数据就会短期内查不出来。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p><img src=\"/2017/10/09/Cobar-Cluster-datasource-switch-design-with-distributed-lock/datasource-swithch-with-zk-event-sender.gif\" alt=\"\"></p>\n<p><img src=\"/2017/10/09/Cobar-Cluster-datasource-switch-design-with-distributed-lock/zk-distributed-lock.gif\" alt=\"\"></p>\n"},{"title":"Cobar——数据库扩容","date":"2017-11-29T07:49:07.000Z","_content":"\n![](Cobar-Database-Scales/backup-and-replay.gif)\n\n![](Cobar-Database-Scales/binlog-sync.gif)\n\n![](Cobar-Database-Scales/cobar-rule-reload.gif)","source":"_posts/Cobar-Database-Scales.md","raw":"---\ntitle: Cobar——数据库扩容\ndate: 2017-11-29 15:49:07\ntags: Cobar\n---\n\n![](Cobar-Database-Scales/backup-and-replay.gif)\n\n![](Cobar-Database-Scales/binlog-sync.gif)\n\n![](Cobar-Database-Scales/cobar-rule-reload.gif)","slug":"Cobar-Database-Scales","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsxi00023iq2zuhv730g","content":"<p><img src=\"/2017/11/29/Cobar-Database-Scales/backup-and-replay.gif\" alt=\"\"></p>\n<p><img src=\"/2017/11/29/Cobar-Database-Scales/binlog-sync.gif\" alt=\"\"></p>\n<p><img src=\"/2017/11/29/Cobar-Database-Scales/cobar-rule-reload.gif\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2017/11/29/Cobar-Database-Scales/backup-and-replay.gif\" alt=\"\"></p>\n<p><img src=\"/2017/11/29/Cobar-Database-Scales/binlog-sync.gif\" alt=\"\"></p>\n<p><img src=\"/2017/11/29/Cobar-Database-Scales/cobar-rule-reload.gif\" alt=\"\"></p>\n"},{"title":"Cobar——扩展Cobar，用Datahost维度来增强数据源","date":"2017-10-27T08:03:12.000Z","_content":"\n![](Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datanode.gif)\n\n![](Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datahost.gif)\n\n\n### change log\n\n#### schema.xml\n以user库为例，两个MySQL实例，分库数量：9，0-4分片在host1，5-8在host2\n\n<schema name=\"user\" dataNode=\"user_dn[0]\">\n    <!-- 拆分表 -->                                                               \n    <table name=\"user\" dataNode=\"user_dn$1-8\" rule=\"user_id_rule\" />\n</schema>\n\n<dataNode name=\"user_dn$0-4\" dataHost=\"user_host1\" database=\"user$0-4\" />\n<dataNode name=\"user_dn$5-8\" dataHost=\"user_host2\" database=\"user$5-8\" />\n\n<dataHost name=\"user_host1\" maxCon=\"200\" minCon=\"50\">\n    <heartbeat>select user()</heartbeat>\n    <writeHost host=\"M1\" url=\"host1:3306\" user=\"root\" password=\"root\" />\n    <writeHost host=\"S1\" url=\"host1_slave:3306\" user=\"root\" password=\"root\" />\n</dataHost>\n<dataHost name=\"user_host2\" maxCon=\"200\" minCon=\"50\">\n    <heartbeat>select user()</heartbeat>\n    <writeHost host=\"M1\" url=\"host2:3306\" user=\"root\" password=\"root\" />\n    <writeHost host=\"S1\" url=\"host2_slave:3306\" user=\"root\" password=\"root\" />\n</dataHost>\n","source":"_posts/Cobar-Enhance-cobar-dataSource-with-dataHost.md","raw":"---\ntitle: Cobar——扩展Cobar，用Datahost维度来增强数据源\ndate: 2017-10-27 16:03:12\ntags: Cobar\n---\n\n![](Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datanode.gif)\n\n![](Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datahost.gif)\n\n\n### change log\n\n#### schema.xml\n以user库为例，两个MySQL实例，分库数量：9，0-4分片在host1，5-8在host2\n\n<schema name=\"user\" dataNode=\"user_dn[0]\">\n    <!-- 拆分表 -->                                                               \n    <table name=\"user\" dataNode=\"user_dn$1-8\" rule=\"user_id_rule\" />\n</schema>\n\n<dataNode name=\"user_dn$0-4\" dataHost=\"user_host1\" database=\"user$0-4\" />\n<dataNode name=\"user_dn$5-8\" dataHost=\"user_host2\" database=\"user$5-8\" />\n\n<dataHost name=\"user_host1\" maxCon=\"200\" minCon=\"50\">\n    <heartbeat>select user()</heartbeat>\n    <writeHost host=\"M1\" url=\"host1:3306\" user=\"root\" password=\"root\" />\n    <writeHost host=\"S1\" url=\"host1_slave:3306\" user=\"root\" password=\"root\" />\n</dataHost>\n<dataHost name=\"user_host2\" maxCon=\"200\" minCon=\"50\">\n    <heartbeat>select user()</heartbeat>\n    <writeHost host=\"M1\" url=\"host2:3306\" user=\"root\" password=\"root\" />\n    <writeHost host=\"S1\" url=\"host2_slave:3306\" user=\"root\" password=\"root\" />\n</dataHost>\n","slug":"Cobar-Enhance-cobar-dataSource-with-dataHost","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsxm00043iq2c34i3z84","content":"<p><img src=\"/2017/10/27/Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datanode.gif\" alt=\"\"></p>\n<p><img src=\"/2017/10/27/Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datahost.gif\" alt=\"\"></p>\n<h3 id=\"change-log\"><a href=\"#change-log\" class=\"headerlink\" title=\"change log\"></a>change log</h3><h4 id=\"schema-xml\"><a href=\"#schema-xml\" class=\"headerlink\" title=\"schema.xml\"></a>schema.xml</h4><p>以user库为例，两个MySQL实例，分库数量：9，0-4分片在host1，5-8在host2</p>\n<schema name=\"user\" datanode=\"user_dn[0]\"><br>    <!-- 拆分表 --><br>    <table name=\"user\" datanode=\"user_dn$1-8\" rule=\"user_id_rule\"><br></table></schema>\n\n<p><datanode name=\"user_dn$0-4\" datahost=\"user_host1\" database=\"user$0-4\"></datanode></p>\n<datanode name=\"user_dn$5-8\" datahost=\"user_host2\" database=\"user$5-8\">\n\n<datahost name=\"user_host1\" maxcon=\"200\" mincon=\"50\"><br>    <heartbeat>select user()</heartbeat><br>    <writehost host=\"M1\" url=\"host1:3306\" user=\"root\" password=\"root\"><br>    <writehost host=\"S1\" url=\"host1_slave:3306\" user=\"root\" password=\"root\"><br></writehost></writehost></datahost><br><datahost name=\"user_host2\" maxcon=\"200\" mincon=\"50\"><br>    <heartbeat>select user()</heartbeat><br>    <writehost host=\"M1\" url=\"host2:3306\" user=\"root\" password=\"root\"><br>    <writehost host=\"S1\" url=\"host2_slave:3306\" user=\"root\" password=\"root\"><br></writehost></writehost></datahost>\n</datanode>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2017/10/27/Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datanode.gif\" alt=\"\"></p>\n<p><img src=\"/2017/10/27/Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datahost.gif\" alt=\"\"></p>\n<h3 id=\"change-log\"><a href=\"#change-log\" class=\"headerlink\" title=\"change log\"></a>change log</h3><h4 id=\"schema-xml\"><a href=\"#schema-xml\" class=\"headerlink\" title=\"schema.xml\"></a>schema.xml</h4><p>以user库为例，两个MySQL实例，分库数量：9，0-4分片在host1，5-8在host2</p>\n<schema name=\"user\" datanode=\"user_dn[0]\"><br>    <!-- 拆分表 --><br>    <table name=\"user\" datanode=\"user_dn$1-8\" rule=\"user_id_rule\"><br></table></schema>\n\n<p><datanode name=\"user_dn$0-4\" datahost=\"user_host1\" database=\"user$0-4\"></datanode></p>\n<datanode name=\"user_dn$5-8\" datahost=\"user_host2\" database=\"user$5-8\">\n\n<datahost name=\"user_host1\" maxcon=\"200\" mincon=\"50\"><br>    <heartbeat>select user()</heartbeat><br>    <writehost host=\"M1\" url=\"host1:3306\" user=\"root\" password=\"root\"><br>    <writehost host=\"S1\" url=\"host1_slave:3306\" user=\"root\" password=\"root\"><br></writehost></writehost></datahost><br><datahost name=\"user_host2\" maxcon=\"200\" mincon=\"50\"><br>    <heartbeat>select user()</heartbeat><br>    <writehost host=\"M1\" url=\"host2:3306\" user=\"root\" password=\"root\"><br>    <writehost host=\"S1\" url=\"host2_slave:3306\" user=\"root\" password=\"root\"><br></writehost></writehost></datahost>\n</datanode>"},{"title":"Cobar——扩展Cobar Driver，防止单点故障","date":"2017-10-12T12:07:23.000Z","_content":"\ncobar作为一套完整的分库分表方案，其负载均衡功能是由cobar-driver提供的。\n\n### cobar-driver单点问题\n\n原始的cobar版的JDBC协议如下：`jdbc:cobar://Cobar_A:8066/user`，只能支持连接cobar集群中的某一台机器，当整个集群中的这台机器宕机后，即使集群中的其余机器仍然可以提供服务，客户端也无法创建新的连接。\n\n![](Cobar-Enhance-cobar-driver-with-high-availability/before-cobar-driver.gif)\n\n### HA cobar(jdbc)协议\n为了防止这种单点故障，需要对cobar-driver的源码进行修改，协议部分改造，URL的host部分不再只能填写一个host地址，而是像ZooKeeper一样，可以填写整个Cobar集群的地址：jdbc:cobar_cluster://cobar_1,cobar_2:8066/user，即使cobar_1宕机了，应用还是可以去cobar_2中继续创建新的连接以保证性能。\n\n![](Cobar-Enhance-cobar-driver-with-high-availability/after-cobar-driver.gif)","source":"_posts/Cobar-Enhance-cobar-driver-with-high-availability.md","raw":"---\ntitle: Cobar——扩展Cobar Driver，防止单点故障\ndate: 2017-10-12 20:07:23\ntags: Cobar\n---\n\ncobar作为一套完整的分库分表方案，其负载均衡功能是由cobar-driver提供的。\n\n### cobar-driver单点问题\n\n原始的cobar版的JDBC协议如下：`jdbc:cobar://Cobar_A:8066/user`，只能支持连接cobar集群中的某一台机器，当整个集群中的这台机器宕机后，即使集群中的其余机器仍然可以提供服务，客户端也无法创建新的连接。\n\n![](Cobar-Enhance-cobar-driver-with-high-availability/before-cobar-driver.gif)\n\n### HA cobar(jdbc)协议\n为了防止这种单点故障，需要对cobar-driver的源码进行修改，协议部分改造，URL的host部分不再只能填写一个host地址，而是像ZooKeeper一样，可以填写整个Cobar集群的地址：jdbc:cobar_cluster://cobar_1,cobar_2:8066/user，即使cobar_1宕机了，应用还是可以去cobar_2中继续创建新的连接以保证性能。\n\n![](Cobar-Enhance-cobar-driver-with-high-availability/after-cobar-driver.gif)","slug":"Cobar-Enhance-cobar-driver-with-high-availability","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsxo00053iq26l3j2g45","content":"<p>cobar作为一套完整的分库分表方案，其负载均衡功能是由cobar-driver提供的。</p>\n<h3 id=\"cobar-driver单点问题\"><a href=\"#cobar-driver单点问题\" class=\"headerlink\" title=\"cobar-driver单点问题\"></a>cobar-driver单点问题</h3><p>原始的cobar版的JDBC协议如下：<code>jdbc:cobar://Cobar_A:8066/user</code>，只能支持连接cobar集群中的某一台机器，当整个集群中的这台机器宕机后，即使集群中的其余机器仍然可以提供服务，客户端也无法创建新的连接。</p>\n<p><img src=\"/2017/10/12/Cobar-Enhance-cobar-driver-with-high-availability/before-cobar-driver.gif\" alt=\"\"></p>\n<h3 id=\"HA-cobar-jdbc-协议\"><a href=\"#HA-cobar-jdbc-协议\" class=\"headerlink\" title=\"HA cobar(jdbc)协议\"></a>HA cobar(jdbc)协议</h3><p>为了防止这种单点故障，需要对cobar-driver的源码进行修改，协议部分改造，URL的host部分不再只能填写一个host地址，而是像ZooKeeper一样，可以填写整个Cobar集群的地址：jdbc:cobar_cluster://cobar_1,cobar_2:8066/user，即使cobar_1宕机了，应用还是可以去cobar_2中继续创建新的连接以保证性能。</p>\n<p><img src=\"/2017/10/12/Cobar-Enhance-cobar-driver-with-high-availability/after-cobar-driver.gif\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>cobar作为一套完整的分库分表方案，其负载均衡功能是由cobar-driver提供的。</p>\n<h3 id=\"cobar-driver单点问题\"><a href=\"#cobar-driver单点问题\" class=\"headerlink\" title=\"cobar-driver单点问题\"></a>cobar-driver单点问题</h3><p>原始的cobar版的JDBC协议如下：<code>jdbc:cobar://Cobar_A:8066/user</code>，只能支持连接cobar集群中的某一台机器，当整个集群中的这台机器宕机后，即使集群中的其余机器仍然可以提供服务，客户端也无法创建新的连接。</p>\n<p><img src=\"/2017/10/12/Cobar-Enhance-cobar-driver-with-high-availability/before-cobar-driver.gif\" alt=\"\"></p>\n<h3 id=\"HA-cobar-jdbc-协议\"><a href=\"#HA-cobar-jdbc-协议\" class=\"headerlink\" title=\"HA cobar(jdbc)协议\"></a>HA cobar(jdbc)协议</h3><p>为了防止这种单点故障，需要对cobar-driver的源码进行修改，协议部分改造，URL的host部分不再只能填写一个host地址，而是像ZooKeeper一样，可以填写整个Cobar集群的地址：jdbc:cobar_cluster://cobar_1,cobar_2:8066/user，即使cobar_1宕机了，应用还是可以去cobar_2中继续创建新的连接以保证性能。</p>\n<p><img src=\"/2017/10/12/Cobar-Enhance-cobar-driver-with-high-availability/after-cobar-driver.gif\" alt=\"\"></p>\n"},{"title":"Cobar-Enhance-cobar-mysql-heartbeat","date":"2017-10-27T06:37:10.000Z","_content":"\n### Cobar与MySQL心跳实现\n\nCobar的心跳是用原生NIO写的，相对于用Netty来发送心跳，复杂度不在一个量级上。\n\n### 网络抖动\n\nCobar会向MySQL发送`select user()`的心跳，Cobar会在以下两种情况下进行数据源切换\n* Cobar向MySQL发送心跳数据失败，界定为Error\n* Cobar向MySQL发送心跳数据，但30秒（默认）内没有收到MySQL回复，界定为Timeout\n\n在阿里云VPC的环境中，网络抖动又是家常便饭，一旦网络出现抖动，Cobar立刻把对应dataNode的数据源从Master切到Slave或者从Slave切回Master，于是，慢SQL出现了。这时都意识到，这个数据源切换的策略不靠谱，需要重新设计。\n\n不能一发现情况一，就认定是Error，网络抖动很有可能在几秒钟之内恢复回来，这里采用的策略是，发现情况一，再试3次，如果第3次还失败，等待n秒后再试一次，如果还发送心跳失败，那就是Error，需要切换数据源。\n\n### 过滤抖动策略","source":"_posts/Cobar-Enhance-cobar-mysql-heartbeat.md","raw":"---\ntitle: Cobar-Enhance-cobar-mysql-heartbeat\ndate: 2017-10-27 14:37:10\ntags: Cobar\n---\n\n### Cobar与MySQL心跳实现\n\nCobar的心跳是用原生NIO写的，相对于用Netty来发送心跳，复杂度不在一个量级上。\n\n### 网络抖动\n\nCobar会向MySQL发送`select user()`的心跳，Cobar会在以下两种情况下进行数据源切换\n* Cobar向MySQL发送心跳数据失败，界定为Error\n* Cobar向MySQL发送心跳数据，但30秒（默认）内没有收到MySQL回复，界定为Timeout\n\n在阿里云VPC的环境中，网络抖动又是家常便饭，一旦网络出现抖动，Cobar立刻把对应dataNode的数据源从Master切到Slave或者从Slave切回Master，于是，慢SQL出现了。这时都意识到，这个数据源切换的策略不靠谱，需要重新设计。\n\n不能一发现情况一，就认定是Error，网络抖动很有可能在几秒钟之内恢复回来，这里采用的策略是，发现情况一，再试3次，如果第3次还失败，等待n秒后再试一次，如果还发送心跳失败，那就是Error，需要切换数据源。\n\n### 过滤抖动策略","slug":"Cobar-Enhance-cobar-mysql-heartbeat","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsxq00063iq2xthrhv0u","content":"<h3 id=\"Cobar与MySQL心跳实现\"><a href=\"#Cobar与MySQL心跳实现\" class=\"headerlink\" title=\"Cobar与MySQL心跳实现\"></a>Cobar与MySQL心跳实现</h3><p>Cobar的心跳是用原生NIO写的，相对于用Netty来发送心跳，复杂度不在一个量级上。</p>\n<h3 id=\"网络抖动\"><a href=\"#网络抖动\" class=\"headerlink\" title=\"网络抖动\"></a>网络抖动</h3><p>Cobar会向MySQL发送<code>select user()</code>的心跳，Cobar会在以下两种情况下进行数据源切换</p>\n<ul>\n<li>Cobar向MySQL发送心跳数据失败，界定为Error</li>\n<li>Cobar向MySQL发送心跳数据，但30秒（默认）内没有收到MySQL回复，界定为Timeout</li>\n</ul>\n<p>在阿里云VPC的环境中，网络抖动又是家常便饭，一旦网络出现抖动，Cobar立刻把对应dataNode的数据源从Master切到Slave或者从Slave切回Master，于是，慢SQL出现了。这时都意识到，这个数据源切换的策略不靠谱，需要重新设计。</p>\n<p>不能一发现情况一，就认定是Error，网络抖动很有可能在几秒钟之内恢复回来，这里采用的策略是，发现情况一，再试3次，如果第3次还失败，等待n秒后再试一次，如果还发送心跳失败，那就是Error，需要切换数据源。</p>\n<h3 id=\"过滤抖动策略\"><a href=\"#过滤抖动策略\" class=\"headerlink\" title=\"过滤抖动策略\"></a>过滤抖动策略</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Cobar与MySQL心跳实现\"><a href=\"#Cobar与MySQL心跳实现\" class=\"headerlink\" title=\"Cobar与MySQL心跳实现\"></a>Cobar与MySQL心跳实现</h3><p>Cobar的心跳是用原生NIO写的，相对于用Netty来发送心跳，复杂度不在一个量级上。</p>\n<h3 id=\"网络抖动\"><a href=\"#网络抖动\" class=\"headerlink\" title=\"网络抖动\"></a>网络抖动</h3><p>Cobar会向MySQL发送<code>select user()</code>的心跳，Cobar会在以下两种情况下进行数据源切换</p>\n<ul>\n<li>Cobar向MySQL发送心跳数据失败，界定为Error</li>\n<li>Cobar向MySQL发送心跳数据，但30秒（默认）内没有收到MySQL回复，界定为Timeout</li>\n</ul>\n<p>在阿里云VPC的环境中，网络抖动又是家常便饭，一旦网络出现抖动，Cobar立刻把对应dataNode的数据源从Master切到Slave或者从Slave切回Master，于是，慢SQL出现了。这时都意识到，这个数据源切换的策略不靠谱，需要重新设计。</p>\n<p>不能一发现情况一，就认定是Error，网络抖动很有可能在几秒钟之内恢复回来，这里采用的策略是，发现情况一，再试3次，如果第3次还失败，等待n秒后再试一次，如果还发送心跳失败，那就是Error，需要切换数据源。</p>\n<h3 id=\"过滤抖动策略\"><a href=\"#过滤抖动策略\" class=\"headerlink\" title=\"过滤抖动策略\"></a>过滤抖动策略</h3>"},{"title":"Cobar——原理整理","date":"2017-10-18T12:24:04.000Z","_content":"\nFrontendConnection默认的NioHandler是FrontendAuthenticator, 当认证信息发来时，FrontendConnection会把handler.handle()任务放入一个线程池中，当前的handler是默认的认证器，如果认证成功了，FrontendAuthenticator会反过来将FrontendConnection的handler替换成FrontendCommandHandler。\n\nHandler是由NioConnection主动触发的，在Handler处理完信息后，需要将处理完后的response回写给NioConnection, NioConnection把数据放入NioProcessor的writeQueue。\n\nCobar将数据库连接池的大小暴露在配置文件中，但为了性能考虑（我觉得），没有严格将数据库的连接数保持在这个范围内，假设连接池的大小为50，在高并发的SQL执行下，连接数可能会冲击到80-90，此时需要注意MySQL的max_connections这个配置，如果这个值比较小，那Cobar在并发执行SQL时创建连接，而MySQL握手包的内容可能会发生变化，但Cobar不会处理这种异常情况，导致Cobar抛出一下错误：\n![img](https://ws4.sinaimg.cn/large/006tKfTcgy1fkmo3ieklej31kw0hz7il.jpg)\n\n### Cobar怎么处理半包和拆包\n\n\n\n### hexo new Cobar-Extend-Database\n\nPercona XtraBackup\n分片数不能变，非常简单得扩容","source":"_posts/Cobar-FAQ.md","raw":"---\ntitle: Cobar——原理整理\ndate: 2017-10-18 20:24:04\ntags: Cobar\n---\n\nFrontendConnection默认的NioHandler是FrontendAuthenticator, 当认证信息发来时，FrontendConnection会把handler.handle()任务放入一个线程池中，当前的handler是默认的认证器，如果认证成功了，FrontendAuthenticator会反过来将FrontendConnection的handler替换成FrontendCommandHandler。\n\nHandler是由NioConnection主动触发的，在Handler处理完信息后，需要将处理完后的response回写给NioConnection, NioConnection把数据放入NioProcessor的writeQueue。\n\nCobar将数据库连接池的大小暴露在配置文件中，但为了性能考虑（我觉得），没有严格将数据库的连接数保持在这个范围内，假设连接池的大小为50，在高并发的SQL执行下，连接数可能会冲击到80-90，此时需要注意MySQL的max_connections这个配置，如果这个值比较小，那Cobar在并发执行SQL时创建连接，而MySQL握手包的内容可能会发生变化，但Cobar不会处理这种异常情况，导致Cobar抛出一下错误：\n![img](https://ws4.sinaimg.cn/large/006tKfTcgy1fkmo3ieklej31kw0hz7il.jpg)\n\n### Cobar怎么处理半包和拆包\n\n\n\n### hexo new Cobar-Extend-Database\n\nPercona XtraBackup\n分片数不能变，非常简单得扩容","slug":"Cobar-FAQ","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsxu00093iq2dca6d2bp","content":"<p>FrontendConnection默认的NioHandler是FrontendAuthenticator, 当认证信息发来时，FrontendConnection会把handler.handle()任务放入一个线程池中，当前的handler是默认的认证器，如果认证成功了，FrontendAuthenticator会反过来将FrontendConnection的handler替换成FrontendCommandHandler。</p>\n<p>Handler是由NioConnection主动触发的，在Handler处理完信息后，需要将处理完后的response回写给NioConnection, NioConnection把数据放入NioProcessor的writeQueue。</p>\n<p>Cobar将数据库连接池的大小暴露在配置文件中，但为了性能考虑（我觉得），没有严格将数据库的连接数保持在这个范围内，假设连接池的大小为50，在高并发的SQL执行下，连接数可能会冲击到80-90，此时需要注意MySQL的max_connections这个配置，如果这个值比较小，那Cobar在并发执行SQL时创建连接，而MySQL握手包的内容可能会发生变化，但Cobar不会处理这种异常情况，导致Cobar抛出一下错误：<br><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fkmo3ieklej31kw0hz7il.jpg\" alt=\"img\"></p>\n<h3 id=\"Cobar怎么处理半包和拆包\"><a href=\"#Cobar怎么处理半包和拆包\" class=\"headerlink\" title=\"Cobar怎么处理半包和拆包\"></a>Cobar怎么处理半包和拆包</h3><h3 id=\"hexo-new-Cobar-Extend-Database\"><a href=\"#hexo-new-Cobar-Extend-Database\" class=\"headerlink\" title=\"hexo new Cobar-Extend-Database\"></a>hexo new Cobar-Extend-Database</h3><p>Percona XtraBackup<br>分片数不能变，非常简单得扩容</p>\n","site":{"data":{}},"excerpt":"","more":"<p>FrontendConnection默认的NioHandler是FrontendAuthenticator, 当认证信息发来时，FrontendConnection会把handler.handle()任务放入一个线程池中，当前的handler是默认的认证器，如果认证成功了，FrontendAuthenticator会反过来将FrontendConnection的handler替换成FrontendCommandHandler。</p>\n<p>Handler是由NioConnection主动触发的，在Handler处理完信息后，需要将处理完后的response回写给NioConnection, NioConnection把数据放入NioProcessor的writeQueue。</p>\n<p>Cobar将数据库连接池的大小暴露在配置文件中，但为了性能考虑（我觉得），没有严格将数据库的连接数保持在这个范围内，假设连接池的大小为50，在高并发的SQL执行下，连接数可能会冲击到80-90，此时需要注意MySQL的max_connections这个配置，如果这个值比较小，那Cobar在并发执行SQL时创建连接，而MySQL握手包的内容可能会发生变化，但Cobar不会处理这种异常情况，导致Cobar抛出一下错误：<br><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fkmo3ieklej31kw0hz7il.jpg\" alt=\"img\"></p>\n<h3 id=\"Cobar怎么处理半包和拆包\"><a href=\"#Cobar怎么处理半包和拆包\" class=\"headerlink\" title=\"Cobar怎么处理半包和拆包\"></a>Cobar怎么处理半包和拆包</h3><h3 id=\"hexo-new-Cobar-Extend-Database\"><a href=\"#hexo-new-Cobar-Extend-Database\" class=\"headerlink\" title=\"hexo new Cobar-Extend-Database\"></a>hexo new Cobar-Extend-Database</h3><p>Percona XtraBackup<br>分片数不能变，非常简单得扩容</p>\n"},{"title":"Cobar——近实时监控Cobar前后端连接与线程池","date":"2017-10-12T12:04:26.000Z","_content":"","source":"_posts/Cobar-How-to-monitor-cobar.md","raw":"---\ntitle: Cobar——近实时监控Cobar前后端连接与线程池\ndate: 2017-10-12 20:04:26\ntags: Cobar\n---\n","slug":"Cobar-How-to-monitor-cobar","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsxx000b3iq2t3uuz87t","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Cobar-NIO-client","date":"2017-10-18T03:13:59.000Z","_content":"\nCobar作为一个数据库分库分表中间件，既是一台NIO Server，又是NIO Client","source":"_posts/Cobar-NIO-client.md","raw":"---\ntitle: Cobar-NIO-client\ndate: 2017-10-18 11:13:59\ntags: Cobar\n---\n\nCobar作为一个数据库分库分表中间件，既是一台NIO Server，又是NIO Client","slug":"Cobar-NIO-client","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsy3000e3iq29fsbo0i0","content":"<p>Cobar作为一个数据库分库分表中间件，既是一台NIO Server，又是NIO Client</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Cobar作为一个数据库分库分表中间件，既是一台NIO Server，又是NIO Client</p>\n"},{"title":"Cobar-NIO-server","date":"2017-10-18T03:13:40.000Z","_content":"\nCobar作为一个数据库分库分表中间件，既是一台NIO Server，又是NIO Client","source":"_posts/Cobar-NIO-server.md","raw":"---\ntitle: Cobar-NIO-server\ndate: 2017-10-18 11:13:40\ntags: Cobar\n---\n\nCobar作为一个数据库分库分表中间件，既是一台NIO Server，又是NIO Client","slug":"Cobar-NIO-server","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsy6000g3iq212o4z0ne","content":"<p>Cobar作为一个数据库分库分表中间件，既是一台NIO Server，又是NIO Client</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Cobar作为一个数据库分库分表中间件，既是一台NIO Server，又是NIO Client</p>\n"},{"title":"Cobar——SQL如何被分库分表以及执行","date":"2017-09-19T08:58:28.000Z","_content":"","source":"_posts/Cobar-How-sql-executes-in-cobar.md","raw":"---\ntitle: Cobar——SQL如何被分库分表以及执行\ndate: 2017-09-19 16:58:28\ntags: Cobar\n---\n","slug":"Cobar-How-sql-executes-in-cobar","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsy9000i3iq27zsf12m1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Cobar-Performance-Test-With-Sysbench","date":"2017-12-13T11:11:35.000Z","_content":"\n### centos\n\n``` bash\nyum install sysbench\n```\n\nlua目录 /usr/share/sysbench/\n\n由于Cobar不支持SQL 92的表创建，所以需要修改/usr/share/sysbench/oltp_common.lua\n\n如果需要查看帮助\n\n则运行: sysbench [lua_path] help\n比如: sysbench /usr/share/sysbench/oltp_insert.lua help\n\nsysbench --mysql-host=mac \\\n--mysql-port=9696 \\\n--mysql-user=zerodb \\\n--mysql-password=zerodb \\\n--mysql-db=zerodb \\\n--threads=4 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 --events=0 \\\n--percentile=99 \\\n--report-interval=2 \\\n/usr/local/Cellar/sysbench/1.0.11/share/sysbench/oltp_insert.lua \\\n\n#cobar_1\n\nsysbench --mysql-host=10.1.21.148 \\\n--mysql-port=8066 \\\n--mysql-user=user \\\n--mysql-password='user' \\\n--mysql-db=user \\\n--threads=400 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 \\\n--events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\n\n\n#cobar_2\n\nsysbench --mysql-host=10.1.21.147 \\\n--mysql-port=8066 \\\n--mysql-user=user \\\n--mysql-password='user' \\\n--mysql-db=user \\\n--threads=400 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 --events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\n\n### 测试报告\n[root@mq001 ~]# sysbench --mysql-host=10.1.21.147 --mysql-port=8066 --mysql-user=user --mysql-password='user' --mysql-db=user --threads=400 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=60 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua run\nsysbench 1.0.9 (using system LuaJIT 2.0.4)\n\nRunning the test with following options:\nNumber of threads: 400\nReport intermediate results every 5 second(s)\nInitializing random number generator from current time\n\n\nInitializing worker threads...\n\nThreads started!\n\n[ 5s ] thds: 400 tps: 11516.37 qps: 11516.37 (r/w/o: 0.00/11516.37/0.00) lat (ms,99%): 204.11 err/s: 0.00 reconn/s: 0.00\n[ 10s ] thds: 400 tps: 2884.87 qps: 2884.87 (r/w/o: 0.00/2884.87/0.00) lat (ms,99%): 831.46 err/s: 0.00 reconn/s: 0.00\n[ 15s ] thds: 400 tps: 4025.00 qps: 4025.00 (r/w/o: 0.00/4025.00/0.00) lat (ms,99%): 1869.60 err/s: 0.00 reconn/s: 0.00\n[ 20s ] thds: 400 tps: 13497.32 qps: 13497.32 (r/w/o: 0.00/13497.32/0.00) lat (ms,99%): 142.39 err/s: 0.00 reconn/s: 0.00\n[ 25s ] thds: 400 tps: 10908.17 qps: 10908.17 (r/w/o: 0.00/10908.17/0.00) lat (ms,99%): 144.97 err/s: 0.00 reconn/s: 0.00\n[ 30s ] thds: 400 tps: 12280.74 qps: 12280.74 (r/w/o: 0.00/12280.74/0.00) lat (ms,99%): 132.49 err/s: 0.00 reconn/s: 0.00\n[ 35s ] thds: 400 tps: 9783.37 qps: 9783.37 (r/w/o: 0.00/9783.37/0.00) lat (ms,99%): 150.29 err/s: 0.00 reconn/s: 0.00\n[ 40s ] thds: 400 tps: 11703.52 qps: 11703.72 (r/w/o: 0.00/11703.72/0.00) lat (ms,99%): 173.58 err/s: 0.00 reconn/s: 0.00\n[ 45s ] thds: 400 tps: 8253.06 qps: 8252.86 (r/w/o: 0.00/8252.86/0.00) lat (ms,99%): 207.82 err/s: 0.00 reconn/s: 0.00\n[ 50s ] thds: 400 tps: 7148.98 qps: 7149.18 (r/w/o: 0.00/7149.18/0.00) lat (ms,99%): 657.93 err/s: 0.00 reconn/s: 0.00\n[ 55s ] thds: 400 tps: 10911.35 qps: 10911.15 (r/w/o: 0.00/10911.15/0.00) lat (ms,99%): 176.73 err/s: 0.00 reconn/s: 0.00\n[ 60s ] thds: 400 tps: 8702.48 qps: 8702.48 (r/w/o: 0.00/8702.48/0.00) lat (ms,99%): 235.74 err/s: 0.00 reconn/s: 0.00\nSQL statistics:\n    queries performed:\n        read:                            0\n        write:                           558494\n        other:                           0\n        total:                           558494\n    transactions:                        558494 (9273.20 per sec.)\n    queries:                             558494 (9273.20 per sec.)\n    ignored errors:                      0      (0.00 per sec.)\n    reconnects:                          0      (0.00 per sec.)\n\nGeneral statistics:\n    total time:                          60.2244s\n    total number of events:              558494\n\nLatency (ms):\n         min:                                  3.89\n         avg:                                 43.02\n         max:                               2881.01\n         99th percentile:                    253.35\n         sum:                            24023700.41\n\nThreads fairness:\n    events (avg/stddev):           1396.2350/30.84\n    execution time (avg/stddev):   60.0593/0.05\n\n\n\n[root@mq001 ~]# sysbench --mysql-host=10.1.21.148 --mysql-port=8066 --mysql-user=user --mysql-password='user' --mysql-db=user --threads=400 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=60 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua run\nsysbench 1.0.9 (using system LuaJIT 2.0.4)\n\nRunning the test with following options:\nNumber of threads: 400\nReport intermediate results every 5 second(s)\nInitializing random number generator from current time\n\n\nInitializing worker threads...\n\nThreads started!\n\n[ 5s ] thds: 400 tps: 10470.98 qps: 10470.98 (r/w/o: 0.00/10470.98/0.00) lat (ms,99%): 262.64 err/s: 0.00 reconn/s: 0.00\n[ 10s ] thds: 400 tps: 3020.06 qps: 3020.06 (r/w/o: 0.00/3020.06/0.00) lat (ms,99%): 1050.76 err/s: 0.00 reconn/s: 0.00\n[ 15s ] thds: 400 tps: 1107.64 qps: 1107.64 (r/w/o: 0.00/1107.64/0.00) lat (ms,99%): 1327.91 err/s: 0.00 reconn/s: 0.00\n[ 20s ] thds: 400 tps: 7395.23 qps: 7395.23 (r/w/o: 0.00/7395.23/0.00) lat (ms,99%): 816.63 err/s: 0.00 reconn/s: 0.00\n[ 25s ] thds: 400 tps: 12654.11 qps: 12654.11 (r/w/o: 0.00/12654.11/0.00) lat (ms,99%): 125.52 err/s: 0.00 reconn/s: 0.00\n[ 30s ] thds: 400 tps: 10854.72 qps: 10854.92 (r/w/o: 0.00/10854.92/0.00) lat (ms,99%): 153.02 err/s: 0.00 reconn/s: 0.00\n[ 35s ] thds: 400 tps: 11832.81 qps: 11832.61 (r/w/o: 0.00/11832.61/0.00) lat (ms,99%): 186.54 err/s: 0.00 reconn/s: 0.00\n[ 40s ] thds: 400 tps: 6895.44 qps: 6895.44 (r/w/o: 0.00/6895.44/0.00) lat (ms,99%): 257.95 err/s: 0.00 reconn/s: 0.00\n[ 45s ] thds: 400 tps: 12907.06 qps: 12907.06 (r/w/o: 0.00/12907.06/0.00) lat (ms,99%): 158.63 err/s: 0.00 reconn/s: 0.00\n[ 50s ] thds: 400 tps: 7760.80 qps: 7760.80 (r/w/o: 0.00/7760.80/0.00) lat (ms,99%): 292.60 err/s: 0.00 reconn/s: 0.00\n[ 55s ] thds: 400 tps: 11595.84 qps: 11595.84 (r/w/o: 0.00/11595.84/0.00) lat (ms,99%): 161.51 err/s: 0.00 reconn/s: 0.00\n[ 60s ] thds: 400 tps: 10314.36 qps: 10314.36 (r/w/o: 0.00/10314.36/0.00) lat (ms,99%): 142.39 err/s: 0.00 reconn/s: 0.00\nSQL statistics:\n    queries performed:\n        read:                            0\n        write:                           534637\n        other:                           0\n        total:                           534637\n    transactions:                        534637 (8890.97 per sec.)\n    queries:                             534637 (8890.97 per sec.)\n    ignored errors:                      0      (0.00 per sec.)\n    reconnects:                          0      (0.00 per sec.)\n\nGeneral statistics:\n    total time:                          60.1304s\n    total number of events:              534637\n\nLatency (ms):\n         min:                                  4.14\n         avg:                                 44.91\n         max:                               3066.99\n         99th percentile:                    292.60\n         sum:                            24012284.54\n\nThreads fairness:\n    events (avg/stddev):           1336.5925/23.11\n    execution time (avg/stddev):   60.0307/0.03\n    \n    \n    \n    \n\nsysbench --mysql-host=10.1.134.195 \\\n--mysql-port=8066 \\\n--mysql-user=user \\\n--mysql-password='user' \\\n--mysql-db=user \\\n--threads=400 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 \\\n--events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\n\n\nsysbench --mysql-host=10.1.21.242 \\\n--mysql-port=9696 \\\n--mysql-user=zerodb \\\n--mysql-password='zerodb' \\\n--mysql-db=zerodb \\\n--threads=10 \\\n--debug=on \\\n--verbosity=5 \\\n--tables=5 \\\n--events=1 \\\n--auto_inc=off \\\n--table-size=1000 \\\n--db-driver=mysql \\\n--time=6000000 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_read_only.lua \\\nrun\n\n\n\n# zerodb\nsysbench --mysql-host=10.1.21.242 \\\n--mysql-port=9696 \\\n--mysql-user=zerodb \\\n--mysql-password='zerodb' \\\n--mysql-db=zerodb \\\n--threads=10 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 --events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\ncleanup\n\nsysbench --mysql-host=10.1.21.242 \\\n--mysql-port=9696 \\\n--mysql-user=zerodb \\\n--mysql-password='zerodb' \\\n--mysql-db=zerodb \\\n--threads=10 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 --events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\nprepare\n\nsysbench --mysql-host=10.1.21.242 \\\n--mysql-port=9696 \\\n--mysql-user=zerodb \\\n--mysql-password='zerodb' \\\n--mysql-db=zerodb \\\n--threads=400 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 --events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\nrun\n\nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[899:{SchemaIndex=225, TableIndex=899, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1592131459, 7, '55016285732-53347045338-85834558147-71206675947-20854212178-67704861318-55023920639-15021922692-58783263226-91831209826', '44804973802-80594424819-30662288113-07543047794-69158617276')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[607:{SchemaIndex=152, TableIndex=607, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1551461983, 1, '97565032345-06095273461-70708868939-89114711497-07191112359-84320966593-06915637429-34011520393-29123922986-41181266499', '10350064023-47161933420-32840507920-65997397770-16177253238')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[371:{SchemaIndex=93, TableIndex=371, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1688397171, 3, '66563027950-07665251035-46015031422-61663761332-16063948763-45273359443-68411883367-29428347771-65572934442-17492196263', '60851935379-49894017653-67952828882-67412344041-59230452535')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[1011:{SchemaIndex=253, TableIndex=1011, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-573803507, 2, '43589791346-92222019297-77586384271-52778612091-96284921979-05035493725-49350672130-03697130813-21052521840-31158762545', '33228172883-24963516238-59142423481-48021525640-21772792414')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1001, mergeExecResult: 0. shardingNode:map[310:{SchemaIndex=78, TableIndex=310, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (439335222, 7, '03793368943-50266953542-49577833032-14468376728-10198261385-85128057368-15281808692-43095784178-01078624681-09027567677', '45982088127-90369291605-80044281219-46887615792-75467747528')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 999, mergeExecResult: 0. shardingNode:map[259:{SchemaIndex=65, TableIndex=259, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (824478979, 9, '79929455805-82686000395-87933678180-97427805059-78850675331-66749630290-23371965370-59789760435-11687903028-37111392097', '65387439360-90889047465-34899315444-83593158053-88419722270')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[388:{SchemaIndex=98, TableIndex=388, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1778834820, 4, '26400620948-86886163258-66955677020-24736956201-37633810654-62170837016-10953232786-08731106510-27930064178-11956848338', '22734010461-63969213016-54927682118-22921617753-25869637636')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[345:{SchemaIndex=87, TableIndex=345, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1906262361, 4, '73054929345-92331883054-27511894619-20000378864-11948567194-86713567705-11190297445-34047180586-99650690403-71903892017', '07335571244-33555087386-76380202973-29490934882-40814481851')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[569:{SchemaIndex=143, TableIndex=569, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1606555193, 2, '94281857928-97538212927-39261666932-79938992409-52558016112-06785833668-50810169070-34555719774-82330250972-35853785503', '29683325026-64124354800-63566774522-19722425169-37547560762')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[906:{SchemaIndex=227, TableIndex=906, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1143670666, 7, '74870370257-63163303467-80061015187-84192128665-25175084977-80554698357-24269465921-53186773519-78675020561-83488552374', '73368269204-64304332325-34620567277-68846684629-38045820340')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[941:{SchemaIndex=236, TableIndex=941, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-1370776493, 6, '16692170437-43512178684-59516594203-75377838995-76081749306-71167865747-97237301685-23453441670-03667446181-56604717727', '14195711604-53513247591-07873804194-96431257292-05520461785')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[872:{SchemaIndex=219, TableIndex=872, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1208557416, 5, '27703568859-81266825379-86789890837-60513053664-22258866897-34966682979-82761864561-83949706302-60135012966-31647733109', '63271991640-87709697591-13072925018-38646644832-79179029573')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[991:{SchemaIndex=248, TableIndex=991, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (138564575, 6, '26857888685-88370802193-51045899118-07572056078-70111763976-05806767425-30208609378-20016792779-48308493020-29821526191', '61555808494-05287717368-66884245341-45983655335-60458704606')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1007, mergeExecResult: 0. shardingNode:map[449:{SchemaIndex=113, TableIndex=449, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-229865921, 8, '14034106238-21876701329-38233326181-31158038417-73928237004-22908354046-72713486563-40610785127-99166317018-52234063725', '23168975405-73598149943-63125122764-74527985990-06171559404')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[959:{SchemaIndex=240, TableIndex=959, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-677583807, 4, '40735866383-98457016615-08789114417-03599576561-48782283253-32055567198-88072330194-83020475968-03693883045-96278614943', '70150968961-19151317381-16983120036-88185867422-84862477300')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1006, mergeExecResult: 0. shardingNode:map[406:{SchemaIndex=102, TableIndex=406, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-2093701526, 5, '09210536591-41896791043-73295525884-89613310006-75387609760-41655764025-47137540812-97100201238-15965683915-13727887851', '48024514833-13441113380-49081922507-17183150276-06208568092')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[894:{SchemaIndex=224, TableIndex=894, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (108403582, 4, '58477996001-39515710854-83438883003-74672331816-19403553257-36113016280-00822951895-43706580851-50122510142-72629874469', '25950012615-74047249694-75644797724-67405314152-48742553448')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[824:{SchemaIndex=207, TableIndex=824, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1108509496, 2, '05591703103-07428761202-09014510822-44571443153-87746638001-18005366596-37591757698-85345493107-52688524466-97341165803', '90287453968-47714845240-54141462203-72968014933-11681199861')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[960:{SchemaIndex=241, TableIndex=960, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-432972736, 4, '32013395637-31037790439-99508763633-39582502523-46934970326-99846192559-79844868065-81128826635-19475623448-94555401729', '72848617704-77451404798-55770002912-34209086424-23821979141')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[864:{SchemaIndex=217, TableIndex=864, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (209038176, 6, '31725269303-67222682770-97738396828-19717571752-01126165612-57542830563-51718817223-13687491781-38891241679-10677758794', '40604117998-67635443824-03882862739-68433432919-44278589057')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[525:{SchemaIndex=132, TableIndex=525, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-663100941, 3, '13572309986-10356575142-87428874956-18162116973-83396135908-09352768769-83603227505-94165603992-17437041978-81761343722', '58884262253-26008842705-81702669160-02709154611-78739667686')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[821:{SchemaIndex=206, TableIndex=821, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1290297141, 6, '28650953615-66926208686-47052429218-34545146184-51693579732-60563146329-00350338711-30136625347-99506216978-22404723673', '30345581431-18594298965-23203468098-48853746952-30033247101')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[881:{SchemaIndex=221, TableIndex=881, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (2128759665, 3, '23557322059-62351008582-19218938648-55023996016-67978090662-04498693910-40333149725-65457542876-11556698223-86845640120', '39531266486-08252986785-52805405505-62972899514-62765043827')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[829:{SchemaIndex=208, TableIndex=829, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1081064253, 2, '39396011527-03550826801-53544579241-44145722341-56423193708-85298116954-45172197891-54532848324-82241582599-97563898680', '76749800295-63255838342-73258070193-02305060704-64352300433')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[900:{SchemaIndex=226, TableIndex=900, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-513806212, 1, '16727493623-40348083665-41922314110-05150944505-43353212884-59194917800-00753396008-63562258886-84259052626-93713085152', '38634951090-07591809914-73325301815-73315254313-82978384844')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1, mergeExecResult: 0. shardingNode:map[863:{SchemaIndex=216, TableIndex=863, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-450094943, 6, '23924438266-62111362125-81473873200-06328498397-88922636306-39182947784-05124699385-49780077333-57313760145-54634535492', '96577223660-83042935121-28454288566-32057418883-39061132652')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[963:{SchemaIndex=241, TableIndex=963, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (1800163267, 4, '27948346446-05701199368-49149768636-18762164887-01870692332-13661773677-35851324771-46733712098-36653074427-31181566769', '08781105428-22812332073-21224324603-72676647429-86438534524')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[878:{SchemaIndex=220, TableIndex=878, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1535190894, 9, '46310600095-97541020554-94065740469-24853513335-69630566641-31721053084-60343664925-46348792383-87749652424-52899212634', '41944783155-15764748316-26823908956-07652542569-85074827204')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[906:{SchemaIndex=227, TableIndex=906, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1945995146, 4, '64447284661-78831878306-27636005022-88863833954-72613803410-72661880191-81775646793-56738842216-16376642732-30662007847', '44349800594-98690127361-78211321236-38340738575-94555021426')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[907:{SchemaIndex=227, TableIndex=907, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1719256971, 3, '36693810506-14727560109-48871542333-86332816255-91899190554-43809786563-22813456576-32468291237-08105779091-35654765264', '76792216525-13152293559-11187746420-35413475429-73316527358')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[827:{SchemaIndex=207, TableIndex=827, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1191957307, 3, '02373892720-70783246981-33072353568-68101913427-25982074179-25716557733-53487403333-33176741697-19961659954-24745733546', '65228452942-44586411798-63293957289-46889416058-55247585232')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[715:{SchemaIndex=179, TableIndex=715, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-368940747, 10, '83732843347-38915816227-71028864502-83867874900-55259635749-04867892981-61246311166-86657029985-98371125854-01109713202', '28665022675-32159696841-27962719413-92137483719-65438251505')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[531:{SchemaIndex=133, TableIndex=531, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (296709651, 4, '68512385573-12594713777-31891099071-55341413329-96572532552-89441743744-75535604911-39664974035-50293453830-41657909966', '54516090919-10379612997-70745484084-47657473576-34684395884')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[1010:{SchemaIndex=253, TableIndex=1010, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (375408626, 5, '86917579879-69750606525-04310713441-66206378609-22671203503-85955817483-08099675016-87194148638-56030296183-72576969654', '14638356398-42816005551-86372571322-85471822123-78848498639')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 207, mergeExecResult: 0. shardingNode:map[481:{SchemaIndex=121, TableIndex=481, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-453506529, 7, '05922416371-88423926572-06168309932-36230491079-35838894643-96519731061-10785734640-51619035736-36739664574-07173836937', '86251074060-14148969607-50675271708-72280786641-89845672651')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 999, mergeExecResult: 0. shardingNode:map[506:{SchemaIndex=127, TableIndex=506, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (923516410, 1, '71118741783-11388565696-96706199622-38503412573-05309353257-45864148538-09400667746-21110528894-17837136283-91361843504', '67292585002-85708710331-29800085937-37291514623-47320174130')] \n\n\n\n\nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 306, mergeExecResult: 0. shardingNode:map[540:{SchemaIndex=136, TableIndex=540, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1344100892, 4, '37923605607-42327774961-35128132820-48158088043-25957128013-51759124002-40449799093-68433809807-31405796686-22817252999', '94291235269-60160247565-39950122186-97684115599-96232437155')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 211, mergeExecResult: 0. shardingNode:map[540:{SchemaIndex=136, TableIndex=540, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-757833244, 5, '50104262688-83666007823-06989738144-95141595109-93329094811-13832991101-93076033912-05017862363-35692005246-88744289137', '54081433849-09378248558-38274752100-88855316211-27289637272')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[198:{SchemaIndex=50, TableIndex=198, HostGroup=hostGroup1}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (652469446, 1, '07652454524-22981957011-41438122391-90347773905-88663504044-48425601588-32127975840-28199749965-27298300589-25715051794', '60470366939-49887579866-34848349508-29262200362-52000338086')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[670:{SchemaIndex=168, TableIndex=670, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-212205214, 3, '39093408635-10213704095-82878149257-88673860178-07278582464-52697390774-95388237318-03462450231-66036638124-64228596635', '38716722580-86486363760-61985600779-83841271441-42765235992')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 248, mergeExecResult: 0. shardingNode:map[594:{SchemaIndex=149, TableIndex=594, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1136835154, 2, '23757270379-51595389012-47476784586-71294005118-20959815636-40533304860-41036462462-22519409530-16151251756-29363403201', '02895678318-89791495824-44276206517-37575326693-35714861579')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 196, mergeExecResult: 0. shardingNode:map[596:{SchemaIndex=150, TableIndex=596, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (927250004, 3, '02232667199-83769701794-18129066725-31520472849-93375763771-42931518091-56094856485-24182688367-31807939112-07474880757', '46530309679-12705910558-69428237706-14629411089-19801742204')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 213, mergeExecResult: 0. shardingNode:map[568:{SchemaIndex=143, TableIndex=568, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1908502072, 6, '11131352749-42538464007-16895664672-62644300750-86974265339-82077852146-68660984992-78157770948-82596046151-02353070903', '35289675345-82804575493-00647347117-53443940605-48670213485')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[530:{SchemaIndex=133, TableIndex=530, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1565462034, 2, '03766551315-88042959333-06619558863-52259377137-27072539179-52210031586-63547684874-18650692849-22136096911-63673950864', '23300762166-38283070103-67223042934-76314148059-35039279078')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 252, mergeExecResult: 0. shardingNode:map[705:{SchemaIndex=177, TableIndex=705, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-282929857, 9, '78018924775-94910259974-14900983402-30428448745-60064721591-40668444882-53712901782-65346911189-59688209606-74312372904', '82234943021-50353143509-80352130420-57571772487-81475633439')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 291, mergeExecResult: 0. shardingNode:map[724:{SchemaIndex=182, TableIndex=724, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (2109119188, 7, '36086413796-51767176683-52982238848-36460965892-84578503998-21697029291-39139590496-18305440259-61532992900-70589028518', '30048526034-08924322516-87289516951-51922079500-47125778015')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 210, mergeExecResult: 0. shardingNode:map[573:{SchemaIndex=144, TableIndex=573, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-994558525, 8, '74078055913-58294585862-48131723756-93089582597-72949713745-85429496032-27905841748-82110966829-12174780172-45947256767', '52598986037-80854622196-65516850169-26314282473-46184813701')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 99, mergeExecResult: 0. shardingNode:map[701:{SchemaIndex=176, TableIndex=701, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1290611389, 10, '06010961323-54786660073-11823817491-71384866194-20002003501-13527828508-52664186690-95551041252-11585296099-86883272955', '35567244596-82663971593-11831798779-27870930145-87441039863')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 292, mergeExecResult: 0. shardingNode:map[567:{SchemaIndex=142, TableIndex=567, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (810312247, 10, '41210873160-21444867641-91122365510-19036499914-34569882163-29091701055-84873343605-60726600041-00757500001-24263691698', '41652074477-40057441865-33409084588-16838407116-03941310610')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[213:{SchemaIndex=54, TableIndex=213, HostGroup=hostGroup1}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1881853141, 2, '14742564348-19913327041-96137703234-33860693319-12765733015-19685217285-90407570147-69715707192-71609875203-72224693707', '62398998246-64288014470-28245239723-29976129053-08238346550')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 242, mergeExecResult: 0. shardingNode:map[698:{SchemaIndex=175, TableIndex=698, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1011920570, 2, '33865708347-82274332444-45097600411-92274439334-16926356904-33828206076-16463987600-06687756787-06453656924-53622006994', '48462480629-04943720987-66250435599-66843177447-86484400166')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 195, mergeExecResult: 0. shardingNode:map[710:{SchemaIndex=178, TableIndex=710, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-2128817862, 7, '12483300987-88535524922-66334741529-64659385522-75032596868-93466219012-01222978665-55122702202-84142740410-53583589563', '89132580254-79206347601-13534456013-96027776935-07650599065')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 233, mergeExecResult: 0. shardingNode:map[544:{SchemaIndex=137, TableIndex=544, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1496016416, 9, '99154323337-90872497215-53698284897-04686362817-35622767062-48356019022-04016504226-75493501145-38429448892-66989460733', '84409926268-28404056573-96777093808-13481662538-98898905310')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 27, mergeExecResult: 0. shardingNode:map[907:{SchemaIndex=227, TableIndex=907, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (756613003, 1, '48041615531-14651008388-14559884387-33045819966-91038786346-39394412181-13147015451-43265025586-90014901196-20159726596', '62496325099-63432555894-84244639858-58924561742-12138512609')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 284, mergeExecResult: 0. shardingNode:map[525:{SchemaIndex=132, TableIndex=525, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (588268045, 3, '01778869912-44391681202-43730989451-99650497628-58071023040-36244500937-05173857724-21592385062-52662008534-88410130321', '68551597952-73268487812-26478068307-11227961732-49092247276')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 229, mergeExecResult: 0. shardingNode:map[674:{SchemaIndex=169, TableIndex=674, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (75111074, 1, '07857287095-83026714634-10012972058-11441297287-80787536524-31038348780-79408482259-95286783641-23620583564-94195135059', '39714908056-38058099094-71552841772-10457961132-39419941227')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 230, mergeExecResult: 0. shardingNode:map[577:{SchemaIndex=145, TableIndex=577, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-911965761, 8, '07321418565-94055920833-16462957068-14933742620-00134077423-05303377934-66121817102-49230219319-72774150061-80468601177', '26522648558-75134929821-83594530381-47917024515-31668467194')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 232, mergeExecResult: 0. shardingNode:map[513:{SchemaIndex=129, TableIndex=513, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1315070465, 5, '15474433240-84784850443-17796367719-48021520867-10943303644-48200729918-91013947900-33061132253-28956163141-98846516045', '99644114596-46918915095-13462299586-15204837308-12785249281')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 231, mergeExecResult: 0. shardingNode:map[737:{SchemaIndex=185, TableIndex=737, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-180994785, 9, '61681162669-07252910162-88941330016-07633567093-86234290556-74605484081-92189953463-28499401861-08881094341-04206273246', '73069152681-47514577462-53755512339-63165295325-04957863379')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 225, mergeExecResult: 0. shardingNode:map[583:{SchemaIndex=146, TableIndex=583, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (905672263, 5, '11686869034-48032081508-20645314791-73241768758-13634493369-36096577158-76040275597-65556337906-73745369125-93817830861', '25154935190-35760055237-67095134841-73686707222-08327146392')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 227, mergeExecResult: 0. shardingNode:map[568:{SchemaIndex=143, TableIndex=568, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1028081208, 6, '65787201754-47681590360-50036937953-38544197509-01589612011-17576022949-32999165698-83171817746-37315560344-14463882405', '65637926145-34138639858-41094177281-29428779399-44688752051')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 232, mergeExecResult: 0. shardingNode:map[558:{SchemaIndex=140, TableIndex=558, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (278584878, 10, '32358945918-66413584434-88058020708-48390261093-67208582401-88568979078-90497400157-49426845556-80952580018-13610087462', '14198786100-85805610838-89824761297-62058901344-60492560838')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 228, mergeExecResult: 0. shardingNode:map[649:{SchemaIndex=163, TableIndex=649, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (1183431305, 2, '43858458237-46788126262-05213368147-07302202409-13593899883-99375055319-42875375550-56499216168-01796902390-08647652700', '48205424174-34611724289-69246697079-03898745311-99595319598')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 26, mergeExecResult: 0. shardingNode:map[1002:{SchemaIndex=251, TableIndex=1002, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1701967850, 9, '59147040383-79705593723-62886101805-60535881029-18413556495-06238443919-02766097021-38361379870-67179305438-52530038201', '14770296700-13396847549-83905253251-99337969432-58669912709')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 229, mergeExecResult: 0. shardingNode:map[745:{SchemaIndex=187, TableIndex=745, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-1169184489, 7, '64955629118-36147506634-51676575477-92147977264-45999410094-15567300060-12836575112-28470342888-04361926080-90629622527', '86593300354-87140619605-87718697448-88392415837-04795141111')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 272, mergeExecResult: 0. shardingNode:map[662:{SchemaIndex=166, TableIndex=662, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1555424918, 10, '11260581771-57660361810-58723152189-43635886031-41094065361-37903459575-65856768363-01843670891-17848285384-92171598763', '36462031678-64770373669-77316073133-32672501580-50753545368')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 271, mergeExecResult: 0. shardingNode:map[736:{SchemaIndex=185, TableIndex=736, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-270642912, 9, '87806093665-04774113218-83983577041-09351362099-88339377062-22401969710-89370302094-61598971830-04573362584-60421137580', '26415700902-09148763904-87375314444-00285784497-80449574080')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 222, mergeExecResult: 0. shardingNode:map[588:{SchemaIndex=148, TableIndex=588, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1608970828, 2, '75571666926-33738024136-84313793696-10714487345-57088294174-41711334397-51382524640-08327299973-66970622008-15344703881', '73366501022-14368954292-21130701303-33960859630-28160972955')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 220, mergeExecResult: 0. shardingNode:map[556:{SchemaIndex=140, TableIndex=556, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-993863212, 3, '68136313990-05892185009-94544559127-32267303237-37763842514-89959134082-97215598641-72307869276-49642816905-24994127953', '97111382859-69888150629-89398585714-99569889618-30099083026')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 220, mergeExecResult: 0. shardingNode:map[513:{SchemaIndex=129, TableIndex=513, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1299240449, 6, '13580427730-91599560017-42392676834-62860979245-65274043134-68243135520-42672727926-56794775679-69217526806-27227304772', '15736027942-38175115801-93773367279-77944721463-03173899187')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 214, mergeExecResult: 0. shardingNode:map[579:{SchemaIndex=145, TableIndex=579, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1346301507, 2, '95777728263-97322915970-24025444526-11872987788-74589515383-37108287704-62890589663-84327075019-58161194629-66166453693', '43925335448-41493749427-45817169562-78879091928-39249185154')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 252, mergeExecResult: 0. shardingNode:map[723:{SchemaIndex=181, TableIndex=723, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1604556499, 3, '54964824319-34611710514-15902154995-18014105243-70193115677-91112406449-61348366967-41301887681-73892593737-54039590822', '26491514771-24473569991-16656607124-07593925149-74926670900')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 253, mergeExecResult: 0. shardingNode:map[715:{SchemaIndex=179, TableIndex=715, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (533688011, 7, '17872695538-16064539790-18108982113-60646269894-74784931403-89606878485-67937667670-39824753762-37339034055-79511964331', '65227853620-62393117281-88901273019-02060144110-40123779052')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[731:{SchemaIndex=183, TableIndex=731, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (548553435, 7, '59524856205-92318067592-84001816236-15799238765-61939312958-49774297702-51059777347-11521186806-90725070157-29567571966', '72604893873-81336794708-64989781571-89144801847-53529920629')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 296, mergeExecResult: 0. shardingNode:map[646:{SchemaIndex=162, TableIndex=646, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1980507782, 8, '15361099362-33426846104-81568076007-88926275697-54147190617-21941361738-39219198670-72817831326-95768248501-29228997291', '51713925651-55077435995-56372978084-60334222441-07023013203')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 27, mergeExecResult: 0. shardingNode:map[1023:{SchemaIndex=256, TableIndex=1023, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (419830783, 9, '39839456224-14625126106-10611694673-69035645226-20746732552-01963419766-94676550107-32542648198-96549393904-39850608367', '69725922822-08559910362-36080928509-49601235010-15261238716')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 296, mergeExecResult: 0. shardingNode:map[612:{SchemaIndex=154, TableIndex=612, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1848104548, 6, '02931425025-68282480940-67294056291-41225608697-44038095895-05390291535-10414730978-25086630856-84460614365-62218384416', '74426157735-27538600335-93122572838-36921241106-44481214039')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 305, mergeExecResult: 0. shardingNode:map[517:{SchemaIndex=130, TableIndex=517, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-543662597,\n\ncobar:\nsysbench --mysql-host=10.1.21.242 --mysql-port=8066 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=10 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua cleanup\nsysbench --mysql-host=10.1.21.242 --mysql-port=8066 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=10 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua prepare\nsysbench --mysql-host=10.1.21.242 --mysql-port=8066 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=400 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua run\n\nzero-proxy\nsysbench --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=10 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua cleanup\nsysbench --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=10 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua prepare\nsysbench --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=400 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua run\n\n\n\n\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb  --oltp-tables-count=5 prepare\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb  --oltp-tables-count=5 cleanup\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb --ssh-user=root --ssh-password=sdfsdf --oltp-tables-count=5 --write-threads=128 --read-threads=8 --max-time=3600 random\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb --ssh-user=root --ssh-password=sdfsdf --oltp-tables-count=5 --write-threads=128 --read-threads=8 --max-time=3600 seq\n\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb --ssh-user=root --ssh-password=sdfsdf --oltp-tables-count=5 --write-threads=4 --read-threads=300 --update-threads=20 --delete-threads=10 --max-time=360000000 random\n\n\n\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb --ssh-user=root --ssh-password=sdfsdf --oltp-tables-count=5 --write-threads=400 --read-threads=400 --max-time=3600 random","source":"_posts/Cobar-Performance-Test-With-Sysbench.md","raw":"---\ntitle: Cobar-Performance-Test-With-Sysbench\ndate: 2017-12-13 19:11:35\ntags: Cobar\n---\n\n### centos\n\n``` bash\nyum install sysbench\n```\n\nlua目录 /usr/share/sysbench/\n\n由于Cobar不支持SQL 92的表创建，所以需要修改/usr/share/sysbench/oltp_common.lua\n\n如果需要查看帮助\n\n则运行: sysbench [lua_path] help\n比如: sysbench /usr/share/sysbench/oltp_insert.lua help\n\nsysbench --mysql-host=mac \\\n--mysql-port=9696 \\\n--mysql-user=zerodb \\\n--mysql-password=zerodb \\\n--mysql-db=zerodb \\\n--threads=4 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 --events=0 \\\n--percentile=99 \\\n--report-interval=2 \\\n/usr/local/Cellar/sysbench/1.0.11/share/sysbench/oltp_insert.lua \\\n\n#cobar_1\n\nsysbench --mysql-host=10.1.21.148 \\\n--mysql-port=8066 \\\n--mysql-user=user \\\n--mysql-password='user' \\\n--mysql-db=user \\\n--threads=400 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 \\\n--events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\n\n\n#cobar_2\n\nsysbench --mysql-host=10.1.21.147 \\\n--mysql-port=8066 \\\n--mysql-user=user \\\n--mysql-password='user' \\\n--mysql-db=user \\\n--threads=400 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 --events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\n\n### 测试报告\n[root@mq001 ~]# sysbench --mysql-host=10.1.21.147 --mysql-port=8066 --mysql-user=user --mysql-password='user' --mysql-db=user --threads=400 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=60 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua run\nsysbench 1.0.9 (using system LuaJIT 2.0.4)\n\nRunning the test with following options:\nNumber of threads: 400\nReport intermediate results every 5 second(s)\nInitializing random number generator from current time\n\n\nInitializing worker threads...\n\nThreads started!\n\n[ 5s ] thds: 400 tps: 11516.37 qps: 11516.37 (r/w/o: 0.00/11516.37/0.00) lat (ms,99%): 204.11 err/s: 0.00 reconn/s: 0.00\n[ 10s ] thds: 400 tps: 2884.87 qps: 2884.87 (r/w/o: 0.00/2884.87/0.00) lat (ms,99%): 831.46 err/s: 0.00 reconn/s: 0.00\n[ 15s ] thds: 400 tps: 4025.00 qps: 4025.00 (r/w/o: 0.00/4025.00/0.00) lat (ms,99%): 1869.60 err/s: 0.00 reconn/s: 0.00\n[ 20s ] thds: 400 tps: 13497.32 qps: 13497.32 (r/w/o: 0.00/13497.32/0.00) lat (ms,99%): 142.39 err/s: 0.00 reconn/s: 0.00\n[ 25s ] thds: 400 tps: 10908.17 qps: 10908.17 (r/w/o: 0.00/10908.17/0.00) lat (ms,99%): 144.97 err/s: 0.00 reconn/s: 0.00\n[ 30s ] thds: 400 tps: 12280.74 qps: 12280.74 (r/w/o: 0.00/12280.74/0.00) lat (ms,99%): 132.49 err/s: 0.00 reconn/s: 0.00\n[ 35s ] thds: 400 tps: 9783.37 qps: 9783.37 (r/w/o: 0.00/9783.37/0.00) lat (ms,99%): 150.29 err/s: 0.00 reconn/s: 0.00\n[ 40s ] thds: 400 tps: 11703.52 qps: 11703.72 (r/w/o: 0.00/11703.72/0.00) lat (ms,99%): 173.58 err/s: 0.00 reconn/s: 0.00\n[ 45s ] thds: 400 tps: 8253.06 qps: 8252.86 (r/w/o: 0.00/8252.86/0.00) lat (ms,99%): 207.82 err/s: 0.00 reconn/s: 0.00\n[ 50s ] thds: 400 tps: 7148.98 qps: 7149.18 (r/w/o: 0.00/7149.18/0.00) lat (ms,99%): 657.93 err/s: 0.00 reconn/s: 0.00\n[ 55s ] thds: 400 tps: 10911.35 qps: 10911.15 (r/w/o: 0.00/10911.15/0.00) lat (ms,99%): 176.73 err/s: 0.00 reconn/s: 0.00\n[ 60s ] thds: 400 tps: 8702.48 qps: 8702.48 (r/w/o: 0.00/8702.48/0.00) lat (ms,99%): 235.74 err/s: 0.00 reconn/s: 0.00\nSQL statistics:\n    queries performed:\n        read:                            0\n        write:                           558494\n        other:                           0\n        total:                           558494\n    transactions:                        558494 (9273.20 per sec.)\n    queries:                             558494 (9273.20 per sec.)\n    ignored errors:                      0      (0.00 per sec.)\n    reconnects:                          0      (0.00 per sec.)\n\nGeneral statistics:\n    total time:                          60.2244s\n    total number of events:              558494\n\nLatency (ms):\n         min:                                  3.89\n         avg:                                 43.02\n         max:                               2881.01\n         99th percentile:                    253.35\n         sum:                            24023700.41\n\nThreads fairness:\n    events (avg/stddev):           1396.2350/30.84\n    execution time (avg/stddev):   60.0593/0.05\n\n\n\n[root@mq001 ~]# sysbench --mysql-host=10.1.21.148 --mysql-port=8066 --mysql-user=user --mysql-password='user' --mysql-db=user --threads=400 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=60 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua run\nsysbench 1.0.9 (using system LuaJIT 2.0.4)\n\nRunning the test with following options:\nNumber of threads: 400\nReport intermediate results every 5 second(s)\nInitializing random number generator from current time\n\n\nInitializing worker threads...\n\nThreads started!\n\n[ 5s ] thds: 400 tps: 10470.98 qps: 10470.98 (r/w/o: 0.00/10470.98/0.00) lat (ms,99%): 262.64 err/s: 0.00 reconn/s: 0.00\n[ 10s ] thds: 400 tps: 3020.06 qps: 3020.06 (r/w/o: 0.00/3020.06/0.00) lat (ms,99%): 1050.76 err/s: 0.00 reconn/s: 0.00\n[ 15s ] thds: 400 tps: 1107.64 qps: 1107.64 (r/w/o: 0.00/1107.64/0.00) lat (ms,99%): 1327.91 err/s: 0.00 reconn/s: 0.00\n[ 20s ] thds: 400 tps: 7395.23 qps: 7395.23 (r/w/o: 0.00/7395.23/0.00) lat (ms,99%): 816.63 err/s: 0.00 reconn/s: 0.00\n[ 25s ] thds: 400 tps: 12654.11 qps: 12654.11 (r/w/o: 0.00/12654.11/0.00) lat (ms,99%): 125.52 err/s: 0.00 reconn/s: 0.00\n[ 30s ] thds: 400 tps: 10854.72 qps: 10854.92 (r/w/o: 0.00/10854.92/0.00) lat (ms,99%): 153.02 err/s: 0.00 reconn/s: 0.00\n[ 35s ] thds: 400 tps: 11832.81 qps: 11832.61 (r/w/o: 0.00/11832.61/0.00) lat (ms,99%): 186.54 err/s: 0.00 reconn/s: 0.00\n[ 40s ] thds: 400 tps: 6895.44 qps: 6895.44 (r/w/o: 0.00/6895.44/0.00) lat (ms,99%): 257.95 err/s: 0.00 reconn/s: 0.00\n[ 45s ] thds: 400 tps: 12907.06 qps: 12907.06 (r/w/o: 0.00/12907.06/0.00) lat (ms,99%): 158.63 err/s: 0.00 reconn/s: 0.00\n[ 50s ] thds: 400 tps: 7760.80 qps: 7760.80 (r/w/o: 0.00/7760.80/0.00) lat (ms,99%): 292.60 err/s: 0.00 reconn/s: 0.00\n[ 55s ] thds: 400 tps: 11595.84 qps: 11595.84 (r/w/o: 0.00/11595.84/0.00) lat (ms,99%): 161.51 err/s: 0.00 reconn/s: 0.00\n[ 60s ] thds: 400 tps: 10314.36 qps: 10314.36 (r/w/o: 0.00/10314.36/0.00) lat (ms,99%): 142.39 err/s: 0.00 reconn/s: 0.00\nSQL statistics:\n    queries performed:\n        read:                            0\n        write:                           534637\n        other:                           0\n        total:                           534637\n    transactions:                        534637 (8890.97 per sec.)\n    queries:                             534637 (8890.97 per sec.)\n    ignored errors:                      0      (0.00 per sec.)\n    reconnects:                          0      (0.00 per sec.)\n\nGeneral statistics:\n    total time:                          60.1304s\n    total number of events:              534637\n\nLatency (ms):\n         min:                                  4.14\n         avg:                                 44.91\n         max:                               3066.99\n         99th percentile:                    292.60\n         sum:                            24012284.54\n\nThreads fairness:\n    events (avg/stddev):           1336.5925/23.11\n    execution time (avg/stddev):   60.0307/0.03\n    \n    \n    \n    \n\nsysbench --mysql-host=10.1.134.195 \\\n--mysql-port=8066 \\\n--mysql-user=user \\\n--mysql-password='user' \\\n--mysql-db=user \\\n--threads=400 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 \\\n--events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\n\n\nsysbench --mysql-host=10.1.21.242 \\\n--mysql-port=9696 \\\n--mysql-user=zerodb \\\n--mysql-password='zerodb' \\\n--mysql-db=zerodb \\\n--threads=10 \\\n--debug=on \\\n--verbosity=5 \\\n--tables=5 \\\n--events=1 \\\n--auto_inc=off \\\n--table-size=1000 \\\n--db-driver=mysql \\\n--time=6000000 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_read_only.lua \\\nrun\n\n\n\n# zerodb\nsysbench --mysql-host=10.1.21.242 \\\n--mysql-port=9696 \\\n--mysql-user=zerodb \\\n--mysql-password='zerodb' \\\n--mysql-db=zerodb \\\n--threads=10 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 --events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\ncleanup\n\nsysbench --mysql-host=10.1.21.242 \\\n--mysql-port=9696 \\\n--mysql-user=zerodb \\\n--mysql-password='zerodb' \\\n--mysql-db=zerodb \\\n--threads=10 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 --events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\nprepare\n\nsysbench --mysql-host=10.1.21.242 \\\n--mysql-port=9696 \\\n--mysql-user=zerodb \\\n--mysql-password='zerodb' \\\n--mysql-db=zerodb \\\n--threads=400 \\\n--table-size=10 \\\n--auto_inc=off \\\n--tables=5 \\\n--rand-type=uniform \\\n--db-driver=mysql \\\n--time=6000000 --events=0 \\\n--percentile=99 \\\n--report-interval=5 \\\n/usr/share/sysbench/oltp_insert.lua \\\nrun\n\nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[899:{SchemaIndex=225, TableIndex=899, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1592131459, 7, '55016285732-53347045338-85834558147-71206675947-20854212178-67704861318-55023920639-15021922692-58783263226-91831209826', '44804973802-80594424819-30662288113-07543047794-69158617276')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[607:{SchemaIndex=152, TableIndex=607, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1551461983, 1, '97565032345-06095273461-70708868939-89114711497-07191112359-84320966593-06915637429-34011520393-29123922986-41181266499', '10350064023-47161933420-32840507920-65997397770-16177253238')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[371:{SchemaIndex=93, TableIndex=371, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1688397171, 3, '66563027950-07665251035-46015031422-61663761332-16063948763-45273359443-68411883367-29428347771-65572934442-17492196263', '60851935379-49894017653-67952828882-67412344041-59230452535')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[1011:{SchemaIndex=253, TableIndex=1011, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-573803507, 2, '43589791346-92222019297-77586384271-52778612091-96284921979-05035493725-49350672130-03697130813-21052521840-31158762545', '33228172883-24963516238-59142423481-48021525640-21772792414')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1001, mergeExecResult: 0. shardingNode:map[310:{SchemaIndex=78, TableIndex=310, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (439335222, 7, '03793368943-50266953542-49577833032-14468376728-10198261385-85128057368-15281808692-43095784178-01078624681-09027567677', '45982088127-90369291605-80044281219-46887615792-75467747528')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 999, mergeExecResult: 0. shardingNode:map[259:{SchemaIndex=65, TableIndex=259, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (824478979, 9, '79929455805-82686000395-87933678180-97427805059-78850675331-66749630290-23371965370-59789760435-11687903028-37111392097', '65387439360-90889047465-34899315444-83593158053-88419722270')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[388:{SchemaIndex=98, TableIndex=388, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1778834820, 4, '26400620948-86886163258-66955677020-24736956201-37633810654-62170837016-10953232786-08731106510-27930064178-11956848338', '22734010461-63969213016-54927682118-22921617753-25869637636')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[345:{SchemaIndex=87, TableIndex=345, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1906262361, 4, '73054929345-92331883054-27511894619-20000378864-11948567194-86713567705-11190297445-34047180586-99650690403-71903892017', '07335571244-33555087386-76380202973-29490934882-40814481851')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[569:{SchemaIndex=143, TableIndex=569, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1606555193, 2, '94281857928-97538212927-39261666932-79938992409-52558016112-06785833668-50810169070-34555719774-82330250972-35853785503', '29683325026-64124354800-63566774522-19722425169-37547560762')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[906:{SchemaIndex=227, TableIndex=906, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1143670666, 7, '74870370257-63163303467-80061015187-84192128665-25175084977-80554698357-24269465921-53186773519-78675020561-83488552374', '73368269204-64304332325-34620567277-68846684629-38045820340')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[941:{SchemaIndex=236, TableIndex=941, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-1370776493, 6, '16692170437-43512178684-59516594203-75377838995-76081749306-71167865747-97237301685-23453441670-03667446181-56604717727', '14195711604-53513247591-07873804194-96431257292-05520461785')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[872:{SchemaIndex=219, TableIndex=872, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1208557416, 5, '27703568859-81266825379-86789890837-60513053664-22258866897-34966682979-82761864561-83949706302-60135012966-31647733109', '63271991640-87709697591-13072925018-38646644832-79179029573')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[991:{SchemaIndex=248, TableIndex=991, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (138564575, 6, '26857888685-88370802193-51045899118-07572056078-70111763976-05806767425-30208609378-20016792779-48308493020-29821526191', '61555808494-05287717368-66884245341-45983655335-60458704606')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1007, mergeExecResult: 0. shardingNode:map[449:{SchemaIndex=113, TableIndex=449, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-229865921, 8, '14034106238-21876701329-38233326181-31158038417-73928237004-22908354046-72713486563-40610785127-99166317018-52234063725', '23168975405-73598149943-63125122764-74527985990-06171559404')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[959:{SchemaIndex=240, TableIndex=959, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-677583807, 4, '40735866383-98457016615-08789114417-03599576561-48782283253-32055567198-88072330194-83020475968-03693883045-96278614943', '70150968961-19151317381-16983120036-88185867422-84862477300')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1006, mergeExecResult: 0. shardingNode:map[406:{SchemaIndex=102, TableIndex=406, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-2093701526, 5, '09210536591-41896791043-73295525884-89613310006-75387609760-41655764025-47137540812-97100201238-15965683915-13727887851', '48024514833-13441113380-49081922507-17183150276-06208568092')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[894:{SchemaIndex=224, TableIndex=894, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (108403582, 4, '58477996001-39515710854-83438883003-74672331816-19403553257-36113016280-00822951895-43706580851-50122510142-72629874469', '25950012615-74047249694-75644797724-67405314152-48742553448')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[824:{SchemaIndex=207, TableIndex=824, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1108509496, 2, '05591703103-07428761202-09014510822-44571443153-87746638001-18005366596-37591757698-85345493107-52688524466-97341165803', '90287453968-47714845240-54141462203-72968014933-11681199861')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[960:{SchemaIndex=241, TableIndex=960, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-432972736, 4, '32013395637-31037790439-99508763633-39582502523-46934970326-99846192559-79844868065-81128826635-19475623448-94555401729', '72848617704-77451404798-55770002912-34209086424-23821979141')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[864:{SchemaIndex=217, TableIndex=864, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (209038176, 6, '31725269303-67222682770-97738396828-19717571752-01126165612-57542830563-51718817223-13687491781-38891241679-10677758794', '40604117998-67635443824-03882862739-68433432919-44278589057')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[525:{SchemaIndex=132, TableIndex=525, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-663100941, 3, '13572309986-10356575142-87428874956-18162116973-83396135908-09352768769-83603227505-94165603992-17437041978-81761343722', '58884262253-26008842705-81702669160-02709154611-78739667686')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[821:{SchemaIndex=206, TableIndex=821, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1290297141, 6, '28650953615-66926208686-47052429218-34545146184-51693579732-60563146329-00350338711-30136625347-99506216978-22404723673', '30345581431-18594298965-23203468098-48853746952-30033247101')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[881:{SchemaIndex=221, TableIndex=881, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (2128759665, 3, '23557322059-62351008582-19218938648-55023996016-67978090662-04498693910-40333149725-65457542876-11556698223-86845640120', '39531266486-08252986785-52805405505-62972899514-62765043827')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[829:{SchemaIndex=208, TableIndex=829, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1081064253, 2, '39396011527-03550826801-53544579241-44145722341-56423193708-85298116954-45172197891-54532848324-82241582599-97563898680', '76749800295-63255838342-73258070193-02305060704-64352300433')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[900:{SchemaIndex=226, TableIndex=900, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-513806212, 1, '16727493623-40348083665-41922314110-05150944505-43353212884-59194917800-00753396008-63562258886-84259052626-93713085152', '38634951090-07591809914-73325301815-73315254313-82978384844')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1, mergeExecResult: 0. shardingNode:map[863:{SchemaIndex=216, TableIndex=863, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-450094943, 6, '23924438266-62111362125-81473873200-06328498397-88922636306-39182947784-05124699385-49780077333-57313760145-54634535492', '96577223660-83042935121-28454288566-32057418883-39061132652')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[963:{SchemaIndex=241, TableIndex=963, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (1800163267, 4, '27948346446-05701199368-49149768636-18762164887-01870692332-13661773677-35851324771-46733712098-36653074427-31181566769', '08781105428-22812332073-21224324603-72676647429-86438534524')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[878:{SchemaIndex=220, TableIndex=878, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1535190894, 9, '46310600095-97541020554-94065740469-24853513335-69630566641-31721053084-60343664925-46348792383-87749652424-52899212634', '41944783155-15764748316-26823908956-07652542569-85074827204')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[906:{SchemaIndex=227, TableIndex=906, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1945995146, 4, '64447284661-78831878306-27636005022-88863833954-72613803410-72661880191-81775646793-56738842216-16376642732-30662007847', '44349800594-98690127361-78211321236-38340738575-94555021426')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[907:{SchemaIndex=227, TableIndex=907, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1719256971, 3, '36693810506-14727560109-48871542333-86332816255-91899190554-43809786563-22813456576-32468291237-08105779091-35654765264', '76792216525-13152293559-11187746420-35413475429-73316527358')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[827:{SchemaIndex=207, TableIndex=827, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1191957307, 3, '02373892720-70783246981-33072353568-68101913427-25982074179-25716557733-53487403333-33176741697-19961659954-24745733546', '65228452942-44586411798-63293957289-46889416058-55247585232')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[715:{SchemaIndex=179, TableIndex=715, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-368940747, 10, '83732843347-38915816227-71028864502-83867874900-55259635749-04867892981-61246311166-86657029985-98371125854-01109713202', '28665022675-32159696841-27962719413-92137483719-65438251505')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[531:{SchemaIndex=133, TableIndex=531, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (296709651, 4, '68512385573-12594713777-31891099071-55341413329-96572532552-89441743744-75535604911-39664974035-50293453830-41657909966', '54516090919-10379612997-70745484084-47657473576-34684395884')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[1010:{SchemaIndex=253, TableIndex=1010, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (375408626, 5, '86917579879-69750606525-04310713441-66206378609-22671203503-85955817483-08099675016-87194148638-56030296183-72576969654', '14638356398-42816005551-86372571322-85471822123-78848498639')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 207, mergeExecResult: 0. shardingNode:map[481:{SchemaIndex=121, TableIndex=481, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-453506529, 7, '05922416371-88423926572-06168309932-36230491079-35838894643-96519731061-10785734640-51619035736-36739664574-07173836937', '86251074060-14148969607-50675271708-72280786641-89845672651')] \nWARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 999, mergeExecResult: 0. shardingNode:map[506:{SchemaIndex=127, TableIndex=506, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (923516410, 1, '71118741783-11388565696-96706199622-38503412573-05309353257-45864148538-09400667746-21110528894-17837136283-91361843504', '67292585002-85708710331-29800085937-37291514623-47320174130')] \n\n\n\n\nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 306, mergeExecResult: 0. shardingNode:map[540:{SchemaIndex=136, TableIndex=540, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1344100892, 4, '37923605607-42327774961-35128132820-48158088043-25957128013-51759124002-40449799093-68433809807-31405796686-22817252999', '94291235269-60160247565-39950122186-97684115599-96232437155')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 211, mergeExecResult: 0. shardingNode:map[540:{SchemaIndex=136, TableIndex=540, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-757833244, 5, '50104262688-83666007823-06989738144-95141595109-93329094811-13832991101-93076033912-05017862363-35692005246-88744289137', '54081433849-09378248558-38274752100-88855316211-27289637272')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[198:{SchemaIndex=50, TableIndex=198, HostGroup=hostGroup1}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (652469446, 1, '07652454524-22981957011-41438122391-90347773905-88663504044-48425601588-32127975840-28199749965-27298300589-25715051794', '60470366939-49887579866-34848349508-29262200362-52000338086')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[670:{SchemaIndex=168, TableIndex=670, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-212205214, 3, '39093408635-10213704095-82878149257-88673860178-07278582464-52697390774-95388237318-03462450231-66036638124-64228596635', '38716722580-86486363760-61985600779-83841271441-42765235992')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 248, mergeExecResult: 0. shardingNode:map[594:{SchemaIndex=149, TableIndex=594, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1136835154, 2, '23757270379-51595389012-47476784586-71294005118-20959815636-40533304860-41036462462-22519409530-16151251756-29363403201', '02895678318-89791495824-44276206517-37575326693-35714861579')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 196, mergeExecResult: 0. shardingNode:map[596:{SchemaIndex=150, TableIndex=596, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (927250004, 3, '02232667199-83769701794-18129066725-31520472849-93375763771-42931518091-56094856485-24182688367-31807939112-07474880757', '46530309679-12705910558-69428237706-14629411089-19801742204')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 213, mergeExecResult: 0. shardingNode:map[568:{SchemaIndex=143, TableIndex=568, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1908502072, 6, '11131352749-42538464007-16895664672-62644300750-86974265339-82077852146-68660984992-78157770948-82596046151-02353070903', '35289675345-82804575493-00647347117-53443940605-48670213485')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[530:{SchemaIndex=133, TableIndex=530, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1565462034, 2, '03766551315-88042959333-06619558863-52259377137-27072539179-52210031586-63547684874-18650692849-22136096911-63673950864', '23300762166-38283070103-67223042934-76314148059-35039279078')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 252, mergeExecResult: 0. shardingNode:map[705:{SchemaIndex=177, TableIndex=705, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-282929857, 9, '78018924775-94910259974-14900983402-30428448745-60064721591-40668444882-53712901782-65346911189-59688209606-74312372904', '82234943021-50353143509-80352130420-57571772487-81475633439')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 291, mergeExecResult: 0. shardingNode:map[724:{SchemaIndex=182, TableIndex=724, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (2109119188, 7, '36086413796-51767176683-52982238848-36460965892-84578503998-21697029291-39139590496-18305440259-61532992900-70589028518', '30048526034-08924322516-87289516951-51922079500-47125778015')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 210, mergeExecResult: 0. shardingNode:map[573:{SchemaIndex=144, TableIndex=573, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-994558525, 8, '74078055913-58294585862-48131723756-93089582597-72949713745-85429496032-27905841748-82110966829-12174780172-45947256767', '52598986037-80854622196-65516850169-26314282473-46184813701')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 99, mergeExecResult: 0. shardingNode:map[701:{SchemaIndex=176, TableIndex=701, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1290611389, 10, '06010961323-54786660073-11823817491-71384866194-20002003501-13527828508-52664186690-95551041252-11585296099-86883272955', '35567244596-82663971593-11831798779-27870930145-87441039863')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 292, mergeExecResult: 0. shardingNode:map[567:{SchemaIndex=142, TableIndex=567, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (810312247, 10, '41210873160-21444867641-91122365510-19036499914-34569882163-29091701055-84873343605-60726600041-00757500001-24263691698', '41652074477-40057441865-33409084588-16838407116-03941310610')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[213:{SchemaIndex=54, TableIndex=213, HostGroup=hostGroup1}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1881853141, 2, '14742564348-19913327041-96137703234-33860693319-12765733015-19685217285-90407570147-69715707192-71609875203-72224693707', '62398998246-64288014470-28245239723-29976129053-08238346550')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 242, mergeExecResult: 0. shardingNode:map[698:{SchemaIndex=175, TableIndex=698, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1011920570, 2, '33865708347-82274332444-45097600411-92274439334-16926356904-33828206076-16463987600-06687756787-06453656924-53622006994', '48462480629-04943720987-66250435599-66843177447-86484400166')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 195, mergeExecResult: 0. shardingNode:map[710:{SchemaIndex=178, TableIndex=710, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-2128817862, 7, '12483300987-88535524922-66334741529-64659385522-75032596868-93466219012-01222978665-55122702202-84142740410-53583589563', '89132580254-79206347601-13534456013-96027776935-07650599065')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 233, mergeExecResult: 0. shardingNode:map[544:{SchemaIndex=137, TableIndex=544, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1496016416, 9, '99154323337-90872497215-53698284897-04686362817-35622767062-48356019022-04016504226-75493501145-38429448892-66989460733', '84409926268-28404056573-96777093808-13481662538-98898905310')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 27, mergeExecResult: 0. shardingNode:map[907:{SchemaIndex=227, TableIndex=907, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (756613003, 1, '48041615531-14651008388-14559884387-33045819966-91038786346-39394412181-13147015451-43265025586-90014901196-20159726596', '62496325099-63432555894-84244639858-58924561742-12138512609')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 284, mergeExecResult: 0. shardingNode:map[525:{SchemaIndex=132, TableIndex=525, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (588268045, 3, '01778869912-44391681202-43730989451-99650497628-58071023040-36244500937-05173857724-21592385062-52662008534-88410130321', '68551597952-73268487812-26478068307-11227961732-49092247276')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 229, mergeExecResult: 0. shardingNode:map[674:{SchemaIndex=169, TableIndex=674, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (75111074, 1, '07857287095-83026714634-10012972058-11441297287-80787536524-31038348780-79408482259-95286783641-23620583564-94195135059', '39714908056-38058099094-71552841772-10457961132-39419941227')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 230, mergeExecResult: 0. shardingNode:map[577:{SchemaIndex=145, TableIndex=577, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-911965761, 8, '07321418565-94055920833-16462957068-14933742620-00134077423-05303377934-66121817102-49230219319-72774150061-80468601177', '26522648558-75134929821-83594530381-47917024515-31668467194')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 232, mergeExecResult: 0. shardingNode:map[513:{SchemaIndex=129, TableIndex=513, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1315070465, 5, '15474433240-84784850443-17796367719-48021520867-10943303644-48200729918-91013947900-33061132253-28956163141-98846516045', '99644114596-46918915095-13462299586-15204837308-12785249281')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 231, mergeExecResult: 0. shardingNode:map[737:{SchemaIndex=185, TableIndex=737, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-180994785, 9, '61681162669-07252910162-88941330016-07633567093-86234290556-74605484081-92189953463-28499401861-08881094341-04206273246', '73069152681-47514577462-53755512339-63165295325-04957863379')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 225, mergeExecResult: 0. shardingNode:map[583:{SchemaIndex=146, TableIndex=583, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (905672263, 5, '11686869034-48032081508-20645314791-73241768758-13634493369-36096577158-76040275597-65556337906-73745369125-93817830861', '25154935190-35760055237-67095134841-73686707222-08327146392')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 227, mergeExecResult: 0. shardingNode:map[568:{SchemaIndex=143, TableIndex=568, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1028081208, 6, '65787201754-47681590360-50036937953-38544197509-01589612011-17576022949-32999165698-83171817746-37315560344-14463882405', '65637926145-34138639858-41094177281-29428779399-44688752051')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 232, mergeExecResult: 0. shardingNode:map[558:{SchemaIndex=140, TableIndex=558, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (278584878, 10, '32358945918-66413584434-88058020708-48390261093-67208582401-88568979078-90497400157-49426845556-80952580018-13610087462', '14198786100-85805610838-89824761297-62058901344-60492560838')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 228, mergeExecResult: 0. shardingNode:map[649:{SchemaIndex=163, TableIndex=649, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (1183431305, 2, '43858458237-46788126262-05213368147-07302202409-13593899883-99375055319-42875375550-56499216168-01796902390-08647652700', '48205424174-34611724289-69246697079-03898745311-99595319598')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 26, mergeExecResult: 0. shardingNode:map[1002:{SchemaIndex=251, TableIndex=1002, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1701967850, 9, '59147040383-79705593723-62886101805-60535881029-18413556495-06238443919-02766097021-38361379870-67179305438-52530038201', '14770296700-13396847549-83905253251-99337969432-58669912709')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 229, mergeExecResult: 0. shardingNode:map[745:{SchemaIndex=187, TableIndex=745, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-1169184489, 7, '64955629118-36147506634-51676575477-92147977264-45999410094-15567300060-12836575112-28470342888-04361926080-90629622527', '86593300354-87140619605-87718697448-88392415837-04795141111')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 272, mergeExecResult: 0. shardingNode:map[662:{SchemaIndex=166, TableIndex=662, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1555424918, 10, '11260581771-57660361810-58723152189-43635886031-41094065361-37903459575-65856768363-01843670891-17848285384-92171598763', '36462031678-64770373669-77316073133-32672501580-50753545368')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 271, mergeExecResult: 0. shardingNode:map[736:{SchemaIndex=185, TableIndex=736, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-270642912, 9, '87806093665-04774113218-83983577041-09351362099-88339377062-22401969710-89370302094-61598971830-04573362584-60421137580', '26415700902-09148763904-87375314444-00285784497-80449574080')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 222, mergeExecResult: 0. shardingNode:map[588:{SchemaIndex=148, TableIndex=588, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1608970828, 2, '75571666926-33738024136-84313793696-10714487345-57088294174-41711334397-51382524640-08327299973-66970622008-15344703881', '73366501022-14368954292-21130701303-33960859630-28160972955')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 220, mergeExecResult: 0. shardingNode:map[556:{SchemaIndex=140, TableIndex=556, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-993863212, 3, '68136313990-05892185009-94544559127-32267303237-37763842514-89959134082-97215598641-72307869276-49642816905-24994127953', '97111382859-69888150629-89398585714-99569889618-30099083026')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 220, mergeExecResult: 0. shardingNode:map[513:{SchemaIndex=129, TableIndex=513, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1299240449, 6, '13580427730-91599560017-42392676834-62860979245-65274043134-68243135520-42672727926-56794775679-69217526806-27227304772', '15736027942-38175115801-93773367279-77944721463-03173899187')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 214, mergeExecResult: 0. shardingNode:map[579:{SchemaIndex=145, TableIndex=579, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1346301507, 2, '95777728263-97322915970-24025444526-11872987788-74589515383-37108287704-62890589663-84327075019-58161194629-66166453693', '43925335448-41493749427-45817169562-78879091928-39249185154')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 252, mergeExecResult: 0. shardingNode:map[723:{SchemaIndex=181, TableIndex=723, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1604556499, 3, '54964824319-34611710514-15902154995-18014105243-70193115677-91112406449-61348366967-41301887681-73892593737-54039590822', '26491514771-24473569991-16656607124-07593925149-74926670900')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 253, mergeExecResult: 0. shardingNode:map[715:{SchemaIndex=179, TableIndex=715, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (533688011, 7, '17872695538-16064539790-18108982113-60646269894-74784931403-89606878485-67937667670-39824753762-37339034055-79511964331', '65227853620-62393117281-88901273019-02060144110-40123779052')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[731:{SchemaIndex=183, TableIndex=731, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (548553435, 7, '59524856205-92318067592-84001816236-15799238765-61939312958-49774297702-51059777347-11521186806-90725070157-29567571966', '72604893873-81336794708-64989781571-89144801847-53529920629')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 296, mergeExecResult: 0. shardingNode:map[646:{SchemaIndex=162, TableIndex=646, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1980507782, 8, '15361099362-33426846104-81568076007-88926275697-54147190617-21941361738-39219198670-72817831326-95768248501-29228997291', '51713925651-55077435995-56372978084-60334222441-07023013203')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 27, mergeExecResult: 0. shardingNode:map[1023:{SchemaIndex=256, TableIndex=1023, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (419830783, 9, '39839456224-14625126106-10611694673-69035645226-20746732552-01963419766-94676550107-32542648198-96549393904-39850608367', '69725922822-08559910362-36080928509-49601235010-15261238716')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 296, mergeExecResult: 0. shardingNode:map[612:{SchemaIndex=154, TableIndex=612, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1848104548, 6, '02931425025-68282480940-67294056291-41225608697-44038095895-05390291535-10414730978-25086630856-84460614365-62218384416', '74426157735-27538600335-93122572838-36921241106-44481214039')] \nWARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 305, mergeExecResult: 0. shardingNode:map[517:{SchemaIndex=130, TableIndex=517, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-543662597,\n\ncobar:\nsysbench --mysql-host=10.1.21.242 --mysql-port=8066 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=10 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua cleanup\nsysbench --mysql-host=10.1.21.242 --mysql-port=8066 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=10 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua prepare\nsysbench --mysql-host=10.1.21.242 --mysql-port=8066 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=400 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua run\n\nzero-proxy\nsysbench --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=10 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua cleanup\nsysbench --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=10 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua prepare\nsysbench --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-user=zerodb --mysql-password='zerodb' --mysql-db=zerodb --threads=400 --table-size=10 --auto_inc=off --tables=5 --rand-type=uniform --db-driver=mysql --time=6000000 --events=0 --percentile=99 --report-interval=5 /usr/share/sysbench/oltp_insert.lua run\n\n\n\n\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb  --oltp-tables-count=5 prepare\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb  --oltp-tables-count=5 cleanup\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb --ssh-user=root --ssh-password=sdfsdf --oltp-tables-count=5 --write-threads=128 --read-threads=8 --max-time=3600 random\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb --ssh-user=root --ssh-password=sdfsdf --oltp-tables-count=5 --write-threads=128 --read-threads=8 --max-time=3600 seq\n\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb --ssh-user=root --ssh-password=sdfsdf --oltp-tables-count=5 --write-threads=4 --read-threads=300 --update-threads=20 --delete-threads=10 --max-time=360000000 random\n\n\n\n\n./benchyou --mysql-host=10.1.21.242 --mysql-port=9696 --mysql-db=zerodb --mysql-user=zerodb --mysql-password=zerodb --ssh-user=root --ssh-password=sdfsdf --oltp-tables-count=5 --write-threads=400 --read-threads=400 --max-time=3600 random","slug":"Cobar-Performance-Test-With-Sysbench","published":1,"updated":"2018-06-15T09:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsya000k3iq2rwljv25y","content":"<h3 id=\"centos\"><a href=\"#centos\" class=\"headerlink\" title=\"centos\"></a>centos</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install sysbench</div></pre></td></tr></table></figure>\n<p>lua目录 /usr/share/sysbench/</p>\n<p>由于Cobar不支持SQL 92的表创建，所以需要修改/usr/share/sysbench/oltp_common.lua</p>\n<p>如果需要查看帮助</p>\n<p>则运行: sysbench [lua_path] help<br>比如: sysbench /usr/share/sysbench/oltp_insert.lua help</p>\n<p>sysbench –mysql-host=mac \\<br>–mysql-port=9696 \\<br>–mysql-user=zerodb \\<br>–mysql-password=zerodb \\<br>–mysql-db=zerodb \\<br>–threads=4 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 –events=0 \\<br>–percentile=99 \\<br>–report-interval=2 \\<br>/usr/local/Cellar/sysbench/1.0.11/share/sysbench/oltp_insert.lua \\</p>\n<p>#cobar_1</p>\n<p>sysbench –mysql-host=10.1.21.148 \\<br>–mysql-port=8066 \\<br>–mysql-user=user \\<br>–mysql-password=’user’ \\<br>–mysql-db=user \\<br>–threads=400 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 \\<br>–events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\</p>\n<p>#cobar_2</p>\n<p>sysbench –mysql-host=10.1.21.147 \\<br>–mysql-port=8066 \\<br>–mysql-user=user \\<br>–mysql-password=’user’ \\<br>–mysql-db=user \\<br>–threads=400 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 –events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\</p>\n<h3 id=\"测试报告\"><a href=\"#测试报告\" class=\"headerlink\" title=\"测试报告\"></a>测试报告</h3><p>[root@mq001 ~]# sysbench –mysql-host=10.1.21.147 –mysql-port=8066 –mysql-user=user –mysql-password=’user’ –mysql-db=user –threads=400 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=60 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua run<br>sysbench 1.0.9 (using system LuaJIT 2.0.4)</p>\n<p>Running the test with following options:<br>Number of threads: 400<br>Report intermediate results every 5 second(s)<br>Initializing random number generator from current time</p>\n<p>Initializing worker threads…</p>\n<p>Threads started!</p>\n<p>[ 5s ] thds: 400 tps: 11516.37 qps: 11516.37 (r/w/o: 0.00/11516.37/0.00) lat (ms,99%): 204.11 err/s: 0.00 reconn/s: 0.00<br>[ 10s ] thds: 400 tps: 2884.87 qps: 2884.87 (r/w/o: 0.00/2884.87/0.00) lat (ms,99%): 831.46 err/s: 0.00 reconn/s: 0.00<br>[ 15s ] thds: 400 tps: 4025.00 qps: 4025.00 (r/w/o: 0.00/4025.00/0.00) lat (ms,99%): 1869.60 err/s: 0.00 reconn/s: 0.00<br>[ 20s ] thds: 400 tps: 13497.32 qps: 13497.32 (r/w/o: 0.00/13497.32/0.00) lat (ms,99%): 142.39 err/s: 0.00 reconn/s: 0.00<br>[ 25s ] thds: 400 tps: 10908.17 qps: 10908.17 (r/w/o: 0.00/10908.17/0.00) lat (ms,99%): 144.97 err/s: 0.00 reconn/s: 0.00<br>[ 30s ] thds: 400 tps: 12280.74 qps: 12280.74 (r/w/o: 0.00/12280.74/0.00) lat (ms,99%): 132.49 err/s: 0.00 reconn/s: 0.00<br>[ 35s ] thds: 400 tps: 9783.37 qps: 9783.37 (r/w/o: 0.00/9783.37/0.00) lat (ms,99%): 150.29 err/s: 0.00 reconn/s: 0.00<br>[ 40s ] thds: 400 tps: 11703.52 qps: 11703.72 (r/w/o: 0.00/11703.72/0.00) lat (ms,99%): 173.58 err/s: 0.00 reconn/s: 0.00<br>[ 45s ] thds: 400 tps: 8253.06 qps: 8252.86 (r/w/o: 0.00/8252.86/0.00) lat (ms,99%): 207.82 err/s: 0.00 reconn/s: 0.00<br>[ 50s ] thds: 400 tps: 7148.98 qps: 7149.18 (r/w/o: 0.00/7149.18/0.00) lat (ms,99%): 657.93 err/s: 0.00 reconn/s: 0.00<br>[ 55s ] thds: 400 tps: 10911.35 qps: 10911.15 (r/w/o: 0.00/10911.15/0.00) lat (ms,99%): 176.73 err/s: 0.00 reconn/s: 0.00<br>[ 60s ] thds: 400 tps: 8702.48 qps: 8702.48 (r/w/o: 0.00/8702.48/0.00) lat (ms,99%): 235.74 err/s: 0.00 reconn/s: 0.00<br>SQL statistics:<br>    queries performed:<br>        read:                            0<br>        write:                           558494<br>        other:                           0<br>        total:                           558494<br>    transactions:                        558494 (9273.20 per sec.)<br>    queries:                             558494 (9273.20 per sec.)<br>    ignored errors:                      0      (0.00 per sec.)<br>    reconnects:                          0      (0.00 per sec.)</p>\n<p>General statistics:<br>    total time:                          60.2244s<br>    total number of events:              558494</p>\n<p>Latency (ms):<br>         min:                                  3.89<br>         avg:                                 43.02<br>         max:                               2881.01<br>         99th percentile:                    253.35<br>         sum:                            24023700.41</p>\n<p>Threads fairness:<br>    events (avg/stddev):           1396.2350/30.84<br>    execution time (avg/stddev):   60.0593/0.05</p>\n<p>[root@mq001 ~]# sysbench –mysql-host=10.1.21.148 –mysql-port=8066 –mysql-user=user –mysql-password=’user’ –mysql-db=user –threads=400 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=60 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua run<br>sysbench 1.0.9 (using system LuaJIT 2.0.4)</p>\n<p>Running the test with following options:<br>Number of threads: 400<br>Report intermediate results every 5 second(s)<br>Initializing random number generator from current time</p>\n<p>Initializing worker threads…</p>\n<p>Threads started!</p>\n<p>[ 5s ] thds: 400 tps: 10470.98 qps: 10470.98 (r/w/o: 0.00/10470.98/0.00) lat (ms,99%): 262.64 err/s: 0.00 reconn/s: 0.00<br>[ 10s ] thds: 400 tps: 3020.06 qps: 3020.06 (r/w/o: 0.00/3020.06/0.00) lat (ms,99%): 1050.76 err/s: 0.00 reconn/s: 0.00<br>[ 15s ] thds: 400 tps: 1107.64 qps: 1107.64 (r/w/o: 0.00/1107.64/0.00) lat (ms,99%): 1327.91 err/s: 0.00 reconn/s: 0.00<br>[ 20s ] thds: 400 tps: 7395.23 qps: 7395.23 (r/w/o: 0.00/7395.23/0.00) lat (ms,99%): 816.63 err/s: 0.00 reconn/s: 0.00<br>[ 25s ] thds: 400 tps: 12654.11 qps: 12654.11 (r/w/o: 0.00/12654.11/0.00) lat (ms,99%): 125.52 err/s: 0.00 reconn/s: 0.00<br>[ 30s ] thds: 400 tps: 10854.72 qps: 10854.92 (r/w/o: 0.00/10854.92/0.00) lat (ms,99%): 153.02 err/s: 0.00 reconn/s: 0.00<br>[ 35s ] thds: 400 tps: 11832.81 qps: 11832.61 (r/w/o: 0.00/11832.61/0.00) lat (ms,99%): 186.54 err/s: 0.00 reconn/s: 0.00<br>[ 40s ] thds: 400 tps: 6895.44 qps: 6895.44 (r/w/o: 0.00/6895.44/0.00) lat (ms,99%): 257.95 err/s: 0.00 reconn/s: 0.00<br>[ 45s ] thds: 400 tps: 12907.06 qps: 12907.06 (r/w/o: 0.00/12907.06/0.00) lat (ms,99%): 158.63 err/s: 0.00 reconn/s: 0.00<br>[ 50s ] thds: 400 tps: 7760.80 qps: 7760.80 (r/w/o: 0.00/7760.80/0.00) lat (ms,99%): 292.60 err/s: 0.00 reconn/s: 0.00<br>[ 55s ] thds: 400 tps: 11595.84 qps: 11595.84 (r/w/o: 0.00/11595.84/0.00) lat (ms,99%): 161.51 err/s: 0.00 reconn/s: 0.00<br>[ 60s ] thds: 400 tps: 10314.36 qps: 10314.36 (r/w/o: 0.00/10314.36/0.00) lat (ms,99%): 142.39 err/s: 0.00 reconn/s: 0.00<br>SQL statistics:<br>    queries performed:<br>        read:                            0<br>        write:                           534637<br>        other:                           0<br>        total:                           534637<br>    transactions:                        534637 (8890.97 per sec.)<br>    queries:                             534637 (8890.97 per sec.)<br>    ignored errors:                      0      (0.00 per sec.)<br>    reconnects:                          0      (0.00 per sec.)</p>\n<p>General statistics:<br>    total time:                          60.1304s<br>    total number of events:              534637</p>\n<p>Latency (ms):<br>         min:                                  4.14<br>         avg:                                 44.91<br>         max:                               3066.99<br>         99th percentile:                    292.60<br>         sum:                            24012284.54</p>\n<p>Threads fairness:<br>    events (avg/stddev):           1336.5925/23.11<br>    execution time (avg/stddev):   60.0307/0.03</p>\n<p>sysbench –mysql-host=10.1.134.195 \\<br>–mysql-port=8066 \\<br>–mysql-user=user \\<br>–mysql-password=’user’ \\<br>–mysql-db=user \\<br>–threads=400 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 \\<br>–events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\</p>\n<p>sysbench –mysql-host=10.1.21.242 \\<br>–mysql-port=9696 \\<br>–mysql-user=zerodb \\<br>–mysql-password=’zerodb’ \\<br>–mysql-db=zerodb \\<br>–threads=10 \\<br>–debug=on \\<br>–verbosity=5 \\<br>–tables=5 \\<br>–events=1 \\<br>–auto_inc=off \\<br>–table-size=1000 \\<br>–db-driver=mysql \\<br>–time=6000000 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_read_only.lua \\<br>run</p>\n<h1 id=\"zerodb\"><a href=\"#zerodb\" class=\"headerlink\" title=\"zerodb\"></a>zerodb</h1><p>sysbench –mysql-host=10.1.21.242 \\<br>–mysql-port=9696 \\<br>–mysql-user=zerodb \\<br>–mysql-password=’zerodb’ \\<br>–mysql-db=zerodb \\<br>–threads=10 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 –events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\<br>cleanup</p>\n<p>sysbench –mysql-host=10.1.21.242 \\<br>–mysql-port=9696 \\<br>–mysql-user=zerodb \\<br>–mysql-password=’zerodb’ \\<br>–mysql-db=zerodb \\<br>–threads=10 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 –events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\<br>prepare</p>\n<p>sysbench –mysql-host=10.1.21.242 \\<br>–mysql-port=9696 \\<br>–mysql-user=zerodb \\<br>–mysql-password=’zerodb’ \\<br>–mysql-db=zerodb \\<br>–threads=400 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 –events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\<br>run</p>\n<p>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[899:{SchemaIndex=225, TableIndex=899, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1592131459, 7, ‘55016285732-53347045338-85834558147-71206675947-20854212178-67704861318-55023920639-15021922692-58783263226-91831209826’, ‘44804973802-80594424819-30662288113-07543047794-69158617276’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[607:{SchemaIndex=152, TableIndex=607, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1551461983, 1, ‘97565032345-06095273461-70708868939-89114711497-07191112359-84320966593-06915637429-34011520393-29123922986-41181266499’, ‘10350064023-47161933420-32840507920-65997397770-16177253238’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[371:{SchemaIndex=93, TableIndex=371, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1688397171, 3, ‘66563027950-07665251035-46015031422-61663761332-16063948763-45273359443-68411883367-29428347771-65572934442-17492196263’, ‘60851935379-49894017653-67952828882-67412344041-59230452535’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[1011:{SchemaIndex=253, TableIndex=1011, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-573803507, 2, ‘43589791346-92222019297-77586384271-52778612091-96284921979-05035493725-49350672130-03697130813-21052521840-31158762545’, ‘33228172883-24963516238-59142423481-48021525640-21772792414’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1001, mergeExecResult: 0. shardingNode:map[310:{SchemaIndex=78, TableIndex=310, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (439335222, 7, ‘03793368943-50266953542-49577833032-14468376728-10198261385-85128057368-15281808692-43095784178-01078624681-09027567677’, ‘45982088127-90369291605-80044281219-46887615792-75467747528’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 999, mergeExecResult: 0. shardingNode:map[259:{SchemaIndex=65, TableIndex=259, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (824478979, 9, ‘79929455805-82686000395-87933678180-97427805059-78850675331-66749630290-23371965370-59789760435-11687903028-37111392097’, ‘65387439360-90889047465-34899315444-83593158053-88419722270’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[388:{SchemaIndex=98, TableIndex=388, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1778834820, 4, ‘26400620948-86886163258-66955677020-24736956201-37633810654-62170837016-10953232786-08731106510-27930064178-11956848338’, ‘22734010461-63969213016-54927682118-22921617753-25869637636’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[345:{SchemaIndex=87, TableIndex=345, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1906262361, 4, ‘73054929345-92331883054-27511894619-20000378864-11948567194-86713567705-11190297445-34047180586-99650690403-71903892017’, ‘07335571244-33555087386-76380202973-29490934882-40814481851’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[569:{SchemaIndex=143, TableIndex=569, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1606555193, 2, ‘94281857928-97538212927-39261666932-79938992409-52558016112-06785833668-50810169070-34555719774-82330250972-35853785503’, ‘29683325026-64124354800-63566774522-19722425169-37547560762’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[906:{SchemaIndex=227, TableIndex=906, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1143670666, 7, ‘74870370257-63163303467-80061015187-84192128665-25175084977-80554698357-24269465921-53186773519-78675020561-83488552374’, ‘73368269204-64304332325-34620567277-68846684629-38045820340’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[941:{SchemaIndex=236, TableIndex=941, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-1370776493, 6, ‘16692170437-43512178684-59516594203-75377838995-76081749306-71167865747-97237301685-23453441670-03667446181-56604717727’, ‘14195711604-53513247591-07873804194-96431257292-05520461785’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[872:{SchemaIndex=219, TableIndex=872, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1208557416, 5, ‘27703568859-81266825379-86789890837-60513053664-22258866897-34966682979-82761864561-83949706302-60135012966-31647733109’, ‘63271991640-87709697591-13072925018-38646644832-79179029573’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[991:{SchemaIndex=248, TableIndex=991, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (138564575, 6, ‘26857888685-88370802193-51045899118-07572056078-70111763976-05806767425-30208609378-20016792779-48308493020-29821526191’, ‘61555808494-05287717368-66884245341-45983655335-60458704606’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1007, mergeExecResult: 0. shardingNode:map[449:{SchemaIndex=113, TableIndex=449, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-229865921, 8, ‘14034106238-21876701329-38233326181-31158038417-73928237004-22908354046-72713486563-40610785127-99166317018-52234063725’, ‘23168975405-73598149943-63125122764-74527985990-06171559404’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[959:{SchemaIndex=240, TableIndex=959, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-677583807, 4, ‘40735866383-98457016615-08789114417-03599576561-48782283253-32055567198-88072330194-83020475968-03693883045-96278614943’, ‘70150968961-19151317381-16983120036-88185867422-84862477300’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1006, mergeExecResult: 0. shardingNode:map[406:{SchemaIndex=102, TableIndex=406, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-2093701526, 5, ‘09210536591-41896791043-73295525884-89613310006-75387609760-41655764025-47137540812-97100201238-15965683915-13727887851’, ‘48024514833-13441113380-49081922507-17183150276-06208568092’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[894:{SchemaIndex=224, TableIndex=894, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (108403582, 4, ‘58477996001-39515710854-83438883003-74672331816-19403553257-36113016280-00822951895-43706580851-50122510142-72629874469’, ‘25950012615-74047249694-75644797724-67405314152-48742553448’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[824:{SchemaIndex=207, TableIndex=824, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1108509496, 2, ‘05591703103-07428761202-09014510822-44571443153-87746638001-18005366596-37591757698-85345493107-52688524466-97341165803’, ‘90287453968-47714845240-54141462203-72968014933-11681199861’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[960:{SchemaIndex=241, TableIndex=960, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-432972736, 4, ‘32013395637-31037790439-99508763633-39582502523-46934970326-99846192559-79844868065-81128826635-19475623448-94555401729’, ‘72848617704-77451404798-55770002912-34209086424-23821979141’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[864:{SchemaIndex=217, TableIndex=864, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (209038176, 6, ‘31725269303-67222682770-97738396828-19717571752-01126165612-57542830563-51718817223-13687491781-38891241679-10677758794’, ‘40604117998-67635443824-03882862739-68433432919-44278589057’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[525:{SchemaIndex=132, TableIndex=525, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-663100941, 3, ‘13572309986-10356575142-87428874956-18162116973-83396135908-09352768769-83603227505-94165603992-17437041978-81761343722’, ‘58884262253-26008842705-81702669160-02709154611-78739667686’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[821:{SchemaIndex=206, TableIndex=821, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1290297141, 6, ‘28650953615-66926208686-47052429218-34545146184-51693579732-60563146329-00350338711-30136625347-99506216978-22404723673’, ‘30345581431-18594298965-23203468098-48853746952-30033247101’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[881:{SchemaIndex=221, TableIndex=881, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (2128759665, 3, ‘23557322059-62351008582-19218938648-55023996016-67978090662-04498693910-40333149725-65457542876-11556698223-86845640120’, ‘39531266486-08252986785-52805405505-62972899514-62765043827’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[829:{SchemaIndex=208, TableIndex=829, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1081064253, 2, ‘39396011527-03550826801-53544579241-44145722341-56423193708-85298116954-45172197891-54532848324-82241582599-97563898680’, ‘76749800295-63255838342-73258070193-02305060704-64352300433’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[900:{SchemaIndex=226, TableIndex=900, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-513806212, 1, ‘16727493623-40348083665-41922314110-05150944505-43353212884-59194917800-00753396008-63562258886-84259052626-93713085152’, ‘38634951090-07591809914-73325301815-73315254313-82978384844’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1, mergeExecResult: 0. shardingNode:map[863:{SchemaIndex=216, TableIndex=863, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-450094943, 6, ‘23924438266-62111362125-81473873200-06328498397-88922636306-39182947784-05124699385-49780077333-57313760145-54634535492’, ‘96577223660-83042935121-28454288566-32057418883-39061132652’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[963:{SchemaIndex=241, TableIndex=963, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (1800163267, 4, ‘27948346446-05701199368-49149768636-18762164887-01870692332-13661773677-35851324771-46733712098-36653074427-31181566769’, ‘08781105428-22812332073-21224324603-72676647429-86438534524’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[878:{SchemaIndex=220, TableIndex=878, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1535190894, 9, ‘46310600095-97541020554-94065740469-24853513335-69630566641-31721053084-60343664925-46348792383-87749652424-52899212634’, ‘41944783155-15764748316-26823908956-07652542569-85074827204’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[906:{SchemaIndex=227, TableIndex=906, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1945995146, 4, ‘64447284661-78831878306-27636005022-88863833954-72613803410-72661880191-81775646793-56738842216-16376642732-30662007847’, ‘44349800594-98690127361-78211321236-38340738575-94555021426’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[907:{SchemaIndex=227, TableIndex=907, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1719256971, 3, ‘36693810506-14727560109-48871542333-86332816255-91899190554-43809786563-22813456576-32468291237-08105779091-35654765264’, ‘76792216525-13152293559-11187746420-35413475429-73316527358’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[827:{SchemaIndex=207, TableIndex=827, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1191957307, 3, ‘02373892720-70783246981-33072353568-68101913427-25982074179-25716557733-53487403333-33176741697-19961659954-24745733546’, ‘65228452942-44586411798-63293957289-46889416058-55247585232’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[715:{SchemaIndex=179, TableIndex=715, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-368940747, 10, ‘83732843347-38915816227-71028864502-83867874900-55259635749-04867892981-61246311166-86657029985-98371125854-01109713202’, ‘28665022675-32159696841-27962719413-92137483719-65438251505’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[531:{SchemaIndex=133, TableIndex=531, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (296709651, 4, ‘68512385573-12594713777-31891099071-55341413329-96572532552-89441743744-75535604911-39664974035-50293453830-41657909966’, ‘54516090919-10379612997-70745484084-47657473576-34684395884’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[1010:{SchemaIndex=253, TableIndex=1010, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (375408626, 5, ‘86917579879-69750606525-04310713441-66206378609-22671203503-85955817483-08099675016-87194148638-56030296183-72576969654’, ‘14638356398-42816005551-86372571322-85471822123-78848498639’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 207, mergeExecResult: 0. shardingNode:map[481:{SchemaIndex=121, TableIndex=481, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-453506529, 7, ‘05922416371-88423926572-06168309932-36230491079-35838894643-96519731061-10785734640-51619035736-36739664574-07173836937’, ‘86251074060-14148969607-50675271708-72280786641-89845672651’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 999, mergeExecResult: 0. shardingNode:map[506:{SchemaIndex=127, TableIndex=506, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (923516410, 1, ‘71118741783-11388565696-96706199622-38503412573-05309353257-45864148538-09400667746-21110528894-17837136283-91361843504’, ‘67292585002-85708710331-29800085937-37291514623-47320174130’)] </p>\n<p>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 306, mergeExecResult: 0. shardingNode:map[540:{SchemaIndex=136, TableIndex=540, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1344100892, 4, ‘37923605607-42327774961-35128132820-48158088043-25957128013-51759124002-40449799093-68433809807-31405796686-22817252999’, ‘94291235269-60160247565-39950122186-97684115599-96232437155’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 211, mergeExecResult: 0. shardingNode:map[540:{SchemaIndex=136, TableIndex=540, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-757833244, 5, ‘50104262688-83666007823-06989738144-95141595109-93329094811-13832991101-93076033912-05017862363-35692005246-88744289137’, ‘54081433849-09378248558-38274752100-88855316211-27289637272’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[198:{SchemaIndex=50, TableIndex=198, HostGroup=hostGroup1}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (652469446, 1, ‘07652454524-22981957011-41438122391-90347773905-88663504044-48425601588-32127975840-28199749965-27298300589-25715051794’, ‘60470366939-49887579866-34848349508-29262200362-52000338086’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[670:{SchemaIndex=168, TableIndex=670, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-212205214, 3, ‘39093408635-10213704095-82878149257-88673860178-07278582464-52697390774-95388237318-03462450231-66036638124-64228596635’, ‘38716722580-86486363760-61985600779-83841271441-42765235992’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 248, mergeExecResult: 0. shardingNode:map[594:{SchemaIndex=149, TableIndex=594, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1136835154, 2, ‘23757270379-51595389012-47476784586-71294005118-20959815636-40533304860-41036462462-22519409530-16151251756-29363403201’, ‘02895678318-89791495824-44276206517-37575326693-35714861579’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 196, mergeExecResult: 0. shardingNode:map[596:{SchemaIndex=150, TableIndex=596, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (927250004, 3, ‘02232667199-83769701794-18129066725-31520472849-93375763771-42931518091-56094856485-24182688367-31807939112-07474880757’, ‘46530309679-12705910558-69428237706-14629411089-19801742204’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 213, mergeExecResult: 0. shardingNode:map[568:{SchemaIndex=143, TableIndex=568, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1908502072, 6, ‘11131352749-42538464007-16895664672-62644300750-86974265339-82077852146-68660984992-78157770948-82596046151-02353070903’, ‘35289675345-82804575493-00647347117-53443940605-48670213485’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[530:{SchemaIndex=133, TableIndex=530, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1565462034, 2, ‘03766551315-88042959333-06619558863-52259377137-27072539179-52210031586-63547684874-18650692849-22136096911-63673950864’, ‘23300762166-38283070103-67223042934-76314148059-35039279078’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 252, mergeExecResult: 0. shardingNode:map[705:{SchemaIndex=177, TableIndex=705, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-282929857, 9, ‘78018924775-94910259974-14900983402-30428448745-60064721591-40668444882-53712901782-65346911189-59688209606-74312372904’, ‘82234943021-50353143509-80352130420-57571772487-81475633439’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 291, mergeExecResult: 0. shardingNode:map[724:{SchemaIndex=182, TableIndex=724, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (2109119188, 7, ‘36086413796-51767176683-52982238848-36460965892-84578503998-21697029291-39139590496-18305440259-61532992900-70589028518’, ‘30048526034-08924322516-87289516951-51922079500-47125778015’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 210, mergeExecResult: 0. shardingNode:map[573:{SchemaIndex=144, TableIndex=573, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-994558525, 8, ‘74078055913-58294585862-48131723756-93089582597-72949713745-85429496032-27905841748-82110966829-12174780172-45947256767’, ‘52598986037-80854622196-65516850169-26314282473-46184813701’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 99, mergeExecResult: 0. shardingNode:map[701:{SchemaIndex=176, TableIndex=701, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1290611389, 10, ‘06010961323-54786660073-11823817491-71384866194-20002003501-13527828508-52664186690-95551041252-11585296099-86883272955’, ‘35567244596-82663971593-11831798779-27870930145-87441039863’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 292, mergeExecResult: 0. shardingNode:map[567:{SchemaIndex=142, TableIndex=567, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (810312247, 10, ‘41210873160-21444867641-91122365510-19036499914-34569882163-29091701055-84873343605-60726600041-00757500001-24263691698’, ‘41652074477-40057441865-33409084588-16838407116-03941310610’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[213:{SchemaIndex=54, TableIndex=213, HostGroup=hostGroup1}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1881853141, 2, ‘14742564348-19913327041-96137703234-33860693319-12765733015-19685217285-90407570147-69715707192-71609875203-72224693707’, ‘62398998246-64288014470-28245239723-29976129053-08238346550’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 242, mergeExecResult: 0. shardingNode:map[698:{SchemaIndex=175, TableIndex=698, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1011920570, 2, ‘33865708347-82274332444-45097600411-92274439334-16926356904-33828206076-16463987600-06687756787-06453656924-53622006994’, ‘48462480629-04943720987-66250435599-66843177447-86484400166’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 195, mergeExecResult: 0. shardingNode:map[710:{SchemaIndex=178, TableIndex=710, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-2128817862, 7, ‘12483300987-88535524922-66334741529-64659385522-75032596868-93466219012-01222978665-55122702202-84142740410-53583589563’, ‘89132580254-79206347601-13534456013-96027776935-07650599065’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 233, mergeExecResult: 0. shardingNode:map[544:{SchemaIndex=137, TableIndex=544, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1496016416, 9, ‘99154323337-90872497215-53698284897-04686362817-35622767062-48356019022-04016504226-75493501145-38429448892-66989460733’, ‘84409926268-28404056573-96777093808-13481662538-98898905310’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 27, mergeExecResult: 0. shardingNode:map[907:{SchemaIndex=227, TableIndex=907, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (756613003, 1, ‘48041615531-14651008388-14559884387-33045819966-91038786346-39394412181-13147015451-43265025586-90014901196-20159726596’, ‘62496325099-63432555894-84244639858-58924561742-12138512609’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 284, mergeExecResult: 0. shardingNode:map[525:{SchemaIndex=132, TableIndex=525, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (588268045, 3, ‘01778869912-44391681202-43730989451-99650497628-58071023040-36244500937-05173857724-21592385062-52662008534-88410130321’, ‘68551597952-73268487812-26478068307-11227961732-49092247276’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 229, mergeExecResult: 0. shardingNode:map[674:{SchemaIndex=169, TableIndex=674, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (75111074, 1, ‘07857287095-83026714634-10012972058-11441297287-80787536524-31038348780-79408482259-95286783641-23620583564-94195135059’, ‘39714908056-38058099094-71552841772-10457961132-39419941227’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 230, mergeExecResult: 0. shardingNode:map[577:{SchemaIndex=145, TableIndex=577, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-911965761, 8, ‘07321418565-94055920833-16462957068-14933742620-00134077423-05303377934-66121817102-49230219319-72774150061-80468601177’, ‘26522648558-75134929821-83594530381-47917024515-31668467194’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 232, mergeExecResult: 0. shardingNode:map[513:{SchemaIndex=129, TableIndex=513, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1315070465, 5, ‘15474433240-84784850443-17796367719-48021520867-10943303644-48200729918-91013947900-33061132253-28956163141-98846516045’, ‘99644114596-46918915095-13462299586-15204837308-12785249281’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 231, mergeExecResult: 0. shardingNode:map[737:{SchemaIndex=185, TableIndex=737, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-180994785, 9, ‘61681162669-07252910162-88941330016-07633567093-86234290556-74605484081-92189953463-28499401861-08881094341-04206273246’, ‘73069152681-47514577462-53755512339-63165295325-04957863379’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 225, mergeExecResult: 0. shardingNode:map[583:{SchemaIndex=146, TableIndex=583, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (905672263, 5, ‘11686869034-48032081508-20645314791-73241768758-13634493369-36096577158-76040275597-65556337906-73745369125-93817830861’, ‘25154935190-35760055237-67095134841-73686707222-08327146392’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 227, mergeExecResult: 0. shardingNode:map[568:{SchemaIndex=143, TableIndex=568, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1028081208, 6, ‘65787201754-47681590360-50036937953-38544197509-01589612011-17576022949-32999165698-83171817746-37315560344-14463882405’, ‘65637926145-34138639858-41094177281-29428779399-44688752051’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 232, mergeExecResult: 0. shardingNode:map[558:{SchemaIndex=140, TableIndex=558, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (278584878, 10, ‘32358945918-66413584434-88058020708-48390261093-67208582401-88568979078-90497400157-49426845556-80952580018-13610087462’, ‘14198786100-85805610838-89824761297-62058901344-60492560838’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 228, mergeExecResult: 0. shardingNode:map[649:{SchemaIndex=163, TableIndex=649, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (1183431305, 2, ‘43858458237-46788126262-05213368147-07302202409-13593899883-99375055319-42875375550-56499216168-01796902390-08647652700’, ‘48205424174-34611724289-69246697079-03898745311-99595319598’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 26, mergeExecResult: 0. shardingNode:map[1002:{SchemaIndex=251, TableIndex=1002, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1701967850, 9, ‘59147040383-79705593723-62886101805-60535881029-18413556495-06238443919-02766097021-38361379870-67179305438-52530038201’, ‘14770296700-13396847549-83905253251-99337969432-58669912709’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 229, mergeExecResult: 0. shardingNode:map[745:{SchemaIndex=187, TableIndex=745, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-1169184489, 7, ‘64955629118-36147506634-51676575477-92147977264-45999410094-15567300060-12836575112-28470342888-04361926080-90629622527’, ‘86593300354-87140619605-87718697448-88392415837-04795141111’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 272, mergeExecResult: 0. shardingNode:map[662:{SchemaIndex=166, TableIndex=662, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1555424918, 10, ‘11260581771-57660361810-58723152189-43635886031-41094065361-37903459575-65856768363-01843670891-17848285384-92171598763’, ‘36462031678-64770373669-77316073133-32672501580-50753545368’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 271, mergeExecResult: 0. shardingNode:map[736:{SchemaIndex=185, TableIndex=736, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-270642912, 9, ‘87806093665-04774113218-83983577041-09351362099-88339377062-22401969710-89370302094-61598971830-04573362584-60421137580’, ‘26415700902-09148763904-87375314444-00285784497-80449574080’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 222, mergeExecResult: 0. shardingNode:map[588:{SchemaIndex=148, TableIndex=588, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1608970828, 2, ‘75571666926-33738024136-84313793696-10714487345-57088294174-41711334397-51382524640-08327299973-66970622008-15344703881’, ‘73366501022-14368954292-21130701303-33960859630-28160972955’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 220, mergeExecResult: 0. shardingNode:map[556:{SchemaIndex=140, TableIndex=556, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-993863212, 3, ‘68136313990-05892185009-94544559127-32267303237-37763842514-89959134082-97215598641-72307869276-49642816905-24994127953’, ‘97111382859-69888150629-89398585714-99569889618-30099083026’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 220, mergeExecResult: 0. shardingNode:map[513:{SchemaIndex=129, TableIndex=513, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1299240449, 6, ‘13580427730-91599560017-42392676834-62860979245-65274043134-68243135520-42672727926-56794775679-69217526806-27227304772’, ‘15736027942-38175115801-93773367279-77944721463-03173899187’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 214, mergeExecResult: 0. shardingNode:map[579:{SchemaIndex=145, TableIndex=579, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1346301507, 2, ‘95777728263-97322915970-24025444526-11872987788-74589515383-37108287704-62890589663-84327075019-58161194629-66166453693’, ‘43925335448-41493749427-45817169562-78879091928-39249185154’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 252, mergeExecResult: 0. shardingNode:map[723:{SchemaIndex=181, TableIndex=723, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1604556499, 3, ‘54964824319-34611710514-15902154995-18014105243-70193115677-91112406449-61348366967-41301887681-73892593737-54039590822’, ‘26491514771-24473569991-16656607124-07593925149-74926670900’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 253, mergeExecResult: 0. shardingNode:map[715:{SchemaIndex=179, TableIndex=715, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (533688011, 7, ‘17872695538-16064539790-18108982113-60646269894-74784931403-89606878485-67937667670-39824753762-37339034055-79511964331’, ‘65227853620-62393117281-88901273019-02060144110-40123779052’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[731:{SchemaIndex=183, TableIndex=731, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (548553435, 7, ‘59524856205-92318067592-84001816236-15799238765-61939312958-49774297702-51059777347-11521186806-90725070157-29567571966’, ‘72604893873-81336794708-64989781571-89144801847-53529920629’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 296, mergeExecResult: 0. shardingNode:map[646:{SchemaIndex=162, TableIndex=646, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1980507782, 8, ‘15361099362-33426846104-81568076007-88926275697-54147190617-21941361738-39219198670-72817831326-95768248501-29228997291’, ‘51713925651-55077435995-56372978084-60334222441-07023013203’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 27, mergeExecResult: 0. shardingNode:map[1023:{SchemaIndex=256, TableIndex=1023, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (419830783, 9, ‘39839456224-14625126106-10611694673-69035645226-20746732552-01963419766-94676550107-32542648198-96549393904-39850608367’, ‘69725922822-08559910362-36080928509-49601235010-15261238716’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 296, mergeExecResult: 0. shardingNode:map[612:{SchemaIndex=154, TableIndex=612, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1848104548, 6, ‘02931425025-68282480940-67294056291-41225608697-44038095895-05390291535-10414730978-25086630856-84460614365-62218384416’, ‘74426157735-27538600335-93122572838-36921241106-44481214039’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 305, mergeExecResult: 0. shardingNode:map[517:{SchemaIndex=130, TableIndex=517, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-543662597,</p>\n<p>cobar:<br>sysbench –mysql-host=10.1.21.242 –mysql-port=8066 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=10 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua cleanup<br>sysbench –mysql-host=10.1.21.242 –mysql-port=8066 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=10 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua prepare<br>sysbench –mysql-host=10.1.21.242 –mysql-port=8066 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=400 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua run</p>\n<p>zero-proxy<br>sysbench –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=10 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua cleanup<br>sysbench –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=10 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua prepare<br>sysbench –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=400 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua run</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb  –oltp-tables-count=5 prepare</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb  –oltp-tables-count=5 cleanup</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb –ssh-user=root –ssh-password=sdfsdf –oltp-tables-count=5 –write-threads=128 –read-threads=8 –max-time=3600 random</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb –ssh-user=root –ssh-password=sdfsdf –oltp-tables-count=5 –write-threads=128 –read-threads=8 –max-time=3600 seq</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb –ssh-user=root –ssh-password=sdfsdf –oltp-tables-count=5 –write-threads=4 –read-threads=300 –update-threads=20 –delete-threads=10 –max-time=360000000 random</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb –ssh-user=root –ssh-password=sdfsdf –oltp-tables-count=5 –write-threads=400 –read-threads=400 –max-time=3600 random</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"centos\"><a href=\"#centos\" class=\"headerlink\" title=\"centos\"></a>centos</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install sysbench</div></pre></td></tr></table></figure>\n<p>lua目录 /usr/share/sysbench/</p>\n<p>由于Cobar不支持SQL 92的表创建，所以需要修改/usr/share/sysbench/oltp_common.lua</p>\n<p>如果需要查看帮助</p>\n<p>则运行: sysbench [lua_path] help<br>比如: sysbench /usr/share/sysbench/oltp_insert.lua help</p>\n<p>sysbench –mysql-host=mac \\<br>–mysql-port=9696 \\<br>–mysql-user=zerodb \\<br>–mysql-password=zerodb \\<br>–mysql-db=zerodb \\<br>–threads=4 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 –events=0 \\<br>–percentile=99 \\<br>–report-interval=2 \\<br>/usr/local/Cellar/sysbench/1.0.11/share/sysbench/oltp_insert.lua \\</p>\n<p>#cobar_1</p>\n<p>sysbench –mysql-host=10.1.21.148 \\<br>–mysql-port=8066 \\<br>–mysql-user=user \\<br>–mysql-password=’user’ \\<br>–mysql-db=user \\<br>–threads=400 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 \\<br>–events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\</p>\n<p>#cobar_2</p>\n<p>sysbench –mysql-host=10.1.21.147 \\<br>–mysql-port=8066 \\<br>–mysql-user=user \\<br>–mysql-password=’user’ \\<br>–mysql-db=user \\<br>–threads=400 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 –events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\</p>\n<h3 id=\"测试报告\"><a href=\"#测试报告\" class=\"headerlink\" title=\"测试报告\"></a>测试报告</h3><p>[root@mq001 ~]# sysbench –mysql-host=10.1.21.147 –mysql-port=8066 –mysql-user=user –mysql-password=’user’ –mysql-db=user –threads=400 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=60 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua run<br>sysbench 1.0.9 (using system LuaJIT 2.0.4)</p>\n<p>Running the test with following options:<br>Number of threads: 400<br>Report intermediate results every 5 second(s)<br>Initializing random number generator from current time</p>\n<p>Initializing worker threads…</p>\n<p>Threads started!</p>\n<p>[ 5s ] thds: 400 tps: 11516.37 qps: 11516.37 (r/w/o: 0.00/11516.37/0.00) lat (ms,99%): 204.11 err/s: 0.00 reconn/s: 0.00<br>[ 10s ] thds: 400 tps: 2884.87 qps: 2884.87 (r/w/o: 0.00/2884.87/0.00) lat (ms,99%): 831.46 err/s: 0.00 reconn/s: 0.00<br>[ 15s ] thds: 400 tps: 4025.00 qps: 4025.00 (r/w/o: 0.00/4025.00/0.00) lat (ms,99%): 1869.60 err/s: 0.00 reconn/s: 0.00<br>[ 20s ] thds: 400 tps: 13497.32 qps: 13497.32 (r/w/o: 0.00/13497.32/0.00) lat (ms,99%): 142.39 err/s: 0.00 reconn/s: 0.00<br>[ 25s ] thds: 400 tps: 10908.17 qps: 10908.17 (r/w/o: 0.00/10908.17/0.00) lat (ms,99%): 144.97 err/s: 0.00 reconn/s: 0.00<br>[ 30s ] thds: 400 tps: 12280.74 qps: 12280.74 (r/w/o: 0.00/12280.74/0.00) lat (ms,99%): 132.49 err/s: 0.00 reconn/s: 0.00<br>[ 35s ] thds: 400 tps: 9783.37 qps: 9783.37 (r/w/o: 0.00/9783.37/0.00) lat (ms,99%): 150.29 err/s: 0.00 reconn/s: 0.00<br>[ 40s ] thds: 400 tps: 11703.52 qps: 11703.72 (r/w/o: 0.00/11703.72/0.00) lat (ms,99%): 173.58 err/s: 0.00 reconn/s: 0.00<br>[ 45s ] thds: 400 tps: 8253.06 qps: 8252.86 (r/w/o: 0.00/8252.86/0.00) lat (ms,99%): 207.82 err/s: 0.00 reconn/s: 0.00<br>[ 50s ] thds: 400 tps: 7148.98 qps: 7149.18 (r/w/o: 0.00/7149.18/0.00) lat (ms,99%): 657.93 err/s: 0.00 reconn/s: 0.00<br>[ 55s ] thds: 400 tps: 10911.35 qps: 10911.15 (r/w/o: 0.00/10911.15/0.00) lat (ms,99%): 176.73 err/s: 0.00 reconn/s: 0.00<br>[ 60s ] thds: 400 tps: 8702.48 qps: 8702.48 (r/w/o: 0.00/8702.48/0.00) lat (ms,99%): 235.74 err/s: 0.00 reconn/s: 0.00<br>SQL statistics:<br>    queries performed:<br>        read:                            0<br>        write:                           558494<br>        other:                           0<br>        total:                           558494<br>    transactions:                        558494 (9273.20 per sec.)<br>    queries:                             558494 (9273.20 per sec.)<br>    ignored errors:                      0      (0.00 per sec.)<br>    reconnects:                          0      (0.00 per sec.)</p>\n<p>General statistics:<br>    total time:                          60.2244s<br>    total number of events:              558494</p>\n<p>Latency (ms):<br>         min:                                  3.89<br>         avg:                                 43.02<br>         max:                               2881.01<br>         99th percentile:                    253.35<br>         sum:                            24023700.41</p>\n<p>Threads fairness:<br>    events (avg/stddev):           1396.2350/30.84<br>    execution time (avg/stddev):   60.0593/0.05</p>\n<p>[root@mq001 ~]# sysbench –mysql-host=10.1.21.148 –mysql-port=8066 –mysql-user=user –mysql-password=’user’ –mysql-db=user –threads=400 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=60 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua run<br>sysbench 1.0.9 (using system LuaJIT 2.0.4)</p>\n<p>Running the test with following options:<br>Number of threads: 400<br>Report intermediate results every 5 second(s)<br>Initializing random number generator from current time</p>\n<p>Initializing worker threads…</p>\n<p>Threads started!</p>\n<p>[ 5s ] thds: 400 tps: 10470.98 qps: 10470.98 (r/w/o: 0.00/10470.98/0.00) lat (ms,99%): 262.64 err/s: 0.00 reconn/s: 0.00<br>[ 10s ] thds: 400 tps: 3020.06 qps: 3020.06 (r/w/o: 0.00/3020.06/0.00) lat (ms,99%): 1050.76 err/s: 0.00 reconn/s: 0.00<br>[ 15s ] thds: 400 tps: 1107.64 qps: 1107.64 (r/w/o: 0.00/1107.64/0.00) lat (ms,99%): 1327.91 err/s: 0.00 reconn/s: 0.00<br>[ 20s ] thds: 400 tps: 7395.23 qps: 7395.23 (r/w/o: 0.00/7395.23/0.00) lat (ms,99%): 816.63 err/s: 0.00 reconn/s: 0.00<br>[ 25s ] thds: 400 tps: 12654.11 qps: 12654.11 (r/w/o: 0.00/12654.11/0.00) lat (ms,99%): 125.52 err/s: 0.00 reconn/s: 0.00<br>[ 30s ] thds: 400 tps: 10854.72 qps: 10854.92 (r/w/o: 0.00/10854.92/0.00) lat (ms,99%): 153.02 err/s: 0.00 reconn/s: 0.00<br>[ 35s ] thds: 400 tps: 11832.81 qps: 11832.61 (r/w/o: 0.00/11832.61/0.00) lat (ms,99%): 186.54 err/s: 0.00 reconn/s: 0.00<br>[ 40s ] thds: 400 tps: 6895.44 qps: 6895.44 (r/w/o: 0.00/6895.44/0.00) lat (ms,99%): 257.95 err/s: 0.00 reconn/s: 0.00<br>[ 45s ] thds: 400 tps: 12907.06 qps: 12907.06 (r/w/o: 0.00/12907.06/0.00) lat (ms,99%): 158.63 err/s: 0.00 reconn/s: 0.00<br>[ 50s ] thds: 400 tps: 7760.80 qps: 7760.80 (r/w/o: 0.00/7760.80/0.00) lat (ms,99%): 292.60 err/s: 0.00 reconn/s: 0.00<br>[ 55s ] thds: 400 tps: 11595.84 qps: 11595.84 (r/w/o: 0.00/11595.84/0.00) lat (ms,99%): 161.51 err/s: 0.00 reconn/s: 0.00<br>[ 60s ] thds: 400 tps: 10314.36 qps: 10314.36 (r/w/o: 0.00/10314.36/0.00) lat (ms,99%): 142.39 err/s: 0.00 reconn/s: 0.00<br>SQL statistics:<br>    queries performed:<br>        read:                            0<br>        write:                           534637<br>        other:                           0<br>        total:                           534637<br>    transactions:                        534637 (8890.97 per sec.)<br>    queries:                             534637 (8890.97 per sec.)<br>    ignored errors:                      0      (0.00 per sec.)<br>    reconnects:                          0      (0.00 per sec.)</p>\n<p>General statistics:<br>    total time:                          60.1304s<br>    total number of events:              534637</p>\n<p>Latency (ms):<br>         min:                                  4.14<br>         avg:                                 44.91<br>         max:                               3066.99<br>         99th percentile:                    292.60<br>         sum:                            24012284.54</p>\n<p>Threads fairness:<br>    events (avg/stddev):           1336.5925/23.11<br>    execution time (avg/stddev):   60.0307/0.03</p>\n<p>sysbench –mysql-host=10.1.134.195 \\<br>–mysql-port=8066 \\<br>–mysql-user=user \\<br>–mysql-password=’user’ \\<br>–mysql-db=user \\<br>–threads=400 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 \\<br>–events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\</p>\n<p>sysbench –mysql-host=10.1.21.242 \\<br>–mysql-port=9696 \\<br>–mysql-user=zerodb \\<br>–mysql-password=’zerodb’ \\<br>–mysql-db=zerodb \\<br>–threads=10 \\<br>–debug=on \\<br>–verbosity=5 \\<br>–tables=5 \\<br>–events=1 \\<br>–auto_inc=off \\<br>–table-size=1000 \\<br>–db-driver=mysql \\<br>–time=6000000 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_read_only.lua \\<br>run</p>\n<h1 id=\"zerodb\"><a href=\"#zerodb\" class=\"headerlink\" title=\"zerodb\"></a>zerodb</h1><p>sysbench –mysql-host=10.1.21.242 \\<br>–mysql-port=9696 \\<br>–mysql-user=zerodb \\<br>–mysql-password=’zerodb’ \\<br>–mysql-db=zerodb \\<br>–threads=10 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 –events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\<br>cleanup</p>\n<p>sysbench –mysql-host=10.1.21.242 \\<br>–mysql-port=9696 \\<br>–mysql-user=zerodb \\<br>–mysql-password=’zerodb’ \\<br>–mysql-db=zerodb \\<br>–threads=10 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 –events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\<br>prepare</p>\n<p>sysbench –mysql-host=10.1.21.242 \\<br>–mysql-port=9696 \\<br>–mysql-user=zerodb \\<br>–mysql-password=’zerodb’ \\<br>–mysql-db=zerodb \\<br>–threads=400 \\<br>–table-size=10 \\<br>–auto_inc=off \\<br>–tables=5 \\<br>–rand-type=uniform \\<br>–db-driver=mysql \\<br>–time=6000000 –events=0 \\<br>–percentile=99 \\<br>–report-interval=5 \\<br>/usr/share/sysbench/oltp_insert.lua \\<br>run</p>\n<p>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[899:{SchemaIndex=225, TableIndex=899, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1592131459, 7, ‘55016285732-53347045338-85834558147-71206675947-20854212178-67704861318-55023920639-15021922692-58783263226-91831209826’, ‘44804973802-80594424819-30662288113-07543047794-69158617276’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[607:{SchemaIndex=152, TableIndex=607, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1551461983, 1, ‘97565032345-06095273461-70708868939-89114711497-07191112359-84320966593-06915637429-34011520393-29123922986-41181266499’, ‘10350064023-47161933420-32840507920-65997397770-16177253238’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[371:{SchemaIndex=93, TableIndex=371, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1688397171, 3, ‘66563027950-07665251035-46015031422-61663761332-16063948763-45273359443-68411883367-29428347771-65572934442-17492196263’, ‘60851935379-49894017653-67952828882-67412344041-59230452535’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[1011:{SchemaIndex=253, TableIndex=1011, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-573803507, 2, ‘43589791346-92222019297-77586384271-52778612091-96284921979-05035493725-49350672130-03697130813-21052521840-31158762545’, ‘33228172883-24963516238-59142423481-48021525640-21772792414’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1001, mergeExecResult: 0. shardingNode:map[310:{SchemaIndex=78, TableIndex=310, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (439335222, 7, ‘03793368943-50266953542-49577833032-14468376728-10198261385-85128057368-15281808692-43095784178-01078624681-09027567677’, ‘45982088127-90369291605-80044281219-46887615792-75467747528’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 999, mergeExecResult: 0. shardingNode:map[259:{SchemaIndex=65, TableIndex=259, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (824478979, 9, ‘79929455805-82686000395-87933678180-97427805059-78850675331-66749630290-23371965370-59789760435-11687903028-37111392097’, ‘65387439360-90889047465-34899315444-83593158053-88419722270’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[388:{SchemaIndex=98, TableIndex=388, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1778834820, 4, ‘26400620948-86886163258-66955677020-24736956201-37633810654-62170837016-10953232786-08731106510-27930064178-11956848338’, ‘22734010461-63969213016-54927682118-22921617753-25869637636’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1000, mergeExecResult: 0. shardingNode:map[345:{SchemaIndex=87, TableIndex=345, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1906262361, 4, ‘73054929345-92331883054-27511894619-20000378864-11948567194-86713567705-11190297445-34047180586-99650690403-71903892017’, ‘07335571244-33555087386-76380202973-29490934882-40814481851’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[569:{SchemaIndex=143, TableIndex=569, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1606555193, 2, ‘94281857928-97538212927-39261666932-79938992409-52558016112-06785833668-50810169070-34555719774-82330250972-35853785503’, ‘29683325026-64124354800-63566774522-19722425169-37547560762’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[906:{SchemaIndex=227, TableIndex=906, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1143670666, 7, ‘74870370257-63163303467-80061015187-84192128665-25175084977-80554698357-24269465921-53186773519-78675020561-83488552374’, ‘73368269204-64304332325-34620567277-68846684629-38045820340’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[941:{SchemaIndex=236, TableIndex=941, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-1370776493, 6, ‘16692170437-43512178684-59516594203-75377838995-76081749306-71167865747-97237301685-23453441670-03667446181-56604717727’, ‘14195711604-53513247591-07873804194-96431257292-05520461785’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[872:{SchemaIndex=219, TableIndex=872, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1208557416, 5, ‘27703568859-81266825379-86789890837-60513053664-22258866897-34966682979-82761864561-83949706302-60135012966-31647733109’, ‘63271991640-87709697591-13072925018-38646644832-79179029573’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[991:{SchemaIndex=248, TableIndex=991, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (138564575, 6, ‘26857888685-88370802193-51045899118-07572056078-70111763976-05806767425-30208609378-20016792779-48308493020-29821526191’, ‘61555808494-05287717368-66884245341-45983655335-60458704606’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1007, mergeExecResult: 0. shardingNode:map[449:{SchemaIndex=113, TableIndex=449, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-229865921, 8, ‘14034106238-21876701329-38233326181-31158038417-73928237004-22908354046-72713486563-40610785127-99166317018-52234063725’, ‘23168975405-73598149943-63125122764-74527985990-06171559404’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[959:{SchemaIndex=240, TableIndex=959, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-677583807, 4, ‘40735866383-98457016615-08789114417-03599576561-48782283253-32055567198-88072330194-83020475968-03693883045-96278614943’, ‘70150968961-19151317381-16983120036-88185867422-84862477300’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1006, mergeExecResult: 0. shardingNode:map[406:{SchemaIndex=102, TableIndex=406, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-2093701526, 5, ‘09210536591-41896791043-73295525884-89613310006-75387609760-41655764025-47137540812-97100201238-15965683915-13727887851’, ‘48024514833-13441113380-49081922507-17183150276-06208568092’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[894:{SchemaIndex=224, TableIndex=894, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (108403582, 4, ‘58477996001-39515710854-83438883003-74672331816-19403553257-36113016280-00822951895-43706580851-50122510142-72629874469’, ‘25950012615-74047249694-75644797724-67405314152-48742553448’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[824:{SchemaIndex=207, TableIndex=824, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1108509496, 2, ‘05591703103-07428761202-09014510822-44571443153-87746638001-18005366596-37591757698-85345493107-52688524466-97341165803’, ‘90287453968-47714845240-54141462203-72968014933-11681199861’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[960:{SchemaIndex=241, TableIndex=960, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-432972736, 4, ‘32013395637-31037790439-99508763633-39582502523-46934970326-99846192559-79844868065-81128826635-19475623448-94555401729’, ‘72848617704-77451404798-55770002912-34209086424-23821979141’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[864:{SchemaIndex=217, TableIndex=864, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (209038176, 6, ‘31725269303-67222682770-97738396828-19717571752-01126165612-57542830563-51718817223-13687491781-38891241679-10677758794’, ‘40604117998-67635443824-03882862739-68433432919-44278589057’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[525:{SchemaIndex=132, TableIndex=525, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-663100941, 3, ‘13572309986-10356575142-87428874956-18162116973-83396135908-09352768769-83603227505-94165603992-17437041978-81761343722’, ‘58884262253-26008842705-81702669160-02709154611-78739667686’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[821:{SchemaIndex=206, TableIndex=821, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1290297141, 6, ‘28650953615-66926208686-47052429218-34545146184-51693579732-60563146329-00350338711-30136625347-99506216978-22404723673’, ‘30345581431-18594298965-23203468098-48853746952-30033247101’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[881:{SchemaIndex=221, TableIndex=881, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (2128759665, 3, ‘23557322059-62351008582-19218938648-55023996016-67978090662-04498693910-40333149725-65457542876-11556698223-86845640120’, ‘39531266486-08252986785-52805405505-62972899514-62765043827’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[829:{SchemaIndex=208, TableIndex=829, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1081064253, 2, ‘39396011527-03550826801-53544579241-44145722341-56423193708-85298116954-45172197891-54532848324-82241582599-97563898680’, ‘76749800295-63255838342-73258070193-02305060704-64352300433’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[900:{SchemaIndex=226, TableIndex=900, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-513806212, 1, ‘16727493623-40348083665-41922314110-05150944505-43353212884-59194917800-00753396008-63562258886-84259052626-93713085152’, ‘38634951090-07591809914-73325301815-73315254313-82978384844’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 1, mergeExecResult: 0. shardingNode:map[863:{SchemaIndex=216, TableIndex=863, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-450094943, 6, ‘23924438266-62111362125-81473873200-06328498397-88922636306-39182947784-05124699385-49780077333-57313760145-54634535492’, ‘96577223660-83042935121-28454288566-32057418883-39061132652’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[963:{SchemaIndex=241, TableIndex=963, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (1800163267, 4, ‘27948346446-05701199368-49149768636-18762164887-01870692332-13661773677-35851324771-46733712098-36653074427-31181566769’, ‘08781105428-22812332073-21224324603-72676647429-86438534524’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[878:{SchemaIndex=220, TableIndex=878, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1535190894, 9, ‘46310600095-97541020554-94065740469-24853513335-69630566641-31721053084-60343664925-46348792383-87749652424-52899212634’, ‘41944783155-15764748316-26823908956-07652542569-85074827204’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[906:{SchemaIndex=227, TableIndex=906, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1945995146, 4, ‘64447284661-78831878306-27636005022-88863833954-72613803410-72661880191-81775646793-56738842216-16376642732-30662007847’, ‘44349800594-98690127361-78211321236-38340738575-94555021426’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[907:{SchemaIndex=227, TableIndex=907, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1719256971, 3, ‘36693810506-14727560109-48871542333-86332816255-91899190554-43809786563-22813456576-32468291237-08105779091-35654765264’, ‘76792216525-13152293559-11187746420-35413475429-73316527358’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[827:{SchemaIndex=207, TableIndex=827, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1191957307, 3, ‘02373892720-70783246981-33072353568-68101913427-25982074179-25716557733-53487403333-33176741697-19961659954-24745733546’, ‘65228452942-44586411798-63293957289-46889416058-55247585232’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[715:{SchemaIndex=179, TableIndex=715, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-368940747, 10, ‘83732843347-38915816227-71028864502-83867874900-55259635749-04867892981-61246311166-86657029985-98371125854-01109713202’, ‘28665022675-32159696841-27962719413-92137483719-65438251505’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[531:{SchemaIndex=133, TableIndex=531, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (296709651, 4, ‘68512385573-12594713777-31891099071-55341413329-96572532552-89441743744-75535604911-39664974035-50293453830-41657909966’, ‘54516090919-10379612997-70745484084-47657473576-34684395884’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 2, mergeExecResult: 0. shardingNode:map[1010:{SchemaIndex=253, TableIndex=1010, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (375408626, 5, ‘86917579879-69750606525-04310713441-66206378609-22671203503-85955817483-08099675016-87194148638-56030296183-72576969654’, ‘14638356398-42816005551-86372571322-85471822123-78848498639’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 207, mergeExecResult: 0. shardingNode:map[481:{SchemaIndex=121, TableIndex=481, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-453506529, 7, ‘05922416371-88423926572-06168309932-36230491079-35838894643-96519731061-10785734640-51619035736-36739664574-07173836937’, ‘86251074060-14148969607-50675271708-72280786641-89845672651’)]<br>WARN[0449] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 999, mergeExecResult: 0. shardingNode:map[506:{SchemaIndex=127, TableIndex=506, HostGroup=hostGroup2}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (923516410, 1, ‘71118741783-11388565696-96706199622-38503412573-05309353257-45864148538-09400667746-21110528894-17837136283-91361843504’, ‘67292585002-85708710331-29800085937-37291514623-47320174130’)] </p>\n<p>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 306, mergeExecResult: 0. shardingNode:map[540:{SchemaIndex=136, TableIndex=540, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1344100892, 4, ‘37923605607-42327774961-35128132820-48158088043-25957128013-51759124002-40449799093-68433809807-31405796686-22817252999’, ‘94291235269-60160247565-39950122186-97684115599-96232437155’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 211, mergeExecResult: 0. shardingNode:map[540:{SchemaIndex=136, TableIndex=540, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-757833244, 5, ‘50104262688-83666007823-06989738144-95141595109-93329094811-13832991101-93076033912-05017862363-35692005246-88744289137’, ‘54081433849-09378248558-38274752100-88855316211-27289637272’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[198:{SchemaIndex=50, TableIndex=198, HostGroup=hostGroup1}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (652469446, 1, ‘07652454524-22981957011-41438122391-90347773905-88663504044-48425601588-32127975840-28199749965-27298300589-25715051794’, ‘60470366939-49887579866-34848349508-29262200362-52000338086’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[670:{SchemaIndex=168, TableIndex=670, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-212205214, 3, ‘39093408635-10213704095-82878149257-88673860178-07278582464-52697390774-95388237318-03462450231-66036638124-64228596635’, ‘38716722580-86486363760-61985600779-83841271441-42765235992’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 248, mergeExecResult: 0. shardingNode:map[594:{SchemaIndex=149, TableIndex=594, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1136835154, 2, ‘23757270379-51595389012-47476784586-71294005118-20959815636-40533304860-41036462462-22519409530-16151251756-29363403201’, ‘02895678318-89791495824-44276206517-37575326693-35714861579’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 196, mergeExecResult: 0. shardingNode:map[596:{SchemaIndex=150, TableIndex=596, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (927250004, 3, ‘02232667199-83769701794-18129066725-31520472849-93375763771-42931518091-56094856485-24182688367-31807939112-07474880757’, ‘46530309679-12705910558-69428237706-14629411089-19801742204’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 213, mergeExecResult: 0. shardingNode:map[568:{SchemaIndex=143, TableIndex=568, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1908502072, 6, ‘11131352749-42538464007-16895664672-62644300750-86974265339-82077852146-68660984992-78157770948-82596046151-02353070903’, ‘35289675345-82804575493-00647347117-53443940605-48670213485’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[530:{SchemaIndex=133, TableIndex=530, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1565462034, 2, ‘03766551315-88042959333-06619558863-52259377137-27072539179-52210031586-63547684874-18650692849-22136096911-63673950864’, ‘23300762166-38283070103-67223042934-76314148059-35039279078’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 252, mergeExecResult: 0. shardingNode:map[705:{SchemaIndex=177, TableIndex=705, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-282929857, 9, ‘78018924775-94910259974-14900983402-30428448745-60064721591-40668444882-53712901782-65346911189-59688209606-74312372904’, ‘82234943021-50353143509-80352130420-57571772487-81475633439’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 291, mergeExecResult: 0. shardingNode:map[724:{SchemaIndex=182, TableIndex=724, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (2109119188, 7, ‘36086413796-51767176683-52982238848-36460965892-84578503998-21697029291-39139590496-18305440259-61532992900-70589028518’, ‘30048526034-08924322516-87289516951-51922079500-47125778015’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 210, mergeExecResult: 0. shardingNode:map[573:{SchemaIndex=144, TableIndex=573, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-994558525, 8, ‘74078055913-58294585862-48131723756-93089582597-72949713745-85429496032-27905841748-82110966829-12174780172-45947256767’, ‘52598986037-80854622196-65516850169-26314282473-46184813701’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 99, mergeExecResult: 0. shardingNode:map[701:{SchemaIndex=176, TableIndex=701, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (1290611389, 10, ‘06010961323-54786660073-11823817491-71384866194-20002003501-13527828508-52664186690-95551041252-11585296099-86883272955’, ‘35567244596-82663971593-11831798779-27870930145-87441039863’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 292, mergeExecResult: 0. shardingNode:map[567:{SchemaIndex=142, TableIndex=567, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (810312247, 10, ‘41210873160-21444867641-91122365510-19036499914-34569882163-29091701055-84873343605-60726600041-00757500001-24263691698’, ‘41652074477-40057441865-33409084588-16838407116-03941310610’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 3, mergeExecResult: 0. shardingNode:map[213:{SchemaIndex=54, TableIndex=213, HostGroup=hostGroup1}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1881853141, 2, ‘14742564348-19913327041-96137703234-33860693319-12765733015-19685217285-90407570147-69715707192-71609875203-72224693707’, ‘62398998246-64288014470-28245239723-29976129053-08238346550’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 242, mergeExecResult: 0. shardingNode:map[698:{SchemaIndex=175, TableIndex=698, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1011920570, 2, ‘33865708347-82274332444-45097600411-92274439334-16926356904-33828206076-16463987600-06687756787-06453656924-53622006994’, ‘48462480629-04943720987-66250435599-66843177447-86484400166’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 195, mergeExecResult: 0. shardingNode:map[710:{SchemaIndex=178, TableIndex=710, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-2128817862, 7, ‘12483300987-88535524922-66334741529-64659385522-75032596868-93466219012-01222978665-55122702202-84142740410-53583589563’, ‘89132580254-79206347601-13534456013-96027776935-07650599065’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 233, mergeExecResult: 0. shardingNode:map[544:{SchemaIndex=137, TableIndex=544, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1496016416, 9, ‘99154323337-90872497215-53698284897-04686362817-35622767062-48356019022-04016504226-75493501145-38429448892-66989460733’, ‘84409926268-28404056573-96777093808-13481662538-98898905310’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 27, mergeExecResult: 0. shardingNode:map[907:{SchemaIndex=227, TableIndex=907, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (756613003, 1, ‘48041615531-14651008388-14559884387-33045819966-91038786346-39394412181-13147015451-43265025586-90014901196-20159726596’, ‘62496325099-63432555894-84244639858-58924561742-12138512609’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 284, mergeExecResult: 0. shardingNode:map[525:{SchemaIndex=132, TableIndex=525, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (588268045, 3, ‘01778869912-44391681202-43730989451-99650497628-58071023040-36244500937-05173857724-21592385062-52662008534-88410130321’, ‘68551597952-73268487812-26478068307-11227961732-49092247276’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 229, mergeExecResult: 0. shardingNode:map[674:{SchemaIndex=169, TableIndex=674, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (75111074, 1, ‘07857287095-83026714634-10012972058-11441297287-80787536524-31038348780-79408482259-95286783641-23620583564-94195135059’, ‘39714908056-38058099094-71552841772-10457961132-39419941227’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 230, mergeExecResult: 0. shardingNode:map[577:{SchemaIndex=145, TableIndex=577, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-911965761, 8, ‘07321418565-94055920833-16462957068-14933742620-00134077423-05303377934-66121817102-49230219319-72774150061-80468601177’, ‘26522648558-75134929821-83594530381-47917024515-31668467194’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 232, mergeExecResult: 0. shardingNode:map[513:{SchemaIndex=129, TableIndex=513, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (1315070465, 5, ‘15474433240-84784850443-17796367719-48021520867-10943303644-48200729918-91013947900-33061132253-28956163141-98846516045’, ‘99644114596-46918915095-13462299586-15204837308-12785249281’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 231, mergeExecResult: 0. shardingNode:map[737:{SchemaIndex=185, TableIndex=737, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-180994785, 9, ‘61681162669-07252910162-88941330016-07633567093-86234290556-74605484081-92189953463-28499401861-08881094341-04206273246’, ‘73069152681-47514577462-53755512339-63165295325-04957863379’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 225, mergeExecResult: 0. shardingNode:map[583:{SchemaIndex=146, TableIndex=583, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (905672263, 5, ‘11686869034-48032081508-20645314791-73241768758-13634493369-36096577158-76040275597-65556337906-73745369125-93817830861’, ‘25154935190-35760055237-67095134841-73686707222-08327146392’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 227, mergeExecResult: 0. shardingNode:map[568:{SchemaIndex=143, TableIndex=568, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (1028081208, 6, ‘65787201754-47681590360-50036937953-38544197509-01589612011-17576022949-32999165698-83171817746-37315560344-14463882405’, ‘65637926145-34138639858-41094177281-29428779399-44688752051’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 232, mergeExecResult: 0. shardingNode:map[558:{SchemaIndex=140, TableIndex=558, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (278584878, 10, ‘32358945918-66413584434-88058020708-48390261093-67208582401-88568979078-90497400157-49426845556-80952580018-13610087462’, ‘14198786100-85805610838-89824761297-62058901344-60492560838’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 228, mergeExecResult: 0. shardingNode:map[649:{SchemaIndex=163, TableIndex=649, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (1183431305, 2, ‘43858458237-46788126262-05213368147-07302202409-13593899883-99375055319-42875375550-56499216168-01796902390-08647652700’, ‘48205424174-34611724289-69246697079-03898745311-99595319598’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 26, mergeExecResult: 0. shardingNode:map[1002:{SchemaIndex=251, TableIndex=1002, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1701967850, 9, ‘59147040383-79705593723-62886101805-60535881029-18413556495-06238443919-02766097021-38361379870-67179305438-52530038201’, ‘14770296700-13396847549-83905253251-99337969432-58669912709’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 229, mergeExecResult: 0. shardingNode:map[745:{SchemaIndex=187, TableIndex=745, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-1169184489, 7, ‘64955629118-36147506634-51676575477-92147977264-45999410094-15567300060-12836575112-28470342888-04361926080-90629622527’, ‘86593300354-87140619605-87718697448-88392415837-04795141111’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 272, mergeExecResult: 0. shardingNode:map[662:{SchemaIndex=166, TableIndex=662, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (1555424918, 10, ‘11260581771-57660361810-58723152189-43635886031-41094065361-37903459575-65856768363-01843670891-17848285384-92171598763’, ‘36462031678-64770373669-77316073133-32672501580-50753545368’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 271, mergeExecResult: 0. shardingNode:map[736:{SchemaIndex=185, TableIndex=736, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-270642912, 9, ‘87806093665-04774113218-83983577041-09351362099-88339377062-22401969710-89370302094-61598971830-04573362584-60421137580’, ‘26415700902-09148763904-87375314444-00285784497-80449574080’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 222, mergeExecResult: 0. shardingNode:map[588:{SchemaIndex=148, TableIndex=588, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (-1608970828, 2, ‘75571666926-33738024136-84313793696-10714487345-57088294174-41711334397-51382524640-08327299973-66970622008-15344703881’, ‘73366501022-14368954292-21130701303-33960859630-28160972955’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 220, mergeExecResult: 0. shardingNode:map[556:{SchemaIndex=140, TableIndex=556, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-993863212, 3, ‘68136313990-05892185009-94544559127-32267303237-37763842514-89959134082-97215598641-72307869276-49642816905-24994127953’, ‘97111382859-69888150629-89398585714-99569889618-30099083026’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 220, mergeExecResult: 0. shardingNode:map[513:{SchemaIndex=129, TableIndex=513, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1299240449, 6, ‘13580427730-91599560017-42392676834-62860979245-65274043134-68243135520-42672727926-56794775679-69217526806-27227304772’, ‘15736027942-38175115801-93773367279-77944721463-03173899187’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 214, mergeExecResult: 0. shardingNode:map[579:{SchemaIndex=145, TableIndex=579, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1346301507, 2, ‘95777728263-97322915970-24025444526-11872987788-74589515383-37108287704-62890589663-84327075019-58161194629-66166453693’, ‘43925335448-41493749427-45817169562-78879091928-39249185154’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 252, mergeExecResult: 0. shardingNode:map[723:{SchemaIndex=181, TableIndex=723, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest3 (id, k, c, pad) VALUES (-1604556499, 3, ‘54964824319-34611710514-15902154995-18014105243-70193115677-91112406449-61348366967-41301887681-73892593737-54039590822’, ‘26491514771-24473569991-16656607124-07593925149-74926670900’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 253, mergeExecResult: 0. shardingNode:map[715:{SchemaIndex=179, TableIndex=715, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (533688011, 7, ‘17872695538-16064539790-18108982113-60646269894-74784931403-89606878485-67937667670-39824753762-37339034055-79511964331’, ‘65227853620-62393117281-88901273019-02060144110-40123779052’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 223, mergeExecResult: 0. shardingNode:map[731:{SchemaIndex=183, TableIndex=731, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (548553435, 7, ‘59524856205-92318067592-84001816236-15799238765-61939312958-49774297702-51059777347-11521186806-90725070157-29567571966’, ‘72604893873-81336794708-64989781571-89144801847-53529920629’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 296, mergeExecResult: 0. shardingNode:map[646:{SchemaIndex=162, TableIndex=646, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest4 (id, k, c, pad) VALUES (-1980507782, 8, ‘15361099362-33426846104-81568076007-88926275697-54147190617-21941361738-39219198670-72817831326-95768248501-29228997291’, ‘51713925651-55077435995-56372978084-60334222441-07023013203’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 27, mergeExecResult: 0. shardingNode:map[1023:{SchemaIndex=256, TableIndex=1023, HostGroup=hostGroup4}], SQL: [INSERT INTO sbtest1 (id, k, c, pad) VALUES (419830783, 9, ‘39839456224-14625126106-10611694673-69035645226-20746732552-01963419766-94676550107-32542648198-96549393904-39850608367’, ‘69725922822-08559910362-36080928509-49601235010-15261238716’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 296, mergeExecResult: 0. shardingNode:map[612:{SchemaIndex=154, TableIndex=612, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest2 (id, k, c, pad) VALUES (-1848104548, 6, ‘02931425025-68282480940-67294056291-41225608697-44038095895-05390291535-10414730978-25086630856-84460614365-62218384416’, ‘74426157735-27538600335-93122572838-36921241106-44481214039’)]<br>WARN[0292] Slow SQL. shardingCount: 1, buildPlan: 0, getShardConns: 0, executeInMultiNodes: 305, mergeExecResult: 0. shardingNode:map[517:{SchemaIndex=130, TableIndex=517, HostGroup=hostGroup3}], SQL: [INSERT INTO sbtest5 (id, k, c, pad) VALUES (-543662597,</p>\n<p>cobar:<br>sysbench –mysql-host=10.1.21.242 –mysql-port=8066 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=10 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua cleanup<br>sysbench –mysql-host=10.1.21.242 –mysql-port=8066 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=10 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua prepare<br>sysbench –mysql-host=10.1.21.242 –mysql-port=8066 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=400 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua run</p>\n<p>zero-proxy<br>sysbench –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=10 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua cleanup<br>sysbench –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=10 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua prepare<br>sysbench –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-user=zerodb –mysql-password=’zerodb’ –mysql-db=zerodb –threads=400 –table-size=10 –auto_inc=off –tables=5 –rand-type=uniform –db-driver=mysql –time=6000000 –events=0 –percentile=99 –report-interval=5 /usr/share/sysbench/oltp_insert.lua run</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb  –oltp-tables-count=5 prepare</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb  –oltp-tables-count=5 cleanup</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb –ssh-user=root –ssh-password=sdfsdf –oltp-tables-count=5 –write-threads=128 –read-threads=8 –max-time=3600 random</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb –ssh-user=root –ssh-password=sdfsdf –oltp-tables-count=5 –write-threads=128 –read-threads=8 –max-time=3600 seq</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb –ssh-user=root –ssh-password=sdfsdf –oltp-tables-count=5 –write-threads=4 –read-threads=300 –update-threads=20 –delete-threads=10 –max-time=360000000 random</p>\n<p>./benchyou –mysql-host=10.1.21.242 –mysql-port=9696 –mysql-db=zerodb –mysql-user=zerodb –mysql-password=zerodb –ssh-user=root –ssh-password=sdfsdf –oltp-tables-count=5 –write-threads=400 –read-threads=400 –max-time=3600 random</p>\n"},{"title":"Cobar——Reactor设计模式","date":"2017-07-24T10:00:58.000Z","_content":"\n### I/O多路复用（multiplexing）和 行为分用（demultiplexing）\n\n不急，我们先看例子:\n\n假设一个班上有5个老师，其中一个为主考官，让3000个学生现场画一幅图，然后给每个学生一个分数。学生在画图之前有时间思考，但不能动笔，等到作画有灵感了，举手向老师示意，老师来现场看你作画。\n\n你有下面几个选择：\n\n1. 第一种选择：一个老师（多了也是乱）按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生画得特别慢，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。\n\n2. 第二种选择：你创建3000个分身，让每个分身检查一个学生的作画过程，由于本身只有5名老师，分身不具备检查的功能，只能发一些比如「开始」「结束」的指令，所以理论上这5个老师在所有的分身中来回切换。 这种类似于为每一个用户创建一个线程处理连接。缺点是需要太多的分身\n\n3. 第三种选择，你先创建100个分身，5名老师站在讲台上等，你作为主考官，谁思考完谁举手。这时C、D、G几乎同时举手，表示他们已经想好怎么画了，你自己不下去亲自处理，你派你10个分身中的三个下去依次检查C、D、G的作画，你然后继续等，分身由另外四位老师管理，分身处理完会自动归队。此时E、A又举手，然后去处理E和A。。。 \n\n这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。\n\n如果以上学生和老师场景都不变，但现场作画改成现场算高数题目（高等数学题目）。那分身设置为100合理不？\n\n多路复用（multiplexing）体现在：主考官一个人去检查所有学生的举手示意情况，所有的连接被一个线程复用了。\n单路分用（demultiplexing）体现在：主考官自己不处理具体的作画批改，而是把任务分用到各个分身去。\n\n### Cobar Reactor\n\n![](Cobar-Reactor-design-pattern/CobarReactorSign.gif)\n\n#### NIO原生API\n\n![](Cobar-Reactor-design-pattern/NioRegister.gif)\n\n#### Cobar NIO Server线程模型\n\n![](Cobar-Reactor-design-pattern/CobarReactor.gif)\n\n#### Cobar的整个模型非常像 Fork/Join\nForks and Joins: When a job arrives at a fork point, it is split into N sub-jobs which are then serviced by n tasks. After being serviced, each sub-job waits until all other sub-jobs are done processing. Then, they are joined again and leave the system. Thus, in parallel programming, we require synchronization as all the parallel processes wait for several other processes to occur.\n\n\n### 如何深刻理解reactor和proactor？\n\nreactor：能收了你跟俺说一声。\nproactor: 你给我收十个字节，收好了跟俺说一声。\n\nRefer:\nhttp://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf\n\n","source":"_posts/Cobar-Reactor-design-pattern.md","raw":"---\ntitle: Cobar——Reactor设计模式\ndate: 2017-07-24 18:00:58\ntags: Cobar\n---\n\n### I/O多路复用（multiplexing）和 行为分用（demultiplexing）\n\n不急，我们先看例子:\n\n假设一个班上有5个老师，其中一个为主考官，让3000个学生现场画一幅图，然后给每个学生一个分数。学生在画图之前有时间思考，但不能动笔，等到作画有灵感了，举手向老师示意，老师来现场看你作画。\n\n你有下面几个选择：\n\n1. 第一种选择：一个老师（多了也是乱）按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生画得特别慢，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。\n\n2. 第二种选择：你创建3000个分身，让每个分身检查一个学生的作画过程，由于本身只有5名老师，分身不具备检查的功能，只能发一些比如「开始」「结束」的指令，所以理论上这5个老师在所有的分身中来回切换。 这种类似于为每一个用户创建一个线程处理连接。缺点是需要太多的分身\n\n3. 第三种选择，你先创建100个分身，5名老师站在讲台上等，你作为主考官，谁思考完谁举手。这时C、D、G几乎同时举手，表示他们已经想好怎么画了，你自己不下去亲自处理，你派你10个分身中的三个下去依次检查C、D、G的作画，你然后继续等，分身由另外四位老师管理，分身处理完会自动归队。此时E、A又举手，然后去处理E和A。。。 \n\n这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。\n\n如果以上学生和老师场景都不变，但现场作画改成现场算高数题目（高等数学题目）。那分身设置为100合理不？\n\n多路复用（multiplexing）体现在：主考官一个人去检查所有学生的举手示意情况，所有的连接被一个线程复用了。\n单路分用（demultiplexing）体现在：主考官自己不处理具体的作画批改，而是把任务分用到各个分身去。\n\n### Cobar Reactor\n\n![](Cobar-Reactor-design-pattern/CobarReactorSign.gif)\n\n#### NIO原生API\n\n![](Cobar-Reactor-design-pattern/NioRegister.gif)\n\n#### Cobar NIO Server线程模型\n\n![](Cobar-Reactor-design-pattern/CobarReactor.gif)\n\n#### Cobar的整个模型非常像 Fork/Join\nForks and Joins: When a job arrives at a fork point, it is split into N sub-jobs which are then serviced by n tasks. After being serviced, each sub-job waits until all other sub-jobs are done processing. Then, they are joined again and leave the system. Thus, in parallel programming, we require synchronization as all the parallel processes wait for several other processes to occur.\n\n\n### 如何深刻理解reactor和proactor？\n\nreactor：能收了你跟俺说一声。\nproactor: 你给我收十个字节，收好了跟俺说一声。\n\nRefer:\nhttp://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf\n\n","slug":"Cobar-Reactor-design-pattern","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyb000m3iq28hisx8ou","content":"<h3 id=\"I-O多路复用（multiplexing）和-行为分用（demultiplexing）\"><a href=\"#I-O多路复用（multiplexing）和-行为分用（demultiplexing）\" class=\"headerlink\" title=\"I/O多路复用（multiplexing）和 行为分用（demultiplexing）\"></a>I/O多路复用（multiplexing）和 行为分用（demultiplexing）</h3><p>不急，我们先看例子:</p>\n<p>假设一个班上有5个老师，其中一个为主考官，让3000个学生现场画一幅图，然后给每个学生一个分数。学生在画图之前有时间思考，但不能动笔，等到作画有灵感了，举手向老师示意，老师来现场看你作画。</p>\n<p>你有下面几个选择：</p>\n<ol>\n<li><p>第一种选择：一个老师（多了也是乱）按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生画得特别慢，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p>\n</li>\n<li><p>第二种选择：你创建3000个分身，让每个分身检查一个学生的作画过程，由于本身只有5名老师，分身不具备检查的功能，只能发一些比如「开始」「结束」的指令，所以理论上这5个老师在所有的分身中来回切换。 这种类似于为每一个用户创建一个线程处理连接。缺点是需要太多的分身</p>\n</li>\n<li><p>第三种选择，你先创建100个分身，5名老师站在讲台上等，你作为主考官，谁思考完谁举手。这时C、D、G几乎同时举手，表示他们已经想好怎么画了，你自己不下去亲自处理，你派你10个分身中的三个下去依次检查C、D、G的作画，你然后继续等，分身由另外四位老师管理，分身处理完会自动归队。此时E、A又举手，然后去处理E和A。。。 </p>\n</li>\n</ol>\n<p>这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。</p>\n<p>如果以上学生和老师场景都不变，但现场作画改成现场算高数题目（高等数学题目）。那分身设置为100合理不？</p>\n<p>多路复用（multiplexing）体现在：主考官一个人去检查所有学生的举手示意情况，所有的连接被一个线程复用了。<br>单路分用（demultiplexing）体现在：主考官自己不处理具体的作画批改，而是把任务分用到各个分身去。</p>\n<h3 id=\"Cobar-Reactor\"><a href=\"#Cobar-Reactor\" class=\"headerlink\" title=\"Cobar Reactor\"></a>Cobar Reactor</h3><p><img src=\"/2017/07/24/Cobar-Reactor-design-pattern/CobarReactorSign.gif\" alt=\"\"></p>\n<h4 id=\"NIO原生API\"><a href=\"#NIO原生API\" class=\"headerlink\" title=\"NIO原生API\"></a>NIO原生API</h4><p><img src=\"/2017/07/24/Cobar-Reactor-design-pattern/NioRegister.gif\" alt=\"\"></p>\n<h4 id=\"Cobar-NIO-Server线程模型\"><a href=\"#Cobar-NIO-Server线程模型\" class=\"headerlink\" title=\"Cobar NIO Server线程模型\"></a>Cobar NIO Server线程模型</h4><p><img src=\"/2017/07/24/Cobar-Reactor-design-pattern/CobarReactor.gif\" alt=\"\"></p>\n<h4 id=\"Cobar的整个模型非常像-Fork-Join\"><a href=\"#Cobar的整个模型非常像-Fork-Join\" class=\"headerlink\" title=\"Cobar的整个模型非常像 Fork/Join\"></a>Cobar的整个模型非常像 Fork/Join</h4><p>Forks and Joins: When a job arrives at a fork point, it is split into N sub-jobs which are then serviced by n tasks. After being serviced, each sub-job waits until all other sub-jobs are done processing. Then, they are joined again and leave the system. Thus, in parallel programming, we require synchronization as all the parallel processes wait for several other processes to occur.</p>\n<h3 id=\"如何深刻理解reactor和proactor？\"><a href=\"#如何深刻理解reactor和proactor？\" class=\"headerlink\" title=\"如何深刻理解reactor和proactor？\"></a>如何深刻理解reactor和proactor？</h3><p>reactor：能收了你跟俺说一声。<br>proactor: 你给我收十个字节，收好了跟俺说一声。</p>\n<p>Refer:<br><a href=\"http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf\" target=\"_blank\" rel=\"external\">http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"I-O多路复用（multiplexing）和-行为分用（demultiplexing）\"><a href=\"#I-O多路复用（multiplexing）和-行为分用（demultiplexing）\" class=\"headerlink\" title=\"I/O多路复用（multiplexing）和 行为分用（demultiplexing）\"></a>I/O多路复用（multiplexing）和 行为分用（demultiplexing）</h3><p>不急，我们先看例子:</p>\n<p>假设一个班上有5个老师，其中一个为主考官，让3000个学生现场画一幅图，然后给每个学生一个分数。学生在画图之前有时间思考，但不能动笔，等到作画有灵感了，举手向老师示意，老师来现场看你作画。</p>\n<p>你有下面几个选择：</p>\n<ol>\n<li><p>第一种选择：一个老师（多了也是乱）按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生画得特别慢，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p>\n</li>\n<li><p>第二种选择：你创建3000个分身，让每个分身检查一个学生的作画过程，由于本身只有5名老师，分身不具备检查的功能，只能发一些比如「开始」「结束」的指令，所以理论上这5个老师在所有的分身中来回切换。 这种类似于为每一个用户创建一个线程处理连接。缺点是需要太多的分身</p>\n</li>\n<li><p>第三种选择，你先创建100个分身，5名老师站在讲台上等，你作为主考官，谁思考完谁举手。这时C、D、G几乎同时举手，表示他们已经想好怎么画了，你自己不下去亲自处理，你派你10个分身中的三个下去依次检查C、D、G的作画，你然后继续等，分身由另外四位老师管理，分身处理完会自动归队。此时E、A又举手，然后去处理E和A。。。 </p>\n</li>\n</ol>\n<p>这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。</p>\n<p>如果以上学生和老师场景都不变，但现场作画改成现场算高数题目（高等数学题目）。那分身设置为100合理不？</p>\n<p>多路复用（multiplexing）体现在：主考官一个人去检查所有学生的举手示意情况，所有的连接被一个线程复用了。<br>单路分用（demultiplexing）体现在：主考官自己不处理具体的作画批改，而是把任务分用到各个分身去。</p>\n<h3 id=\"Cobar-Reactor\"><a href=\"#Cobar-Reactor\" class=\"headerlink\" title=\"Cobar Reactor\"></a>Cobar Reactor</h3><p><img src=\"/2017/07/24/Cobar-Reactor-design-pattern/CobarReactorSign.gif\" alt=\"\"></p>\n<h4 id=\"NIO原生API\"><a href=\"#NIO原生API\" class=\"headerlink\" title=\"NIO原生API\"></a>NIO原生API</h4><p><img src=\"/2017/07/24/Cobar-Reactor-design-pattern/NioRegister.gif\" alt=\"\"></p>\n<h4 id=\"Cobar-NIO-Server线程模型\"><a href=\"#Cobar-NIO-Server线程模型\" class=\"headerlink\" title=\"Cobar NIO Server线程模型\"></a>Cobar NIO Server线程模型</h4><p><img src=\"/2017/07/24/Cobar-Reactor-design-pattern/CobarReactor.gif\" alt=\"\"></p>\n<h4 id=\"Cobar的整个模型非常像-Fork-Join\"><a href=\"#Cobar的整个模型非常像-Fork-Join\" class=\"headerlink\" title=\"Cobar的整个模型非常像 Fork/Join\"></a>Cobar的整个模型非常像 Fork/Join</h4><p>Forks and Joins: When a job arrives at a fork point, it is split into N sub-jobs which are then serviced by n tasks. After being serviced, each sub-job waits until all other sub-jobs are done processing. Then, they are joined again and leave the system. Thus, in parallel programming, we require synchronization as all the parallel processes wait for several other processes to occur.</p>\n<h3 id=\"如何深刻理解reactor和proactor？\"><a href=\"#如何深刻理解reactor和proactor？\" class=\"headerlink\" title=\"如何深刻理解reactor和proactor？\"></a>如何深刻理解reactor和proactor？</h3><p>reactor：能收了你跟俺说一声。<br>proactor: 你给我收十个字节，收好了跟俺说一声。</p>\n<p>Refer:<br><a href=\"http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf\" target=\"_blank\" rel=\"external\">http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf</a></p>\n"},{"title":"curator——分布式锁的实现之一","date":"2017-09-28T08:58:05.000Z","_content":"\n\n### MySQL实现\n\n\n### Redis\n\nhttp://blog.csdn.net/bolg_hero/article/details/78532920\n\n### ZooKeeper\n RedLock\n\n\n``` java\npublic class InterProcessMutexTest {\n    public static final String LOCK_PATH = \"/curator-kick-off/lock\";\n    private static CuratorFramework client;\n\n    @BeforeClass\n    public static void before() {\n        client = CuratorFrameworkFactory.newClient(\n                \"127.0.0.1:2181\",\n                1000 * 10,\n                3000, new ExponentialBackoffRetry(\n                        1000,\n                        3));\n        client.start();\n    }\n\n    @Test\n    public void test() throws Exception {\n        InterProcessMutex lock = new InterProcessMutex(client, LOCK_PATH);\n        boolean acquire = lock.acquire(5, TimeUnit.SECONDS);\n        System.out.println(acquire);\n        System.out.println(\"done\");\n        lock.release();\n        System.in.read();\n    }\n}\n```\n","source":"_posts/Curator-Distributed-lock.md","raw":"---\ntitle: curator——分布式锁的实现之一\ndate: 2017-09-28 16:58:05\ntags: Curator\n---\n\n\n### MySQL实现\n\n\n### Redis\n\nhttp://blog.csdn.net/bolg_hero/article/details/78532920\n\n### ZooKeeper\n RedLock\n\n\n``` java\npublic class InterProcessMutexTest {\n    public static final String LOCK_PATH = \"/curator-kick-off/lock\";\n    private static CuratorFramework client;\n\n    @BeforeClass\n    public static void before() {\n        client = CuratorFrameworkFactory.newClient(\n                \"127.0.0.1:2181\",\n                1000 * 10,\n                3000, new ExponentialBackoffRetry(\n                        1000,\n                        3));\n        client.start();\n    }\n\n    @Test\n    public void test() throws Exception {\n        InterProcessMutex lock = new InterProcessMutex(client, LOCK_PATH);\n        boolean acquire = lock.acquire(5, TimeUnit.SECONDS);\n        System.out.println(acquire);\n        System.out.println(\"done\");\n        lock.release();\n        System.in.read();\n    }\n}\n```\n","slug":"Curator-Distributed-lock","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyc000o3iq2moo800ti","content":"<h3 id=\"MySQL实现\"><a href=\"#MySQL实现\" class=\"headerlink\" title=\"MySQL实现\"></a>MySQL实现</h3><h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><p><a href=\"http://blog.csdn.net/bolg_hero/article/details/78532920\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/bolg_hero/article/details/78532920</a></p>\n<h3 id=\"ZooKeeper\"><a href=\"#ZooKeeper\" class=\"headerlink\" title=\"ZooKeeper\"></a>ZooKeeper</h3><p> RedLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InterProcessMutexTest</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOCK_PATH = <span class=\"string\">\"/curator-kick-off/lock\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CuratorFramework client;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@BeforeClass</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        client = CuratorFrameworkFactory.newClient(</div><div class=\"line\">                <span class=\"string\">\"127.0.0.1:2181\"</span>,</div><div class=\"line\">                <span class=\"number\">1000</span> * <span class=\"number\">10</span>,</div><div class=\"line\">                <span class=\"number\">3000</span>, <span class=\"keyword\">new</span> ExponentialBackoffRetry(</div><div class=\"line\">                        <span class=\"number\">1000</span>,</div><div class=\"line\">                        <span class=\"number\">3</span>));</div><div class=\"line\">        client.start();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Test</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">        InterProcessMutex lock = <span class=\"keyword\">new</span> InterProcessMutex(client, LOCK_PATH);</div><div class=\"line\">        <span class=\"keyword\">boolean</span> acquire = lock.acquire(<span class=\"number\">5</span>, TimeUnit.SECONDS);</div><div class=\"line\">        System.out.println(acquire);</div><div class=\"line\">        System.out.println(<span class=\"string\">\"done\"</span>);</div><div class=\"line\">        lock.release();</div><div class=\"line\">        System.in.read();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"MySQL实现\"><a href=\"#MySQL实现\" class=\"headerlink\" title=\"MySQL实现\"></a>MySQL实现</h3><h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><p><a href=\"http://blog.csdn.net/bolg_hero/article/details/78532920\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/bolg_hero/article/details/78532920</a></p>\n<h3 id=\"ZooKeeper\"><a href=\"#ZooKeeper\" class=\"headerlink\" title=\"ZooKeeper\"></a>ZooKeeper</h3><p> RedLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InterProcessMutexTest</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOCK_PATH = <span class=\"string\">\"/curator-kick-off/lock\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CuratorFramework client;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@BeforeClass</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        client = CuratorFrameworkFactory.newClient(</div><div class=\"line\">                <span class=\"string\">\"127.0.0.1:2181\"</span>,</div><div class=\"line\">                <span class=\"number\">1000</span> * <span class=\"number\">10</span>,</div><div class=\"line\">                <span class=\"number\">3000</span>, <span class=\"keyword\">new</span> ExponentialBackoffRetry(</div><div class=\"line\">                        <span class=\"number\">1000</span>,</div><div class=\"line\">                        <span class=\"number\">3</span>));</div><div class=\"line\">        client.start();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Test</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">        InterProcessMutex lock = <span class=\"keyword\">new</span> InterProcessMutex(client, LOCK_PATH);</div><div class=\"line\">        <span class=\"keyword\">boolean</span> acquire = lock.acquire(<span class=\"number\">5</span>, TimeUnit.SECONDS);</div><div class=\"line\">        System.out.println(acquire);</div><div class=\"line\">        System.out.println(<span class=\"string\">\"done\"</span>);</div><div class=\"line\">        lock.release();</div><div class=\"line\">        System.in.read();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"Distributed-Consensus-Raft","date":"2017-11-15T03:41:21.000Z","_content":"\nhttps://zhuanlan.zhihu.com/p/27910576\nhttp://thesecretlivesofdata.com/raft/\n\n### 不想当将军的兵不是好兵\n\n### 将军永远想独裁\n\n### 为了生存，要隐忍","source":"_posts/Distributed-Consensus-Raft.md","raw":"---\ntitle: Distributed-Consensus-Raft\ndate: 2017-11-15 11:41:21\ntags: Raft\n---\n\nhttps://zhuanlan.zhihu.com/p/27910576\nhttp://thesecretlivesofdata.com/raft/\n\n### 不想当将军的兵不是好兵\n\n### 将军永远想独裁\n\n### 为了生存，要隐忍","slug":"Distributed-Consensus-Raft","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyd000q3iq2b0608ezy","content":"<p><a href=\"https://zhuanlan.zhihu.com/p/27910576\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/p/27910576</a><br><a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"external\">http://thesecretlivesofdata.com/raft/</a></p>\n<h3 id=\"不想当将军的兵不是好兵\"><a href=\"#不想当将军的兵不是好兵\" class=\"headerlink\" title=\"不想当将军的兵不是好兵\"></a>不想当将军的兵不是好兵</h3><h3 id=\"将军永远想独裁\"><a href=\"#将军永远想独裁\" class=\"headerlink\" title=\"将军永远想独裁\"></a>将军永远想独裁</h3><h3 id=\"为了生存，要隐忍\"><a href=\"#为了生存，要隐忍\" class=\"headerlink\" title=\"为了生存，要隐忍\"></a>为了生存，要隐忍</h3>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://zhuanlan.zhihu.com/p/27910576\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/p/27910576</a><br><a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"external\">http://thesecretlivesofdata.com/raft/</a></p>\n<h3 id=\"不想当将军的兵不是好兵\"><a href=\"#不想当将军的兵不是好兵\" class=\"headerlink\" title=\"不想当将军的兵不是好兵\"></a>不想当将军的兵不是好兵</h3><h3 id=\"将军永远想独裁\"><a href=\"#将军永远想独裁\" class=\"headerlink\" title=\"将军永远想独裁\"></a>将军永远想独裁</h3><h3 id=\"为了生存，要隐忍\"><a href=\"#为了生存，要隐忍\" class=\"headerlink\" title=\"为了生存，要隐忍\"></a>为了生存，要隐忍</h3>"},{"title":"Curator-sync-and-mutual-exclusion-between-thread-and-process","date":"2017-10-28T02:46:49.000Z","_content":"\n### Lock\n\n#### read write lock\n\n#### spin lock\n\n#### reentrant lock\n\n### Barrier\n\n### Semaphore\n\n###","source":"_posts/Curator-sync-and-mutual-exclusion-between-thread-and-process.md","raw":"---\ntitle: Curator-sync-and-mutual-exclusion-between-thread-and-process\ndate: 2017-10-28 10:46:49\ntags: Curator\n---\n\n### Lock\n\n#### read write lock\n\n#### spin lock\n\n#### reentrant lock\n\n### Barrier\n\n### Semaphore\n\n###","slug":"Curator-sync-and-mutual-exclusion-between-thread-and-process","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsye000t3iq2wdmff3j6","content":"<h3 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h3><h4 id=\"read-write-lock\"><a href=\"#read-write-lock\" class=\"headerlink\" title=\"read write lock\"></a>read write lock</h4><h4 id=\"spin-lock\"><a href=\"#spin-lock\" class=\"headerlink\" title=\"spin lock\"></a>spin lock</h4><h4 id=\"reentrant-lock\"><a href=\"#reentrant-lock\" class=\"headerlink\" title=\"reentrant lock\"></a>reentrant lock</h4><h3 id=\"Barrier\"><a href=\"#Barrier\" class=\"headerlink\" title=\"Barrier\"></a>Barrier</h3><h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p>###</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h3><h4 id=\"read-write-lock\"><a href=\"#read-write-lock\" class=\"headerlink\" title=\"read write lock\"></a>read write lock</h4><h4 id=\"spin-lock\"><a href=\"#spin-lock\" class=\"headerlink\" title=\"spin lock\"></a>spin lock</h4><h4 id=\"reentrant-lock\"><a href=\"#reentrant-lock\" class=\"headerlink\" title=\"reentrant lock\"></a>reentrant lock</h4><h3 id=\"Barrier\"><a href=\"#Barrier\" class=\"headerlink\" title=\"Barrier\"></a>Barrier</h3><h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p>###</p>\n"},{"title":"Distributed-Transaction-TCC","date":"2017-11-10T11:03:55.000Z","_content":"\n### TCC\n\n### 变种\n\nhttps://github.com/1991wangliang/tx-lcn","source":"_posts/Distributed-Transaction-TCC.md","raw":"---\ntitle: Distributed-Transaction-TCC\ndate: 2017-11-10 19:03:55\ntags: 分布式事务\n---\n\n### TCC\n\n### 变种\n\nhttps://github.com/1991wangliang/tx-lcn","slug":"Distributed-Transaction-TCC","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyf000v3iq2br47vxag","content":"<h3 id=\"TCC\"><a href=\"#TCC\" class=\"headerlink\" title=\"TCC\"></a>TCC</h3><h3 id=\"变种\"><a href=\"#变种\" class=\"headerlink\" title=\"变种\"></a>变种</h3><p><a href=\"https://github.com/1991wangliang/tx-lcn\" target=\"_blank\" rel=\"external\">https://github.com/1991wangliang/tx-lcn</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"TCC\"><a href=\"#TCC\" class=\"headerlink\" title=\"TCC\"></a>TCC</h3><h3 id=\"变种\"><a href=\"#变种\" class=\"headerlink\" title=\"变种\"></a>变种</h3><p><a href=\"https://github.com/1991wangliang/tx-lcn\" target=\"_blank\" rel=\"external\">https://github.com/1991wangliang/tx-lcn</a></p>\n"},{"title":"分布式唯一ID","date":"2017-11-08T06:39:03.000Z","_content":"\n\n``` java\n/**\n * Twitter_Snowflake<br>\n * SnowFlake的结构如下(每部分用-分开):<br>\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0<br>\n * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)\n * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69<br>\n * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId<br>\n * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号<br>\n * 加起来刚好64位，为一个Long型。<br>\n * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。\n */\npublic class SnowflakeIdWorker {\n\n    // ==============================Fields===========================================\n    /** 开始时间截 (2015-01-01) */\n    private final long twepoch = 1420041600000L;\n\n    /** 机器id所占的位数 */\n    private final long workerIdBits = 5L;\n\n    /** 数据标识id所占的位数 */\n    private final long datacenterIdBits = 5L;\n\n    /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */\n    private final long maxWorkerId = -1L ^ (-1L << workerIdBits);\n\n    /** 支持的最大数据标识id，结果是31 */\n    private final long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);\n\n    /** 序列在id中占的位数 */\n    private final long sequenceBits = 12L;\n\n    /** 机器ID向左移12位 */\n    private final long workerIdShift = sequenceBits;\n\n    /** 数据标识id向左移17位(12+5) */\n    private final long datacenterIdShift = sequenceBits + workerIdBits;\n\n    /** 时间截向左移22位(5+5+12) */\n    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;\n\n    /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */\n    private final long sequenceMask = -1L ^ (-1L << sequenceBits);\n\n    /** 工作机器ID(0~31) */\n    private long workerId;\n\n    /** 数据中心ID(0~31) */\n    private long datacenterId;\n\n    /** 毫秒内序列(0~4095) */\n    private long sequence = 0L;\n\n    /** 上次生成ID的时间截 */\n    private long lastTimestamp = -1L;\n\n    //==============================Constructors=====================================\n    /**\n     * 构造函数\n     * @param workerId 工作ID (0~31)\n     * @param datacenterId 数据中心ID (0~31)\n     */\n    public SnowflakeIdWorker(long workerId, long datacenterId) {\n        if (workerId > maxWorkerId || workerId < 0) {\n            throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId));\n        }\n        if (datacenterId > maxDatacenterId || datacenterId < 0) {\n            throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", maxDatacenterId));\n        }\n        this.workerId = workerId;\n        this.datacenterId = datacenterId;\n    }\n\n    // ==============================Methods==========================================\n    /**\n     * 获得下一个ID (该方法是线程安全的)\n     * @return SnowflakeId\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常\n        if (timestamp < lastTimestamp) {\n            throw new RuntimeException(\n                    String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内序列\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) & sequenceMask;\n            //毫秒内序列溢出\n            if (sequence == 0) {\n                //阻塞到下一个毫秒,获得新的时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        }\n        //时间戳改变，毫秒内序列重置\n        else {\n            sequence = 0L;\n        }\n\n        //上次生成ID的时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算拼到一起组成64位的ID\n        return ((timestamp - twepoch) << timestampLeftShift) //\n                | (datacenterId << datacenterIdShift) //\n                | (workerId << workerIdShift) //\n                | sequence;\n    }\n\n    /**\n     * 阻塞到下一个毫秒，直到获得新的时间戳\n     * @param lastTimestamp 上次生成ID的时间截\n     * @return 当前时间戳\n     */\n    protected long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp <= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 返回以毫秒为单位的当前时间\n     * @return 当前时间(毫秒)\n     */\n    protected long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i < 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }\n}\n```\n\n### baidu uid-generator\n\nhttps://github.com/baidu/uid-generator\n\n### 怎么解决由于\n","source":"_posts/Distributed-Unique-id.md","raw":"---\ntitle: 分布式唯一ID\ndate: 2017-11-08 14:39:03\ntags: 分布式设计\n---\n\n\n``` java\n/**\n * Twitter_Snowflake<br>\n * SnowFlake的结构如下(每部分用-分开):<br>\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0<br>\n * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)\n * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69<br>\n * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId<br>\n * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号<br>\n * 加起来刚好64位，为一个Long型。<br>\n * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。\n */\npublic class SnowflakeIdWorker {\n\n    // ==============================Fields===========================================\n    /** 开始时间截 (2015-01-01) */\n    private final long twepoch = 1420041600000L;\n\n    /** 机器id所占的位数 */\n    private final long workerIdBits = 5L;\n\n    /** 数据标识id所占的位数 */\n    private final long datacenterIdBits = 5L;\n\n    /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */\n    private final long maxWorkerId = -1L ^ (-1L << workerIdBits);\n\n    /** 支持的最大数据标识id，结果是31 */\n    private final long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);\n\n    /** 序列在id中占的位数 */\n    private final long sequenceBits = 12L;\n\n    /** 机器ID向左移12位 */\n    private final long workerIdShift = sequenceBits;\n\n    /** 数据标识id向左移17位(12+5) */\n    private final long datacenterIdShift = sequenceBits + workerIdBits;\n\n    /** 时间截向左移22位(5+5+12) */\n    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;\n\n    /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */\n    private final long sequenceMask = -1L ^ (-1L << sequenceBits);\n\n    /** 工作机器ID(0~31) */\n    private long workerId;\n\n    /** 数据中心ID(0~31) */\n    private long datacenterId;\n\n    /** 毫秒内序列(0~4095) */\n    private long sequence = 0L;\n\n    /** 上次生成ID的时间截 */\n    private long lastTimestamp = -1L;\n\n    //==============================Constructors=====================================\n    /**\n     * 构造函数\n     * @param workerId 工作ID (0~31)\n     * @param datacenterId 数据中心ID (0~31)\n     */\n    public SnowflakeIdWorker(long workerId, long datacenterId) {\n        if (workerId > maxWorkerId || workerId < 0) {\n            throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId));\n        }\n        if (datacenterId > maxDatacenterId || datacenterId < 0) {\n            throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", maxDatacenterId));\n        }\n        this.workerId = workerId;\n        this.datacenterId = datacenterId;\n    }\n\n    // ==============================Methods==========================================\n    /**\n     * 获得下一个ID (该方法是线程安全的)\n     * @return SnowflakeId\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常\n        if (timestamp < lastTimestamp) {\n            throw new RuntimeException(\n                    String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内序列\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) & sequenceMask;\n            //毫秒内序列溢出\n            if (sequence == 0) {\n                //阻塞到下一个毫秒,获得新的时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        }\n        //时间戳改变，毫秒内序列重置\n        else {\n            sequence = 0L;\n        }\n\n        //上次生成ID的时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算拼到一起组成64位的ID\n        return ((timestamp - twepoch) << timestampLeftShift) //\n                | (datacenterId << datacenterIdShift) //\n                | (workerId << workerIdShift) //\n                | sequence;\n    }\n\n    /**\n     * 阻塞到下一个毫秒，直到获得新的时间戳\n     * @param lastTimestamp 上次生成ID的时间截\n     * @return 当前时间戳\n     */\n    protected long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp <= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 返回以毫秒为单位的当前时间\n     * @return 当前时间(毫秒)\n     */\n    protected long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i < 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }\n}\n```\n\n### baidu uid-generator\n\nhttps://github.com/baidu/uid-generator\n\n### 怎么解决由于\n","slug":"Distributed-Unique-id","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyg000x3iq2dj9yykcq","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * Twitter_Snowflake&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * SnowFlake的结构如下(每部分用-分开):&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)</span></div><div class=\"line\"><span class=\"comment\"> * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 加起来刚好64位，为一个Long型。&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnowflakeIdWorker</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// ==============================Fields===========================================</span></div><div class=\"line\">    <span class=\"comment\">/** 开始时间截 (2015-01-01) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> twepoch = <span class=\"number\">1420041600000L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 机器id所占的位数 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> workerIdBits = <span class=\"number\">5L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 数据标识id所占的位数 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> datacenterIdBits = <span class=\"number\">5L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxWorkerId = -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; workerIdBits);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 支持的最大数据标识id，结果是31 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxDatacenterId = -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; datacenterIdBits);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 序列在id中占的位数 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> sequenceBits = <span class=\"number\">12L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 机器ID向左移12位 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> workerIdShift = sequenceBits;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 数据标识id向左移17位(12+5) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> datacenterIdShift = sequenceBits + workerIdBits;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 时间截向左移22位(5+5+12) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> sequenceMask = -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; sequenceBits);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 工作机器ID(0~31) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> workerId;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 数据中心ID(0~31) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> datacenterId;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 毫秒内序列(0~4095) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> sequence = <span class=\"number\">0L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 上次生成ID的时间截 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastTimestamp = -<span class=\"number\">1L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//==============================Constructors=====================================</span></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 构造函数</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> workerId 工作ID (0~31)</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> datacenterId 数据中心ID (0~31)</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SnowflakeIdWorker</span><span class=\"params\">(<span class=\"keyword\">long</span> workerId, <span class=\"keyword\">long</span> datacenterId)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(String.format(<span class=\"string\">\"worker Id can't be greater than %d or less than 0\"</span>, maxWorkerId));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(String.format(<span class=\"string\">\"datacenter Id can't be greater than %d or less than 0\"</span>, maxDatacenterId));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">this</span>.workerId = workerId;</div><div class=\"line\">        <span class=\"keyword\">this</span>.datacenterId = datacenterId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// ==============================Methods==========================================</span></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 获得下一个ID (该方法是线程安全的)</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> SnowflakeId</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">long</span> <span class=\"title\">nextId</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> timestamp = timeGen();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (timestamp &lt; lastTimestamp) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                    String.format(<span class=\"string\">\"Clock moved backwards.  Refusing to generate id for %d milliseconds\"</span>, lastTimestamp - timestamp));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//如果是同一时间生成的，则进行毫秒内序列</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (lastTimestamp == timestamp) &#123;</div><div class=\"line\">            sequence = (sequence + <span class=\"number\">1</span>) &amp; sequenceMask;</div><div class=\"line\">            <span class=\"comment\">//毫秒内序列溢出</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (sequence == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">//阻塞到下一个毫秒,获得新的时间戳</span></div><div class=\"line\">                timestamp = tilNextMillis(lastTimestamp);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//时间戳改变，毫秒内序列重置</span></div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            sequence = <span class=\"number\">0L</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//上次生成ID的时间截</span></div><div class=\"line\">        lastTimestamp = timestamp;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//移位并通过或运算拼到一起组成64位的ID</span></div><div class=\"line\">        <span class=\"keyword\">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class=\"comment\">//</span></div><div class=\"line\">                | (datacenterId &lt;&lt; datacenterIdShift) <span class=\"comment\">//</span></div><div class=\"line\">                | (workerId &lt;&lt; workerIdShift) <span class=\"comment\">//</span></div><div class=\"line\">                | sequence;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lastTimestamp 上次生成ID的时间截</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 当前时间戳</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">long</span> <span class=\"title\">tilNextMillis</span><span class=\"params\">(<span class=\"keyword\">long</span> lastTimestamp)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> timestamp = timeGen();</div><div class=\"line\">        <span class=\"keyword\">while</span> (timestamp &lt;= lastTimestamp) &#123;</div><div class=\"line\">            timestamp = timeGen();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> timestamp;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 返回以毫秒为单位的当前时间</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 当前时间(毫秒)</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">long</span> <span class=\"title\">timeGen</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> System.currentTimeMillis();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//==============================Test=============================================</span></div><div class=\"line\">    <span class=\"comment\">/** 测试 */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        SnowflakeIdWorker idWorker = <span class=\"keyword\">new</span> SnowflakeIdWorker(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">long</span> id = idWorker.nextId();</div><div class=\"line\">            System.out.println(Long.toBinaryString(id));</div><div class=\"line\">            System.out.println(id);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"baidu-uid-generator\"><a href=\"#baidu-uid-generator\" class=\"headerlink\" title=\"baidu uid-generator\"></a>baidu uid-generator</h3><p><a href=\"https://github.com/baidu/uid-generator\" target=\"_blank\" rel=\"external\">https://github.com/baidu/uid-generator</a></p>\n<h3 id=\"怎么解决由于\"><a href=\"#怎么解决由于\" class=\"headerlink\" title=\"怎么解决由于\"></a>怎么解决由于</h3>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * Twitter_Snowflake&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * SnowFlake的结构如下(每部分用-分开):&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)</span></div><div class=\"line\"><span class=\"comment\"> * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * 加起来刚好64位，为一个Long型。&lt;br&gt;</span></div><div class=\"line\"><span class=\"comment\"> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnowflakeIdWorker</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// ==============================Fields===========================================</span></div><div class=\"line\">    <span class=\"comment\">/** 开始时间截 (2015-01-01) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> twepoch = <span class=\"number\">1420041600000L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 机器id所占的位数 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> workerIdBits = <span class=\"number\">5L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 数据标识id所占的位数 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> datacenterIdBits = <span class=\"number\">5L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxWorkerId = -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; workerIdBits);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 支持的最大数据标识id，结果是31 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxDatacenterId = -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; datacenterIdBits);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 序列在id中占的位数 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> sequenceBits = <span class=\"number\">12L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 机器ID向左移12位 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> workerIdShift = sequenceBits;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 数据标识id向左移17位(12+5) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> datacenterIdShift = sequenceBits + workerIdBits;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 时间截向左移22位(5+5+12) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> sequenceMask = -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; sequenceBits);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 工作机器ID(0~31) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> workerId;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 数据中心ID(0~31) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> datacenterId;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 毫秒内序列(0~4095) */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> sequence = <span class=\"number\">0L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 上次生成ID的时间截 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastTimestamp = -<span class=\"number\">1L</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//==============================Constructors=====================================</span></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 构造函数</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> workerId 工作ID (0~31)</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> datacenterId 数据中心ID (0~31)</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SnowflakeIdWorker</span><span class=\"params\">(<span class=\"keyword\">long</span> workerId, <span class=\"keyword\">long</span> datacenterId)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(String.format(<span class=\"string\">\"worker Id can't be greater than %d or less than 0\"</span>, maxWorkerId));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(String.format(<span class=\"string\">\"datacenter Id can't be greater than %d or less than 0\"</span>, maxDatacenterId));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">this</span>.workerId = workerId;</div><div class=\"line\">        <span class=\"keyword\">this</span>.datacenterId = datacenterId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// ==============================Methods==========================================</span></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 获得下一个ID (该方法是线程安全的)</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> SnowflakeId</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">long</span> <span class=\"title\">nextId</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> timestamp = timeGen();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (timestamp &lt; lastTimestamp) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                    String.format(<span class=\"string\">\"Clock moved backwards.  Refusing to generate id for %d milliseconds\"</span>, lastTimestamp - timestamp));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//如果是同一时间生成的，则进行毫秒内序列</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (lastTimestamp == timestamp) &#123;</div><div class=\"line\">            sequence = (sequence + <span class=\"number\">1</span>) &amp; sequenceMask;</div><div class=\"line\">            <span class=\"comment\">//毫秒内序列溢出</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (sequence == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">//阻塞到下一个毫秒,获得新的时间戳</span></div><div class=\"line\">                timestamp = tilNextMillis(lastTimestamp);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//时间戳改变，毫秒内序列重置</span></div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            sequence = <span class=\"number\">0L</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//上次生成ID的时间截</span></div><div class=\"line\">        lastTimestamp = timestamp;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//移位并通过或运算拼到一起组成64位的ID</span></div><div class=\"line\">        <span class=\"keyword\">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class=\"comment\">//</span></div><div class=\"line\">                | (datacenterId &lt;&lt; datacenterIdShift) <span class=\"comment\">//</span></div><div class=\"line\">                | (workerId &lt;&lt; workerIdShift) <span class=\"comment\">//</span></div><div class=\"line\">                | sequence;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lastTimestamp 上次生成ID的时间截</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 当前时间戳</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">long</span> <span class=\"title\">tilNextMillis</span><span class=\"params\">(<span class=\"keyword\">long</span> lastTimestamp)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> timestamp = timeGen();</div><div class=\"line\">        <span class=\"keyword\">while</span> (timestamp &lt;= lastTimestamp) &#123;</div><div class=\"line\">            timestamp = timeGen();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> timestamp;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 返回以毫秒为单位的当前时间</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 当前时间(毫秒)</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">long</span> <span class=\"title\">timeGen</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> System.currentTimeMillis();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//==============================Test=============================================</span></div><div class=\"line\">    <span class=\"comment\">/** 测试 */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        SnowflakeIdWorker idWorker = <span class=\"keyword\">new</span> SnowflakeIdWorker(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">long</span> id = idWorker.nextId();</div><div class=\"line\">            System.out.println(Long.toBinaryString(id));</div><div class=\"line\">            System.out.println(id);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"baidu-uid-generator\"><a href=\"#baidu-uid-generator\" class=\"headerlink\" title=\"baidu uid-generator\"></a>baidu uid-generator</h3><p><a href=\"https://github.com/baidu/uid-generator\" target=\"_blank\" rel=\"external\">https://github.com/baidu/uid-generator</a></p>\n<h3 id=\"怎么解决由于\"><a href=\"#怎么解决由于\" class=\"headerlink\" title=\"怎么解决由于\"></a>怎么解决由于</h3>"},{"title":"Distributed-Transaction","date":"2017-11-03T02:54:48.000Z","_content":"\n### TCC\n\n### RocketMQ事务功能\n![你想输入的替代文字](Distributed-Transaction/transaction_rocketmq.gif)\n\n### 抽象出一个完整的系统\n不是所有的MQ系统都是支持这个HalfMsg的操作的，所以我们把这个系统抽成一个事务SOA服务\n\nhttps://mp.weixin.qq.com/s?__biz=MzU4MTEyODIzMg==&mid=2247483713&idx=1&sn=c9efdd6eda9d7bd32f82e42b2ca3fbe3&chksm=fd4d1806ca3a9110474f9c0b1d2a886a9f994c4b8ed8d354a3c6bd8d8373cd012646443ebfca&mpshare=1&scene=1&srcid=1110kSXANwBrbL2TWtA0NAK6&key=86d1b0bfcae3874289b26357e30923b1734881e3a43437f4558c9c6be8f133e62f000fc4c315915ad48066faca9893f45a6515e6faebf3f27b85a03bf975ca15ecd8401181121b82a5d41040f7b5c565&ascene=0&uin=MjcyMjMxNTA0Mg%3D%3D&devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.12+build(16A323)&version=12010210&nettype=WIFI&fontScale=100&pass_ticket=T2oTN5azeGV4Brh%2FOFJxtVGb2WVp1QN3ylyWucAGYWTJBOrOLdFJzJoRIwToLTv8\n\n### Spring Cloud\nhttp://www.jianshu.com/p/cf3a2884a8d2?open_source=weibo_search\nhttps://www.atomikos.com/Blog/TransactionManagementAPIForRESTTCC\n\n\nhttps://github.com/beston123/Tarzan","source":"_posts/Distributed-Transaction.md","raw":"---\ntitle: Distributed-Transaction\ndate: 2017-11-03 10:54:48\ntags: 分布式事务\n---\n\n### TCC\n\n### RocketMQ事务功能\n![你想输入的替代文字](Distributed-Transaction/transaction_rocketmq.gif)\n\n### 抽象出一个完整的系统\n不是所有的MQ系统都是支持这个HalfMsg的操作的，所以我们把这个系统抽成一个事务SOA服务\n\nhttps://mp.weixin.qq.com/s?__biz=MzU4MTEyODIzMg==&mid=2247483713&idx=1&sn=c9efdd6eda9d7bd32f82e42b2ca3fbe3&chksm=fd4d1806ca3a9110474f9c0b1d2a886a9f994c4b8ed8d354a3c6bd8d8373cd012646443ebfca&mpshare=1&scene=1&srcid=1110kSXANwBrbL2TWtA0NAK6&key=86d1b0bfcae3874289b26357e30923b1734881e3a43437f4558c9c6be8f133e62f000fc4c315915ad48066faca9893f45a6515e6faebf3f27b85a03bf975ca15ecd8401181121b82a5d41040f7b5c565&ascene=0&uin=MjcyMjMxNTA0Mg%3D%3D&devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.12+build(16A323)&version=12010210&nettype=WIFI&fontScale=100&pass_ticket=T2oTN5azeGV4Brh%2FOFJxtVGb2WVp1QN3ylyWucAGYWTJBOrOLdFJzJoRIwToLTv8\n\n### Spring Cloud\nhttp://www.jianshu.com/p/cf3a2884a8d2?open_source=weibo_search\nhttps://www.atomikos.com/Blog/TransactionManagementAPIForRESTTCC\n\n\nhttps://github.com/beston123/Tarzan","slug":"Distributed-Transaction","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyp00103iq2ucqi5ypu","content":"<h3 id=\"TCC\"><a href=\"#TCC\" class=\"headerlink\" title=\"TCC\"></a>TCC</h3><h3 id=\"RocketMQ事务功能\"><a href=\"#RocketMQ事务功能\" class=\"headerlink\" title=\"RocketMQ事务功能\"></a>RocketMQ事务功能</h3><p><img src=\"/2017/11/03/Distributed-Transaction/transaction_rocketmq.gif\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"抽象出一个完整的系统\"><a href=\"#抽象出一个完整的系统\" class=\"headerlink\" title=\"抽象出一个完整的系统\"></a>抽象出一个完整的系统</h3><p>不是所有的MQ系统都是支持这个HalfMsg的操作的，所以我们把这个系统抽成一个事务SOA服务</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU4MTEyODIzMg==&amp;mid=2247483713&amp;idx=1&amp;sn=c9efdd6eda9d7bd32f82e42b2ca3fbe3&amp;chksm=fd4d1806ca3a9110474f9c0b1d2a886a9f994c4b8ed8d354a3c6bd8d8373cd012646443ebfca&amp;mpshare=1&amp;scene=1&amp;srcid=1110kSXANwBrbL2TWtA0NAK6&amp;key=86d1b0bfcae3874289b26357e30923b1734881e3a43437f4558c9c6be8f133e62f000fc4c315915ad48066faca9893f45a6515e6faebf3f27b85a03bf975ca15ecd8401181121b82a5d41040f7b5c565&amp;ascene=0&amp;uin=MjcyMjMxNTA0Mg%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.12+build(16A323)&amp;version=12010210&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=T2oTN5azeGV4Brh%2FOFJxtVGb2WVp1QN3ylyWucAGYWTJBOrOLdFJzJoRIwToLTv8\" target=\"_blank\" rel=\"external\">https://mp.weixin.qq.com/s?__biz=MzU4MTEyODIzMg==&amp;mid=2247483713&amp;idx=1&amp;sn=c9efdd6eda9d7bd32f82e42b2ca3fbe3&amp;chksm=fd4d1806ca3a9110474f9c0b1d2a886a9f994c4b8ed8d354a3c6bd8d8373cd012646443ebfca&amp;mpshare=1&amp;scene=1&amp;srcid=1110kSXANwBrbL2TWtA0NAK6&amp;key=86d1b0bfcae3874289b26357e30923b1734881e3a43437f4558c9c6be8f133e62f000fc4c315915ad48066faca9893f45a6515e6faebf3f27b85a03bf975ca15ecd8401181121b82a5d41040f7b5c565&amp;ascene=0&amp;uin=MjcyMjMxNTA0Mg%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.12+build(16A323)&amp;version=12010210&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=T2oTN5azeGV4Brh%2FOFJxtVGb2WVp1QN3ylyWucAGYWTJBOrOLdFJzJoRIwToLTv8</a></p>\n<h3 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h3><p><a href=\"http://www.jianshu.com/p/cf3a2884a8d2?open_source=weibo_search\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/cf3a2884a8d2?open_source=weibo_search</a><br><a href=\"https://www.atomikos.com/Blog/TransactionManagementAPIForRESTTCC\" target=\"_blank\" rel=\"external\">https://www.atomikos.com/Blog/TransactionManagementAPIForRESTTCC</a></p>\n<p><a href=\"https://github.com/beston123/Tarzan\" target=\"_blank\" rel=\"external\">https://github.com/beston123/Tarzan</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"TCC\"><a href=\"#TCC\" class=\"headerlink\" title=\"TCC\"></a>TCC</h3><h3 id=\"RocketMQ事务功能\"><a href=\"#RocketMQ事务功能\" class=\"headerlink\" title=\"RocketMQ事务功能\"></a>RocketMQ事务功能</h3><p><img src=\"/2017/11/03/Distributed-Transaction/transaction_rocketmq.gif\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"抽象出一个完整的系统\"><a href=\"#抽象出一个完整的系统\" class=\"headerlink\" title=\"抽象出一个完整的系统\"></a>抽象出一个完整的系统</h3><p>不是所有的MQ系统都是支持这个HalfMsg的操作的，所以我们把这个系统抽成一个事务SOA服务</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU4MTEyODIzMg==&amp;mid=2247483713&amp;idx=1&amp;sn=c9efdd6eda9d7bd32f82e42b2ca3fbe3&amp;chksm=fd4d1806ca3a9110474f9c0b1d2a886a9f994c4b8ed8d354a3c6bd8d8373cd012646443ebfca&amp;mpshare=1&amp;scene=1&amp;srcid=1110kSXANwBrbL2TWtA0NAK6&amp;key=86d1b0bfcae3874289b26357e30923b1734881e3a43437f4558c9c6be8f133e62f000fc4c315915ad48066faca9893f45a6515e6faebf3f27b85a03bf975ca15ecd8401181121b82a5d41040f7b5c565&amp;ascene=0&amp;uin=MjcyMjMxNTA0Mg%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.12+build(16A323)&amp;version=12010210&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=T2oTN5azeGV4Brh%2FOFJxtVGb2WVp1QN3ylyWucAGYWTJBOrOLdFJzJoRIwToLTv8\" target=\"_blank\" rel=\"external\">https://mp.weixin.qq.com/s?__biz=MzU4MTEyODIzMg==&amp;mid=2247483713&amp;idx=1&amp;sn=c9efdd6eda9d7bd32f82e42b2ca3fbe3&amp;chksm=fd4d1806ca3a9110474f9c0b1d2a886a9f994c4b8ed8d354a3c6bd8d8373cd012646443ebfca&amp;mpshare=1&amp;scene=1&amp;srcid=1110kSXANwBrbL2TWtA0NAK6&amp;key=86d1b0bfcae3874289b26357e30923b1734881e3a43437f4558c9c6be8f133e62f000fc4c315915ad48066faca9893f45a6515e6faebf3f27b85a03bf975ca15ecd8401181121b82a5d41040f7b5c565&amp;ascene=0&amp;uin=MjcyMjMxNTA0Mg%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.12+build(16A323)&amp;version=12010210&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=T2oTN5azeGV4Brh%2FOFJxtVGb2WVp1QN3ylyWucAGYWTJBOrOLdFJzJoRIwToLTv8</a></p>\n<h3 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h3><p><a href=\"http://www.jianshu.com/p/cf3a2884a8d2?open_source=weibo_search\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/cf3a2884a8d2?open_source=weibo_search</a><br><a href=\"https://www.atomikos.com/Blog/TransactionManagementAPIForRESTTCC\" target=\"_blank\" rel=\"external\">https://www.atomikos.com/Blog/TransactionManagementAPIForRESTTCC</a></p>\n<p><a href=\"https://github.com/beston123/Tarzan\" target=\"_blank\" rel=\"external\">https://github.com/beston123/Tarzan</a></p>\n"},{"title":"guava中的黑科技","date":"2017-09-19T09:39:05.000Z","_content":"\n### 限流\n\nhttp://www.itwendao.com/article/detail/357611.html\n\n### 缓存\n\n### 集合\n\n#### BiMap\n\n### 反射\n\n### 并发","source":"_posts/Guava-Black-techs.md","raw":"---\ntitle: guava中的黑科技\ndate: 2017-09-19 17:39:05\ntags: Guava\n---\n\n### 限流\n\nhttp://www.itwendao.com/article/detail/357611.html\n\n### 缓存\n\n### 集合\n\n#### BiMap\n\n### 反射\n\n### 并发","slug":"Guava-Black-techs","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyq00113iq2fhmdjdlq","content":"<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p><a href=\"http://www.itwendao.com/article/detail/357611.html\" target=\"_blank\" rel=\"external\">http://www.itwendao.com/article/detail/357611.html</a></p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><h4 id=\"BiMap\"><a href=\"#BiMap\" class=\"headerlink\" title=\"BiMap\"></a>BiMap</h4><h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><p><a href=\"http://www.itwendao.com/article/detail/357611.html\" target=\"_blank\" rel=\"external\">http://www.itwendao.com/article/detail/357611.html</a></p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><h4 id=\"BiMap\"><a href=\"#BiMap\" class=\"headerlink\" title=\"BiMap\"></a>BiMap</h4><h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h3>"},{"title":"JVM-Atomic-operation","date":"2017-11-09T02:12:31.000Z","_content":"\n### Volatile关键词\n\nvolatile的实现原理\n\n1.可见性\n\n处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。\n\n如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。\n\n但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。\n\n2.有序性\n\nLock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。\n\n作者：Ruheng\n链接：http://www.jianshu.com/p/7798161d7472\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n#### 主内存与线程工作内存\n\n### MVCC Copy on write\n\nCopyOnWriteArrayList 实现细节\n\n``` java\npublic class CopyOnWriteArrayList<E> {\n    /** The lock protecting all mutators */\n    final transient ReentrantLock lock = new ReentrantLock();\n\n    /** The array, accessed only via getArray/setArray. */\n    private transient volatile Object[] array;\n\n    /**\n     * Gets the array.  Non-private so as to also be accessible\n     * from CopyOnWriteArraySet class.\n     */\n    final Object[] getArray() {\n        return array;\n    }\n\n    /**\n     * Sets the array.\n     */\n    final void setArray(Object[] a) {\n        array = a;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E get(int index) {\n        return get(getArray(), index);\n    }\n\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their\n     * indices).  Returns the element that was removed from the list.\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            E oldValue = get(elements, index);\n            int numMoved = len - index - 1;\n            if (numMoved == 0)\n                setArray(Arrays.copyOf(elements, len - 1));\n            else {\n                Object[] newElements = new Object[len - 1];\n                System.arraycopy(elements, 0, newElements, 0, index);\n                System.arraycopy(elements, index + 1, newElements, index,\n                                 numMoved);\n                setArray(newElements);\n            }\n            return oldValue;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n   \n}\n```\n\n可以看到，对CopyOnWriteArrayList的「写」操作，代码中都是有加互斥锁——ReentrantLock的，而对于「读」操作，没有任何锁机制。所以也就决定了CopyOnWriteArrayList一般在有大量并发读，少量并发写的场景下使用。\n\n> 参考：http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html\n\n七、volatile的应用场景\n\nsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n\n1）对变量的写操作不依赖于当前值\n\n2）该变量没有包含在具有其他变量的不变式中\n\n下面列举几个Java中使用volatile的几个场景。\n\n①.状态标记量\n\n``` java\nvolatile boolean flag = false;\n //线程1\nwhile(!flag){\n    doSomething();\n}\n  //线程2\npublic void setFlag() {\n    flag = true;\n}\n```\n\n根据状态标记，终止线程。\n\n②.单例模式中的double check\n\n``` java\nclass Singleton{\n    private volatile static Singleton instance = null;\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n\n为什么要使用volatile 修饰instance？\n\n主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:\n\n1.给 instance 分配内存\n\n2.调用 Singleton 的构造函数来初始化成员变量\n\n3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。\n\n但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。\n\n作者：Ruheng\n链接：http://www.jianshu.com/p/7798161d7472\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","source":"_posts/JVM-Atomic-operation.md","raw":"---\ntitle: JVM-Atomic-operation\ndate: 2017-11-09 10:12:31\ntags: JVM\n---\n\n### Volatile关键词\n\nvolatile的实现原理\n\n1.可见性\n\n处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。\n\n如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。\n\n但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。\n\n2.有序性\n\nLock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。\n\n作者：Ruheng\n链接：http://www.jianshu.com/p/7798161d7472\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n#### 主内存与线程工作内存\n\n### MVCC Copy on write\n\nCopyOnWriteArrayList 实现细节\n\n``` java\npublic class CopyOnWriteArrayList<E> {\n    /** The lock protecting all mutators */\n    final transient ReentrantLock lock = new ReentrantLock();\n\n    /** The array, accessed only via getArray/setArray. */\n    private transient volatile Object[] array;\n\n    /**\n     * Gets the array.  Non-private so as to also be accessible\n     * from CopyOnWriteArraySet class.\n     */\n    final Object[] getArray() {\n        return array;\n    }\n\n    /**\n     * Sets the array.\n     */\n    final void setArray(Object[] a) {\n        array = a;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E get(int index) {\n        return get(getArray(), index);\n    }\n\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their\n     * indices).  Returns the element that was removed from the list.\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            E oldValue = get(elements, index);\n            int numMoved = len - index - 1;\n            if (numMoved == 0)\n                setArray(Arrays.copyOf(elements, len - 1));\n            else {\n                Object[] newElements = new Object[len - 1];\n                System.arraycopy(elements, 0, newElements, 0, index);\n                System.arraycopy(elements, index + 1, newElements, index,\n                                 numMoved);\n                setArray(newElements);\n            }\n            return oldValue;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n   \n}\n```\n\n可以看到，对CopyOnWriteArrayList的「写」操作，代码中都是有加互斥锁——ReentrantLock的，而对于「读」操作，没有任何锁机制。所以也就决定了CopyOnWriteArrayList一般在有大量并发读，少量并发写的场景下使用。\n\n> 参考：http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html\n\n七、volatile的应用场景\n\nsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n\n1）对变量的写操作不依赖于当前值\n\n2）该变量没有包含在具有其他变量的不变式中\n\n下面列举几个Java中使用volatile的几个场景。\n\n①.状态标记量\n\n``` java\nvolatile boolean flag = false;\n //线程1\nwhile(!flag){\n    doSomething();\n}\n  //线程2\npublic void setFlag() {\n    flag = true;\n}\n```\n\n根据状态标记，终止线程。\n\n②.单例模式中的double check\n\n``` java\nclass Singleton{\n    private volatile static Singleton instance = null;\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n\n为什么要使用volatile 修饰instance？\n\n主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:\n\n1.给 instance 分配内存\n\n2.调用 Singleton 的构造函数来初始化成员变量\n\n3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。\n\n但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。\n\n作者：Ruheng\n链接：http://www.jianshu.com/p/7798161d7472\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","slug":"JVM-Atomic-operation","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyr00133iq28ruqmiy5","content":"<h3 id=\"Volatile关键词\"><a href=\"#Volatile关键词\" class=\"headerlink\" title=\"Volatile关键词\"></a>Volatile关键词</h3><p>volatile的实现原理</p>\n<p>1.可见性</p>\n<p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p>\n<p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p>\n<p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p>\n<p>2.有序性</p>\n<p>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p>\n<p>作者：Ruheng<br>链接：<a href=\"http://www.jianshu.com/p/7798161d7472\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/7798161d7472</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h4 id=\"主内存与线程工作内存\"><a href=\"#主内存与线程工作内存\" class=\"headerlink\" title=\"主内存与线程工作内存\"></a>主内存与线程工作内存</h4><h3 id=\"MVCC-Copy-on-write\"><a href=\"#MVCC-Copy-on-write\" class=\"headerlink\" title=\"MVCC Copy on write\"></a>MVCC Copy on write</h3><p>CopyOnWriteArrayList 实现细节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CopyOnWriteArrayList</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/** The lock protecting all mutators */</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** The array, accessed only via getArray/setArray. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Object[] array;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * Gets the array.  Non-private so as to also be accessible</span></div><div class=\"line\"><span class=\"comment\">     * from CopyOnWriteArraySet class.</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Object[] getArray() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> array;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * Sets the array.</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setArray</span><span class=\"params\">(Object[] a)</span> </span>&#123;</div><div class=\"line\">        array = a;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</span></div><div class=\"line\"><span class=\"comment\">     *</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IndexOutOfBoundsException &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> get(getArray(), index);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * Appends the specified element to the end of this list.</span></div><div class=\"line\"><span class=\"comment\">     *</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e element to be appended to this list</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; (as specified by &#123;<span class=\"doctag\">@link</span> Collection#add&#125;)</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</div><div class=\"line\">        lock.lock();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Object[] elements = getArray();</div><div class=\"line\">            <span class=\"keyword\">int</span> len = elements.length;</div><div class=\"line\">            Object[] newElements = Arrays.copyOf(elements, len + <span class=\"number\">1</span>);</div><div class=\"line\">            newElements[len] = e;</div><div class=\"line\">            setArray(newElements);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            lock.unlock();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * Removes the element at the specified position in this list.</span></div><div class=\"line\"><span class=\"comment\">     * Shifts any subsequent elements to the left (subtracts one from their</span></div><div class=\"line\"><span class=\"comment\">     * indices).  Returns the element that was removed from the list.</span></div><div class=\"line\"><span class=\"comment\">     *</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IndexOutOfBoundsException &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</div><div class=\"line\">        lock.lock();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Object[] elements = getArray();</div><div class=\"line\">            <span class=\"keyword\">int</span> len = elements.length;</div><div class=\"line\">            E oldValue = get(elements, index);</div><div class=\"line\">            <span class=\"keyword\">int</span> numMoved = len - index - <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (numMoved == <span class=\"number\">0</span>)</div><div class=\"line\">                setArray(Arrays.copyOf(elements, len - <span class=\"number\">1</span>));</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                Object[] newElements = <span class=\"keyword\">new</span> Object[len - <span class=\"number\">1</span>];</div><div class=\"line\">                System.arraycopy(elements, <span class=\"number\">0</span>, newElements, <span class=\"number\">0</span>, index);</div><div class=\"line\">                System.arraycopy(elements, index + <span class=\"number\">1</span>, newElements, index,</div><div class=\"line\">                                 numMoved);</div><div class=\"line\">                setArray(newElements);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            lock.unlock();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，对CopyOnWriteArrayList的「写」操作，代码中都是有加互斥锁——ReentrantLock的，而对于「读」操作，没有任何锁机制。所以也就决定了CopyOnWriteArrayList一般在有大量并发读，少量并发写的场景下使用。</p>\n<blockquote>\n<p>参考：<a href=\"http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</a></p>\n</blockquote>\n<p>七、volatile的应用场景</p>\n<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>\n<p>1）对变量的写操作不依赖于当前值</p>\n<p>2）该变量没有包含在具有其他变量的不变式中</p>\n<p>下面列举几个Java中使用volatile的几个场景。</p>\n<p>①.状态标记量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"comment\">//线程1</span></div><div class=\"line\"><span class=\"keyword\">while</span>(!flag)&#123;</div><div class=\"line\">    doSomething();</div><div class=\"line\">&#125;</div><div class=\"line\">  <span class=\"comment\">//线程2</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFlag</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    flag = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据状态标记，终止线程。</p>\n<p>②.单例模式中的double check</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)</div><div class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为什么要使用volatile 修饰instance？</p>\n<p>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:</p>\n<p>1.给 instance 分配内存</p>\n<p>2.调用 Singleton 的构造函数来初始化成员变量</p>\n<p>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。</p>\n<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>\n<p>作者：Ruheng<br>链接：<a href=\"http://www.jianshu.com/p/7798161d7472\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/7798161d7472</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Volatile关键词\"><a href=\"#Volatile关键词\" class=\"headerlink\" title=\"Volatile关键词\"></a>Volatile关键词</h3><p>volatile的实现原理</p>\n<p>1.可见性</p>\n<p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p>\n<p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p>\n<p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p>\n<p>2.有序性</p>\n<p>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p>\n<p>作者：Ruheng<br>链接：<a href=\"http://www.jianshu.com/p/7798161d7472\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/7798161d7472</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h4 id=\"主内存与线程工作内存\"><a href=\"#主内存与线程工作内存\" class=\"headerlink\" title=\"主内存与线程工作内存\"></a>主内存与线程工作内存</h4><h3 id=\"MVCC-Copy-on-write\"><a href=\"#MVCC-Copy-on-write\" class=\"headerlink\" title=\"MVCC Copy on write\"></a>MVCC Copy on write</h3><p>CopyOnWriteArrayList 实现细节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CopyOnWriteArrayList</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/** The lock protecting all mutators */</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** The array, accessed only via getArray/setArray. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Object[] array;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * Gets the array.  Non-private so as to also be accessible</span></div><div class=\"line\"><span class=\"comment\">     * from CopyOnWriteArraySet class.</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Object[] getArray() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> array;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * Sets the array.</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setArray</span><span class=\"params\">(Object[] a)</span> </span>&#123;</div><div class=\"line\">        array = a;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</span></div><div class=\"line\"><span class=\"comment\">     *</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IndexOutOfBoundsException &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> get(getArray(), index);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * Appends the specified element to the end of this list.</span></div><div class=\"line\"><span class=\"comment\">     *</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e element to be appended to this list</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; (as specified by &#123;<span class=\"doctag\">@link</span> Collection#add&#125;)</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</div><div class=\"line\">        lock.lock();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Object[] elements = getArray();</div><div class=\"line\">            <span class=\"keyword\">int</span> len = elements.length;</div><div class=\"line\">            Object[] newElements = Arrays.copyOf(elements, len + <span class=\"number\">1</span>);</div><div class=\"line\">            newElements[len] = e;</div><div class=\"line\">            setArray(newElements);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            lock.unlock();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * Removes the element at the specified position in this list.</span></div><div class=\"line\"><span class=\"comment\">     * Shifts any subsequent elements to the left (subtracts one from their</span></div><div class=\"line\"><span class=\"comment\">     * indices).  Returns the element that was removed from the list.</span></div><div class=\"line\"><span class=\"comment\">     *</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IndexOutOfBoundsException &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</div><div class=\"line\">        lock.lock();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Object[] elements = getArray();</div><div class=\"line\">            <span class=\"keyword\">int</span> len = elements.length;</div><div class=\"line\">            E oldValue = get(elements, index);</div><div class=\"line\">            <span class=\"keyword\">int</span> numMoved = len - index - <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (numMoved == <span class=\"number\">0</span>)</div><div class=\"line\">                setArray(Arrays.copyOf(elements, len - <span class=\"number\">1</span>));</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                Object[] newElements = <span class=\"keyword\">new</span> Object[len - <span class=\"number\">1</span>];</div><div class=\"line\">                System.arraycopy(elements, <span class=\"number\">0</span>, newElements, <span class=\"number\">0</span>, index);</div><div class=\"line\">                System.arraycopy(elements, index + <span class=\"number\">1</span>, newElements, index,</div><div class=\"line\">                                 numMoved);</div><div class=\"line\">                setArray(newElements);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            lock.unlock();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，对CopyOnWriteArrayList的「写」操作，代码中都是有加互斥锁——ReentrantLock的，而对于「读」操作，没有任何锁机制。所以也就决定了CopyOnWriteArrayList一般在有大量并发读，少量并发写的场景下使用。</p>\n<blockquote>\n<p>参考：<a href=\"http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</a></p>\n</blockquote>\n<p>七、volatile的应用场景</p>\n<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>\n<p>1）对变量的写操作不依赖于当前值</p>\n<p>2）该变量没有包含在具有其他变量的不变式中</p>\n<p>下面列举几个Java中使用volatile的几个场景。</p>\n<p>①.状态标记量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"comment\">//线程1</span></div><div class=\"line\"><span class=\"keyword\">while</span>(!flag)&#123;</div><div class=\"line\">    doSomething();</div><div class=\"line\">&#125;</div><div class=\"line\">  <span class=\"comment\">//线程2</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFlag</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    flag = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据状态标记，终止线程。</p>\n<p>②.单例模式中的double check</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)</div><div class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为什么要使用volatile 修饰instance？</p>\n<p>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:</p>\n<p>1.给 instance 分配内存</p>\n<p>2.调用 Singleton 的构造函数来初始化成员变量</p>\n<p>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。</p>\n<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>\n<p>作者：Ruheng<br>链接：<a href=\"http://www.jianshu.com/p/7798161d7472\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/7798161d7472</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n"},{"title":"Interview-Questions","date":"2017-11-20T07:38:08.000Z","_content":"\n\n### 如果让你设计一个异步调用的服务，你会注意些什么？\n\n异步结果（Future & Promise）设计\n异步没有被调用者的反馈（Feed Back），如果没有限流，将会被调用垮掉\n\n作者：Leo Yang\n链接：https://www.zhihu.com/question/60949531/answer/184044541\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n从阿里的常规java技术面试角度说一说，一般都是由浅到深去问，思路是先考察基础是否过关，再通过深度考察是否有技术热情和深度，同时可能会通过提出一些质疑和挑战来考察候选人是如何与不同意见进行沟通考察内容和方式基础知识：考察基础的时候一般都不会太深入地去问，主要目的是考察知识面，如果发现候选人很多都不知道可能就不会继续进入下一步的考察。\nJDK 集合、BIO/NIO、annotation 等虚拟机 内存模型、类加载原理数据库 索引、事务、死锁 等并发 并发优缺点、内存可见性（volatile）、锁、同步、线程池框架网络 TCP/HTTP 常见设计模式深入考察：深入考察的时候不会像考察基础一样面面俱到，而是会在某个点上深入去聊，这个点的选择可能是让候选人自己选一个点，也可能是面试官根据简历内容去选，主要目的是考察候选人对某个技术点的深入掌握程度，技术是相通的，如果一个人能在某个技术点上达到很深入的程度，其他点上通常也不会有太大问题；相反如果某个人在他声称很了解的点上都支支吾吾、一知半解多半可以判断此人要么技术能力有限、要么遇到问题不愿深入考察、浅尝辄止。\nJDK ConcurrentHashMap如何提高并发度、NIO的原理（零拷贝、堆外内存），优缺点虚拟机 包冲突，类冲突的形成原理及解决办法（可能会引申JDK9的模块化设计）、TCCL的存在价值分布式 一致性哈希、RPC原理和设计（通信协议、序列化方式、超时机制等）、负载均衡、分布式缓存架构设计、分布式消息、分布式事务、paxos（这个可能只有在技术专业型很强的职位上会去问）数据库 数据库性能优化（慢sql、索引优化、大事务、内核参数调优），也可能会把一些工作中碰到的诡异场景抛出来问并发 非阻塞锁（CAS)、并发对编译器优化的影响、线程池调优、也肯会把工作中碰到的并发问题抛出来问技术趋势、docker、微服务等新技术发展历史、带来的福利如何准备首先要声明的是，最好的“准备”方式一定是平时多积累、遇到问题不要逃避或者讨巧、深入去思考并解决，在解决一个个问题的过程中积累解决问题的能力，形成自己的知识体系。所以这里说的如何准备不是说临时抱佛脚，而是如何能通过提前准备把自己平时的积累展现出来，不因为临场的表现影响面试官对你的判断。针对以上列的知识点思考答案甚至扩展，如果能知道大部分，深入一部分就很好，这个过程主要是整理自己的知识体系回忆整理简历和过往项目中的”难点“、”亮点“，因为这些是用来区分候选人很重要的点，合格的面试官一定会问类似于”你在项目中经历的最大的技术难点是什么？“，整理一下思路，不至于在面试时候因为时间久远而回忆不起来细节影响面试效果。沟通过程中做到有理有据，不要过于自大，也无需刻意迎合面试官。沟通的本质是信息透明化，工作中也许我们无法做到完全客观公正，但是在技术问题上坚持自己的客观和原则是我认为技术人应该坚持的品格，我这里说的坚持不是一根筋的固执已见，而是根据共同认可的事实进行逻辑推断得出的观点。长远来看这种品格会带给你足够的技术影响力和回报。","source":"_posts/Interview-Questions.md","raw":"---\ntitle: Interview-Questions\ndate: 2017-11-20 15:38:08\ntags: 面试\n---\n\n\n### 如果让你设计一个异步调用的服务，你会注意些什么？\n\n异步结果（Future & Promise）设计\n异步没有被调用者的反馈（Feed Back），如果没有限流，将会被调用垮掉\n\n作者：Leo Yang\n链接：https://www.zhihu.com/question/60949531/answer/184044541\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n从阿里的常规java技术面试角度说一说，一般都是由浅到深去问，思路是先考察基础是否过关，再通过深度考察是否有技术热情和深度，同时可能会通过提出一些质疑和挑战来考察候选人是如何与不同意见进行沟通考察内容和方式基础知识：考察基础的时候一般都不会太深入地去问，主要目的是考察知识面，如果发现候选人很多都不知道可能就不会继续进入下一步的考察。\nJDK 集合、BIO/NIO、annotation 等虚拟机 内存模型、类加载原理数据库 索引、事务、死锁 等并发 并发优缺点、内存可见性（volatile）、锁、同步、线程池框架网络 TCP/HTTP 常见设计模式深入考察：深入考察的时候不会像考察基础一样面面俱到，而是会在某个点上深入去聊，这个点的选择可能是让候选人自己选一个点，也可能是面试官根据简历内容去选，主要目的是考察候选人对某个技术点的深入掌握程度，技术是相通的，如果一个人能在某个技术点上达到很深入的程度，其他点上通常也不会有太大问题；相反如果某个人在他声称很了解的点上都支支吾吾、一知半解多半可以判断此人要么技术能力有限、要么遇到问题不愿深入考察、浅尝辄止。\nJDK ConcurrentHashMap如何提高并发度、NIO的原理（零拷贝、堆外内存），优缺点虚拟机 包冲突，类冲突的形成原理及解决办法（可能会引申JDK9的模块化设计）、TCCL的存在价值分布式 一致性哈希、RPC原理和设计（通信协议、序列化方式、超时机制等）、负载均衡、分布式缓存架构设计、分布式消息、分布式事务、paxos（这个可能只有在技术专业型很强的职位上会去问）数据库 数据库性能优化（慢sql、索引优化、大事务、内核参数调优），也可能会把一些工作中碰到的诡异场景抛出来问并发 非阻塞锁（CAS)、并发对编译器优化的影响、线程池调优、也肯会把工作中碰到的并发问题抛出来问技术趋势、docker、微服务等新技术发展历史、带来的福利如何准备首先要声明的是，最好的“准备”方式一定是平时多积累、遇到问题不要逃避或者讨巧、深入去思考并解决，在解决一个个问题的过程中积累解决问题的能力，形成自己的知识体系。所以这里说的如何准备不是说临时抱佛脚，而是如何能通过提前准备把自己平时的积累展现出来，不因为临场的表现影响面试官对你的判断。针对以上列的知识点思考答案甚至扩展，如果能知道大部分，深入一部分就很好，这个过程主要是整理自己的知识体系回忆整理简历和过往项目中的”难点“、”亮点“，因为这些是用来区分候选人很重要的点，合格的面试官一定会问类似于”你在项目中经历的最大的技术难点是什么？“，整理一下思路，不至于在面试时候因为时间久远而回忆不起来细节影响面试效果。沟通过程中做到有理有据，不要过于自大，也无需刻意迎合面试官。沟通的本质是信息透明化，工作中也许我们无法做到完全客观公正，但是在技术问题上坚持自己的客观和原则是我认为技术人应该坚持的品格，我这里说的坚持不是一根筋的固执已见，而是根据共同认可的事实进行逻辑推断得出的观点。长远来看这种品格会带给你足够的技术影响力和回报。","slug":"Interview-Questions","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsys00153iq2y5swmh97","content":"<h3 id=\"如果让你设计一个异步调用的服务，你会注意些什么？\"><a href=\"#如果让你设计一个异步调用的服务，你会注意些什么？\" class=\"headerlink\" title=\"如果让你设计一个异步调用的服务，你会注意些什么？\"></a>如果让你设计一个异步调用的服务，你会注意些什么？</h3><p>异步结果（Future &amp; Promise）设计<br>异步没有被调用者的反馈（Feed Back），如果没有限流，将会被调用垮掉</p>\n<p>作者：Leo Yang<br>链接：<a href=\"https://www.zhihu.com/question/60949531/answer/184044541\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/60949531/answer/184044541</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>从阿里的常规java技术面试角度说一说，一般都是由浅到深去问，思路是先考察基础是否过关，再通过深度考察是否有技术热情和深度，同时可能会通过提出一些质疑和挑战来考察候选人是如何与不同意见进行沟通考察内容和方式基础知识：考察基础的时候一般都不会太深入地去问，主要目的是考察知识面，如果发现候选人很多都不知道可能就不会继续进入下一步的考察。<br>JDK 集合、BIO/NIO、annotation 等虚拟机 内存模型、类加载原理数据库 索引、事务、死锁 等并发 并发优缺点、内存可见性（volatile）、锁、同步、线程池框架网络 TCP/HTTP 常见设计模式深入考察：深入考察的时候不会像考察基础一样面面俱到，而是会在某个点上深入去聊，这个点的选择可能是让候选人自己选一个点，也可能是面试官根据简历内容去选，主要目的是考察候选人对某个技术点的深入掌握程度，技术是相通的，如果一个人能在某个技术点上达到很深入的程度，其他点上通常也不会有太大问题；相反如果某个人在他声称很了解的点上都支支吾吾、一知半解多半可以判断此人要么技术能力有限、要么遇到问题不愿深入考察、浅尝辄止。<br>JDK ConcurrentHashMap如何提高并发度、NIO的原理（零拷贝、堆外内存），优缺点虚拟机 包冲突，类冲突的形成原理及解决办法（可能会引申JDK9的模块化设计）、TCCL的存在价值分布式 一致性哈希、RPC原理和设计（通信协议、序列化方式、超时机制等）、负载均衡、分布式缓存架构设计、分布式消息、分布式事务、paxos（这个可能只有在技术专业型很强的职位上会去问）数据库 数据库性能优化（慢sql、索引优化、大事务、内核参数调优），也可能会把一些工作中碰到的诡异场景抛出来问并发 非阻塞锁（CAS)、并发对编译器优化的影响、线程池调优、也肯会把工作中碰到的并发问题抛出来问技术趋势、docker、微服务等新技术发展历史、带来的福利如何准备首先要声明的是，最好的“准备”方式一定是平时多积累、遇到问题不要逃避或者讨巧、深入去思考并解决，在解决一个个问题的过程中积累解决问题的能力，形成自己的知识体系。所以这里说的如何准备不是说临时抱佛脚，而是如何能通过提前准备把自己平时的积累展现出来，不因为临场的表现影响面试官对你的判断。针对以上列的知识点思考答案甚至扩展，如果能知道大部分，深入一部分就很好，这个过程主要是整理自己的知识体系回忆整理简历和过往项目中的”难点“、”亮点“，因为这些是用来区分候选人很重要的点，合格的面试官一定会问类似于”你在项目中经历的最大的技术难点是什么？“，整理一下思路，不至于在面试时候因为时间久远而回忆不起来细节影响面试效果。沟通过程中做到有理有据，不要过于自大，也无需刻意迎合面试官。沟通的本质是信息透明化，工作中也许我们无法做到完全客观公正，但是在技术问题上坚持自己的客观和原则是我认为技术人应该坚持的品格，我这里说的坚持不是一根筋的固执已见，而是根据共同认可的事实进行逻辑推断得出的观点。长远来看这种品格会带给你足够的技术影响力和回报。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"如果让你设计一个异步调用的服务，你会注意些什么？\"><a href=\"#如果让你设计一个异步调用的服务，你会注意些什么？\" class=\"headerlink\" title=\"如果让你设计一个异步调用的服务，你会注意些什么？\"></a>如果让你设计一个异步调用的服务，你会注意些什么？</h3><p>异步结果（Future &amp; Promise）设计<br>异步没有被调用者的反馈（Feed Back），如果没有限流，将会被调用垮掉</p>\n<p>作者：Leo Yang<br>链接：<a href=\"https://www.zhihu.com/question/60949531/answer/184044541\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/60949531/answer/184044541</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>从阿里的常规java技术面试角度说一说，一般都是由浅到深去问，思路是先考察基础是否过关，再通过深度考察是否有技术热情和深度，同时可能会通过提出一些质疑和挑战来考察候选人是如何与不同意见进行沟通考察内容和方式基础知识：考察基础的时候一般都不会太深入地去问，主要目的是考察知识面，如果发现候选人很多都不知道可能就不会继续进入下一步的考察。<br>JDK 集合、BIO/NIO、annotation 等虚拟机 内存模型、类加载原理数据库 索引、事务、死锁 等并发 并发优缺点、内存可见性（volatile）、锁、同步、线程池框架网络 TCP/HTTP 常见设计模式深入考察：深入考察的时候不会像考察基础一样面面俱到，而是会在某个点上深入去聊，这个点的选择可能是让候选人自己选一个点，也可能是面试官根据简历内容去选，主要目的是考察候选人对某个技术点的深入掌握程度，技术是相通的，如果一个人能在某个技术点上达到很深入的程度，其他点上通常也不会有太大问题；相反如果某个人在他声称很了解的点上都支支吾吾、一知半解多半可以判断此人要么技术能力有限、要么遇到问题不愿深入考察、浅尝辄止。<br>JDK ConcurrentHashMap如何提高并发度、NIO的原理（零拷贝、堆外内存），优缺点虚拟机 包冲突，类冲突的形成原理及解决办法（可能会引申JDK9的模块化设计）、TCCL的存在价值分布式 一致性哈希、RPC原理和设计（通信协议、序列化方式、超时机制等）、负载均衡、分布式缓存架构设计、分布式消息、分布式事务、paxos（这个可能只有在技术专业型很强的职位上会去问）数据库 数据库性能优化（慢sql、索引优化、大事务、内核参数调优），也可能会把一些工作中碰到的诡异场景抛出来问并发 非阻塞锁（CAS)、并发对编译器优化的影响、线程池调优、也肯会把工作中碰到的并发问题抛出来问技术趋势、docker、微服务等新技术发展历史、带来的福利如何准备首先要声明的是，最好的“准备”方式一定是平时多积累、遇到问题不要逃避或者讨巧、深入去思考并解决，在解决一个个问题的过程中积累解决问题的能力，形成自己的知识体系。所以这里说的如何准备不是说临时抱佛脚，而是如何能通过提前准备把自己平时的积累展现出来，不因为临场的表现影响面试官对你的判断。针对以上列的知识点思考答案甚至扩展，如果能知道大部分，深入一部分就很好，这个过程主要是整理自己的知识体系回忆整理简历和过往项目中的”难点“、”亮点“，因为这些是用来区分候选人很重要的点，合格的面试官一定会问类似于”你在项目中经历的最大的技术难点是什么？“，整理一下思路，不至于在面试时候因为时间久远而回忆不起来细节影响面试效果。沟通过程中做到有理有据，不要过于自大，也无需刻意迎合面试官。沟通的本质是信息透明化，工作中也许我们无法做到完全客观公正，但是在技术问题上坚持自己的客观和原则是我认为技术人应该坚持的品格，我这里说的坚持不是一根筋的固执已见，而是根据共同认可的事实进行逻辑推断得出的观点。长远来看这种品格会带给你足够的技术影响力和回报。</p>\n"},{"title":"JVM-CAS-Campare-and-swap","date":"2017-11-10T11:48:55.000Z","_content":"> 仅供学习交流,如有错误请指出,如要转载请加上出处,谢谢\n\n### CAS\n\n硬件指令\n\n### 基于CAS的无所化（Lock-Free）设计\n\n也就是所谓的乐观锁\n``` java\n/**\n * 自旋锁\n */\npublic class SpinLock {\n    private AtomicBoolean canLock = new AtomicBoolean(true);\n\n    public void lock() {\n        boolean b;\n        do {\n            b = canLock.compareAndSet(true, false);\n        } while (!b);\n    }\n\n    public void release() {\n        canLock.compareAndSet(false, true);\n    }\n}\n```\n\n调用lock方法时，`canLock`初始为true，cas成功执行，返回修改后的值，也就是false。然后循环在while中，只要canLock没有被重置会true，cas一直是失败的。CPU被该线程长久占用着。\n\n### ABA问题\n\nCAS本身是没有任何问题的，是操作系统的指令。但是，当我们用CAS原理来设计无锁化的互斥机制时，就一定会产生ABA问题。\n\n### 优化ABA\n\n对于某些系统，ABA不会产生问题，但也有不能容忍ABA的系统\n","source":"_posts/JVM-CAS-Campare-and-swap.md","raw":"---\ntitle: JVM-CAS-Campare-and-swap\ndate: 2017-11-10 19:48:55\ntags: JVM\n---\n> 仅供学习交流,如有错误请指出,如要转载请加上出处,谢谢\n\n### CAS\n\n硬件指令\n\n### 基于CAS的无所化（Lock-Free）设计\n\n也就是所谓的乐观锁\n``` java\n/**\n * 自旋锁\n */\npublic class SpinLock {\n    private AtomicBoolean canLock = new AtomicBoolean(true);\n\n    public void lock() {\n        boolean b;\n        do {\n            b = canLock.compareAndSet(true, false);\n        } while (!b);\n    }\n\n    public void release() {\n        canLock.compareAndSet(false, true);\n    }\n}\n```\n\n调用lock方法时，`canLock`初始为true，cas成功执行，返回修改后的值，也就是false。然后循环在while中，只要canLock没有被重置会true，cas一直是失败的。CPU被该线程长久占用着。\n\n### ABA问题\n\nCAS本身是没有任何问题的，是操作系统的指令。但是，当我们用CAS原理来设计无锁化的互斥机制时，就一定会产生ABA问题。\n\n### 优化ABA\n\n对于某些系统，ABA不会产生问题，但也有不能容忍ABA的系统\n","slug":"JVM-CAS-Campare-and-swap","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyt00173iq2d9knarfl","content":"<blockquote>\n<p>仅供学习交流,如有错误请指出,如要转载请加上出处,谢谢</p>\n</blockquote>\n<h3 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h3><p>硬件指令</p>\n<h3 id=\"基于CAS的无所化（Lock-Free）设计\"><a href=\"#基于CAS的无所化（Lock-Free）设计\" class=\"headerlink\" title=\"基于CAS的无所化（Lock-Free）设计\"></a>基于CAS的无所化（Lock-Free）设计</h3><p>也就是所谓的乐观锁<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 自旋锁</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpinLock</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> AtomicBoolean canLock = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> b;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            b = canLock.compareAndSet(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (!b);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        canLock.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用lock方法时，<code>canLock</code>初始为true，cas成功执行，返回修改后的值，也就是false。然后循环在while中，只要canLock没有被重置会true，cas一直是失败的。CPU被该线程长久占用着。</p>\n<h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>CAS本身是没有任何问题的，是操作系统的指令。但是，当我们用CAS原理来设计无锁化的互斥机制时，就一定会产生ABA问题。</p>\n<h3 id=\"优化ABA\"><a href=\"#优化ABA\" class=\"headerlink\" title=\"优化ABA\"></a>优化ABA</h3><p>对于某些系统，ABA不会产生问题，但也有不能容忍ABA的系统</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>仅供学习交流,如有错误请指出,如要转载请加上出处,谢谢</p>\n</blockquote>\n<h3 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h3><p>硬件指令</p>\n<h3 id=\"基于CAS的无所化（Lock-Free）设计\"><a href=\"#基于CAS的无所化（Lock-Free）设计\" class=\"headerlink\" title=\"基于CAS的无所化（Lock-Free）设计\"></a>基于CAS的无所化（Lock-Free）设计</h3><p>也就是所谓的乐观锁<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 自旋锁</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpinLock</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> AtomicBoolean canLock = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> b;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            b = canLock.compareAndSet(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (!b);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        canLock.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用lock方法时，<code>canLock</code>初始为true，cas成功执行，返回修改后的值，也就是false。然后循环在while中，只要canLock没有被重置会true，cas一直是失败的。CPU被该线程长久占用着。</p>\n<h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>CAS本身是没有任何问题的，是操作系统的指令。但是，当我们用CAS原理来设计无锁化的互斥机制时，就一定会产生ABA问题。</p>\n<h3 id=\"优化ABA\"><a href=\"#优化ABA\" class=\"headerlink\" title=\"优化ABA\"></a>优化ABA</h3><p>对于某些系统，ABA不会产生问题，但也有不能容忍ABA的系统</p>\n"},{"title":"JVM-Crash-Log-Analysis","date":"2018-01-11T06:39:37.000Z","_content":"\n\nhttp://www.raychase.net/1459\n\n致命错误出现的时候，JVM生成了hs_err_pid<pid>.log这样的文件，其中往往包含了虚拟机崩溃原因的重要信息。因为经常遇到，在这篇文章里，我挑选了一个，并且逐段分析它包含的内容（文件可以在文章最后下载）。默认情况下文件是创建在工作目录下的（如果没权限创建的话JVM会尝试把文件写到/tmp这样的临时目录下面去），当然，文件格式和路径也可以通过参数指定，比如：\n\n1\njava -XX:ErrorFile=/var/log/java/java_error%p.log\n这个文件将包括：\n\n触发致命错误的操作异常或者信号；\n版本和配置信息；\n触发致命异常的线程详细信息和线程栈；\n当前运行的线程列表和它们的状态；\n堆的总括信息；\n加载的本地库；\n命令行参数；\n环境变量；\n操作系统CPU的详细信息。\n首先，看到的是对问题的概要介绍：\n\n1\n#  SIGSEGV (0xb) at pc=0x03568cf4, pid=16819, tid=3073346448\n一个非预期的错误被JRE检测到，其中：\n\nSIGSEGV是信号名称\n0xb是信号码\npc=0x03568cf4指的是程序计数器的值\npid=16819是进程号\ntid=3073346448是线程号\n如果你对JVM有了解，应该不会对这些东西陌生。\n","source":"_posts/JVM-Crash-Log-Analysis.md","raw":"---\ntitle: JVM-Crash-Log-Analysis\ndate: 2018-01-11 14:39:37\ntags:\n---\n\n\nhttp://www.raychase.net/1459\n\n致命错误出现的时候，JVM生成了hs_err_pid<pid>.log这样的文件，其中往往包含了虚拟机崩溃原因的重要信息。因为经常遇到，在这篇文章里，我挑选了一个，并且逐段分析它包含的内容（文件可以在文章最后下载）。默认情况下文件是创建在工作目录下的（如果没权限创建的话JVM会尝试把文件写到/tmp这样的临时目录下面去），当然，文件格式和路径也可以通过参数指定，比如：\n\n1\njava -XX:ErrorFile=/var/log/java/java_error%p.log\n这个文件将包括：\n\n触发致命错误的操作异常或者信号；\n版本和配置信息；\n触发致命异常的线程详细信息和线程栈；\n当前运行的线程列表和它们的状态；\n堆的总括信息；\n加载的本地库；\n命令行参数；\n环境变量；\n操作系统CPU的详细信息。\n首先，看到的是对问题的概要介绍：\n\n1\n#  SIGSEGV (0xb) at pc=0x03568cf4, pid=16819, tid=3073346448\n一个非预期的错误被JRE检测到，其中：\n\nSIGSEGV是信号名称\n0xb是信号码\npc=0x03568cf4指的是程序计数器的值\npid=16819是进程号\ntid=3073346448是线程号\n如果你对JVM有了解，应该不会对这些东西陌生。\n","slug":"JVM-Crash-Log-Analysis","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyu00193iq2exlx32vz","content":"<p><a href=\"http://www.raychase.net/1459\" target=\"_blank\" rel=\"external\">http://www.raychase.net/1459</a></p>\n<p>致命错误出现的时候，JVM生成了hs_err_pid<pid>.log这样的文件，其中往往包含了虚拟机崩溃原因的重要信息。因为经常遇到，在这篇文章里，我挑选了一个，并且逐段分析它包含的内容（文件可以在文章最后下载）。默认情况下文件是创建在工作目录下的（如果没权限创建的话JVM会尝试把文件写到/tmp这样的临时目录下面去），当然，文件格式和路径也可以通过参数指定，比如：</pid></p>\n<p>1<br>java -XX:ErrorFile=/var/log/java/java_error%p.log<br>这个文件将包括：</p>\n<p>触发致命错误的操作异常或者信号；<br>版本和配置信息；<br>触发致命异常的线程详细信息和线程栈；<br>当前运行的线程列表和它们的状态；<br>堆的总括信息；<br>加载的本地库；<br>命令行参数；<br>环境变量；<br>操作系统CPU的详细信息。<br>首先，看到的是对问题的概要介绍：</p>\n<p>1</p>\n<h1 id=\"SIGSEGV-0xb-at-pc-0x03568cf4-pid-16819-tid-3073346448\"><a href=\"#SIGSEGV-0xb-at-pc-0x03568cf4-pid-16819-tid-3073346448\" class=\"headerlink\" title=\"SIGSEGV (0xb) at pc=0x03568cf4, pid=16819, tid=3073346448\"></a>SIGSEGV (0xb) at pc=0x03568cf4, pid=16819, tid=3073346448</h1><p>一个非预期的错误被JRE检测到，其中：</p>\n<p>SIGSEGV是信号名称<br>0xb是信号码<br>pc=0x03568cf4指的是程序计数器的值<br>pid=16819是进程号<br>tid=3073346448是线程号<br>如果你对JVM有了解，应该不会对这些东西陌生。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.raychase.net/1459\" target=\"_blank\" rel=\"external\">http://www.raychase.net/1459</a></p>\n<p>致命错误出现的时候，JVM生成了hs_err_pid<pid>.log这样的文件，其中往往包含了虚拟机崩溃原因的重要信息。因为经常遇到，在这篇文章里，我挑选了一个，并且逐段分析它包含的内容（文件可以在文章最后下载）。默认情况下文件是创建在工作目录下的（如果没权限创建的话JVM会尝试把文件写到/tmp这样的临时目录下面去），当然，文件格式和路径也可以通过参数指定，比如：</pid></p>\n<p>1<br>java -XX:ErrorFile=/var/log/java/java_error%p.log<br>这个文件将包括：</p>\n<p>触发致命错误的操作异常或者信号；<br>版本和配置信息；<br>触发致命异常的线程详细信息和线程栈；<br>当前运行的线程列表和它们的状态；<br>堆的总括信息；<br>加载的本地库；<br>命令行参数；<br>环境变量；<br>操作系统CPU的详细信息。<br>首先，看到的是对问题的概要介绍：</p>\n<p>1</p>\n<h1 id=\"SIGSEGV-0xb-at-pc-0x03568cf4-pid-16819-tid-3073346448\"><a href=\"#SIGSEGV-0xb-at-pc-0x03568cf4-pid-16819-tid-3073346448\" class=\"headerlink\" title=\"SIGSEGV (0xb) at pc=0x03568cf4, pid=16819, tid=3073346448\"></a>SIGSEGV (0xb) at pc=0x03568cf4, pid=16819, tid=3073346448</h1><p>一个非预期的错误被JRE检测到，其中：</p>\n<p>SIGSEGV是信号名称<br>0xb是信号码<br>pc=0x03568cf4指的是程序计数器的值<br>pid=16819是进程号<br>tid=3073346448是线程号<br>如果你对JVM有了解，应该不会对这些东西陌生。</p>\n"},{"title":"JVM-Debug-Openjdk-On-Mac","date":"2017-12-08T04:54:59.000Z","_content":"\nhttps://segmentfault.com/a/1190000005082098\n\nhttp://rednaxelafx.iteye.com/\n大神博客\n\nhttp://www.javaranger.com/archives/1636\nhttp://www.cnblogs.com/dennyzhangdd/p/6734638.html\nhttp://hllvm.group.iteye.com/group/topic/35385\n\n\ndebug on linux\nhttps://segmentfault.com/a/1190000008346240\n\n\n### netbeans看hotspot代码\n\nhttp://marcelinorc.com/2016/02/17/using-netbeans-to-hack-openjdk9-in-ubuntu/\n\n./configure --with-target-bits=64 \\\n--with-freetype=/usr/local/Cellar/freetype/2.8.1 \\\n--enable-ccache \\\n--with-jvm-variants=server,client \\\n--with-boot-jdk-jvmargs=\"-Xlint:deprecation -Xlint:unchecked\" \\\n--disable-zip-debug-info \\\n--disable-warnings-as-errors \\\n--with-debug-level=slowdebug 2>&1 | tee configure_mac_x64.log\n\n\nbash configure --with-target-bits=64 --with-freetype=/usr/local/Cellar/freetype/2.8.1 --enable-ccache --with-jvm-variants=server,client --with-boot-jdk-jvmargs=\"-Xlint:deprecation -Xlint:unchecked\" --disable-zip-debug-info --disable-warnings-as-errors --with-debug-level=slowdebug","source":"_posts/JVM-Debug-Openjdk-On-Mac.md","raw":"---\ntitle: JVM-Debug-Openjdk-On-Mac\ndate: 2017-12-08 12:54:59\ntags:\n---\n\nhttps://segmentfault.com/a/1190000005082098\n\nhttp://rednaxelafx.iteye.com/\n大神博客\n\nhttp://www.javaranger.com/archives/1636\nhttp://www.cnblogs.com/dennyzhangdd/p/6734638.html\nhttp://hllvm.group.iteye.com/group/topic/35385\n\n\ndebug on linux\nhttps://segmentfault.com/a/1190000008346240\n\n\n### netbeans看hotspot代码\n\nhttp://marcelinorc.com/2016/02/17/using-netbeans-to-hack-openjdk9-in-ubuntu/\n\n./configure --with-target-bits=64 \\\n--with-freetype=/usr/local/Cellar/freetype/2.8.1 \\\n--enable-ccache \\\n--with-jvm-variants=server,client \\\n--with-boot-jdk-jvmargs=\"-Xlint:deprecation -Xlint:unchecked\" \\\n--disable-zip-debug-info \\\n--disable-warnings-as-errors \\\n--with-debug-level=slowdebug 2>&1 | tee configure_mac_x64.log\n\n\nbash configure --with-target-bits=64 --with-freetype=/usr/local/Cellar/freetype/2.8.1 --enable-ccache --with-jvm-variants=server,client --with-boot-jdk-jvmargs=\"-Xlint:deprecation -Xlint:unchecked\" --disable-zip-debug-info --disable-warnings-as-errors --with-debug-level=slowdebug","slug":"JVM-Debug-Openjdk-On-Mac","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyu001b3iq262kugjwm","content":"<p><a href=\"https://segmentfault.com/a/1190000005082098\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000005082098</a></p>\n<p><a href=\"http://rednaxelafx.iteye.com/\" target=\"_blank\" rel=\"external\">http://rednaxelafx.iteye.com/</a><br>大神博客</p>\n<p><a href=\"http://www.javaranger.com/archives/1636\" target=\"_blank\" rel=\"external\">http://www.javaranger.com/archives/1636</a><br><a href=\"http://www.cnblogs.com/dennyzhangdd/p/6734638.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/dennyzhangdd/p/6734638.html</a><br><a href=\"http://hllvm.group.iteye.com/group/topic/35385\" target=\"_blank\" rel=\"external\">http://hllvm.group.iteye.com/group/topic/35385</a></p>\n<p>debug on linux<br><a href=\"https://segmentfault.com/a/1190000008346240\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000008346240</a></p>\n<h3 id=\"netbeans看hotspot代码\"><a href=\"#netbeans看hotspot代码\" class=\"headerlink\" title=\"netbeans看hotspot代码\"></a>netbeans看hotspot代码</h3><p><a href=\"http://marcelinorc.com/2016/02/17/using-netbeans-to-hack-openjdk9-in-ubuntu/\" target=\"_blank\" rel=\"external\">http://marcelinorc.com/2016/02/17/using-netbeans-to-hack-openjdk9-in-ubuntu/</a></p>\n<p>./configure –with-target-bits=64 \\<br>–with-freetype=/usr/local/Cellar/freetype/2.8.1 \\<br>–enable-ccache \\<br>–with-jvm-variants=server,client \\<br>–with-boot-jdk-jvmargs=”-Xlint:deprecation -Xlint:unchecked” \\<br>–disable-zip-debug-info \\<br>–disable-warnings-as-errors \\<br>–with-debug-level=slowdebug 2&gt;&amp;1 | tee configure_mac_x64.log</p>\n<p>bash configure –with-target-bits=64 –with-freetype=/usr/local/Cellar/freetype/2.8.1 –enable-ccache –with-jvm-variants=server,client –with-boot-jdk-jvmargs=”-Xlint:deprecation -Xlint:unchecked” –disable-zip-debug-info –disable-warnings-as-errors –with-debug-level=slowdebug</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://segmentfault.com/a/1190000005082098\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000005082098</a></p>\n<p><a href=\"http://rednaxelafx.iteye.com/\" target=\"_blank\" rel=\"external\">http://rednaxelafx.iteye.com/</a><br>大神博客</p>\n<p><a href=\"http://www.javaranger.com/archives/1636\" target=\"_blank\" rel=\"external\">http://www.javaranger.com/archives/1636</a><br><a href=\"http://www.cnblogs.com/dennyzhangdd/p/6734638.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/dennyzhangdd/p/6734638.html</a><br><a href=\"http://hllvm.group.iteye.com/group/topic/35385\" target=\"_blank\" rel=\"external\">http://hllvm.group.iteye.com/group/topic/35385</a></p>\n<p>debug on linux<br><a href=\"https://segmentfault.com/a/1190000008346240\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000008346240</a></p>\n<h3 id=\"netbeans看hotspot代码\"><a href=\"#netbeans看hotspot代码\" class=\"headerlink\" title=\"netbeans看hotspot代码\"></a>netbeans看hotspot代码</h3><p><a href=\"http://marcelinorc.com/2016/02/17/using-netbeans-to-hack-openjdk9-in-ubuntu/\" target=\"_blank\" rel=\"external\">http://marcelinorc.com/2016/02/17/using-netbeans-to-hack-openjdk9-in-ubuntu/</a></p>\n<p>./configure –with-target-bits=64 \\<br>–with-freetype=/usr/local/Cellar/freetype/2.8.1 \\<br>–enable-ccache \\<br>–with-jvm-variants=server,client \\<br>–with-boot-jdk-jvmargs=”-Xlint:deprecation -Xlint:unchecked” \\<br>–disable-zip-debug-info \\<br>–disable-warnings-as-errors \\<br>–with-debug-level=slowdebug 2&gt;&amp;1 | tee configure_mac_x64.log</p>\n<p>bash configure –with-target-bits=64 –with-freetype=/usr/local/Cellar/freetype/2.8.1 –enable-ccache –with-jvm-variants=server,client –with-boot-jdk-jvmargs=”-Xlint:deprecation -Xlint:unchecked” –disable-zip-debug-info –disable-warnings-as-errors –with-debug-level=slowdebug</p>\n"},{"title":"JVM-Lock","date":"2017-11-06T02:16:02.000Z","_content":"\n### 同步的原理\n\nJVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。\n\n### Java对象头\n\n锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。\n\n| 长度 | 内容 | 说明 |\n| --------- |:-----------:|:-----------|\n| 32/64bit | Mark Word | 存储对象的hashCode或锁信息等\n| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针\n| 32/64bit | Array length | 数组的长度（如果当前对象是数组）\n\nJava对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：\n\n25 bit\t4bit\t1bit\n是否是偏向锁\t2bit\n锁标志位\n无锁状态\t对象的hashCode\t对象分代年龄\t0\t01\n\n在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：\n![你想输入的替代文字](JVM-Lock/markword_state.jpg)\n\n### 几种锁的类型\n\n**线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。**\nJava SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。\n**锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。**\n\n#### 偏向锁\nHotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。\n![你想输入的替代文字](JVM-Lock/biased_lock_flow.jpg)\n\n##### 偏向锁的进一步理解\n偏向锁的释放不需要做任何事情，这也就意味着加过偏向锁的MarkValue会一直保留偏向锁的状态，因此即便同一个线程持续不断地加锁解锁，也是没有开销的。\n\n另一方面，偏向锁比轻量锁更容易被终结，轻量锁是在有锁竞争出现时升级为重量锁，而一般偏向锁是在有不同线程申请锁时升级为轻量锁，这也就意味着假如一个对象先被线程1加锁解锁，再被线程2加锁解锁，这过程中没有锁冲突，也一样会发生偏向锁失效，不同的是这回要先退化为无锁的状态，再加轻量锁，如图：\n\n另外，JVM对那种会有多线程加锁，但不存在锁竞争的情况也做了优化，听起来比较拗口，但在现实应用中确实是可能出现这种情况，因为线程之前除了互斥之外也可能发生同步关系，被同步的两个线程（一前一后）对共享对象锁的竞争很可能是没有冲突的。对这种情况，JVM用一个epoch表示一个偏向锁的时间戳（真实地生成一个时间戳代价还是蛮大的，因此这里应当理解为一种类似时间戳的identifier），对epoch，官方是这么解释的：\n\n##### 偏向锁的获取\n\n当一个线程访问同步块并获取锁时，**会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁**，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。\n\n##### 偏向锁的撤销\n\n**偏向锁使用了一种等到竞争出现才释放锁的机制**，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。\n\n##### 偏向锁的设置\n\n关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。\n\n#### 自旋锁\n\n线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。\n所谓“自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。\n自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。\n对自旋锁周期的选择上，HotSpot认为最佳时间应是一个线程上下文切换的时间，但目前并没有做到。经过调查，目前只是通过汇编暂停了几个CPU周期，除了自旋周期选择，HotSpot还进行许多其他的自旋优化策略，具体如下：\n如果平均负载小于CPUs则一直自旋\n如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞\n如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞 如果CPU处于节电模式则停止自旋\n自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）\n\n#### 轻量级锁\n\n##### 轻量级锁加锁\n\n线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。**然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。**\n\n##### 轻量级锁解锁\n\n**轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。**如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。下图是两个线程同时争夺锁，导致锁膨胀的流程图。\n\n![你想输入的替代文字](JVM-Lock/light_lock_flow.jpg)\n\n### 锁的优缺点总结\n\n| 锁 | 优点 | 缺点 | 适用场景 |\n| --------- |:-----------:|:-----------|:-----------|\n| 偏向锁\t | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景\n| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程使用自旋会消耗CPU | 追求响应时间,锁占用时间很短\n| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量,锁占用时间较长\n\n> 内容参考：http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/\n","source":"_posts/JVM-Lock.md","raw":"---\ntitle: JVM-Lock\ndate: 2017-11-06 10:16:02\ntags: JVM\n---\n\n### 同步的原理\n\nJVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。\n\n### Java对象头\n\n锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。\n\n| 长度 | 内容 | 说明 |\n| --------- |:-----------:|:-----------|\n| 32/64bit | Mark Word | 存储对象的hashCode或锁信息等\n| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针\n| 32/64bit | Array length | 数组的长度（如果当前对象是数组）\n\nJava对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：\n\n25 bit\t4bit\t1bit\n是否是偏向锁\t2bit\n锁标志位\n无锁状态\t对象的hashCode\t对象分代年龄\t0\t01\n\n在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：\n![你想输入的替代文字](JVM-Lock/markword_state.jpg)\n\n### 几种锁的类型\n\n**线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。**\nJava SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。\n**锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。**\n\n#### 偏向锁\nHotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。\n![你想输入的替代文字](JVM-Lock/biased_lock_flow.jpg)\n\n##### 偏向锁的进一步理解\n偏向锁的释放不需要做任何事情，这也就意味着加过偏向锁的MarkValue会一直保留偏向锁的状态，因此即便同一个线程持续不断地加锁解锁，也是没有开销的。\n\n另一方面，偏向锁比轻量锁更容易被终结，轻量锁是在有锁竞争出现时升级为重量锁，而一般偏向锁是在有不同线程申请锁时升级为轻量锁，这也就意味着假如一个对象先被线程1加锁解锁，再被线程2加锁解锁，这过程中没有锁冲突，也一样会发生偏向锁失效，不同的是这回要先退化为无锁的状态，再加轻量锁，如图：\n\n另外，JVM对那种会有多线程加锁，但不存在锁竞争的情况也做了优化，听起来比较拗口，但在现实应用中确实是可能出现这种情况，因为线程之前除了互斥之外也可能发生同步关系，被同步的两个线程（一前一后）对共享对象锁的竞争很可能是没有冲突的。对这种情况，JVM用一个epoch表示一个偏向锁的时间戳（真实地生成一个时间戳代价还是蛮大的，因此这里应当理解为一种类似时间戳的identifier），对epoch，官方是这么解释的：\n\n##### 偏向锁的获取\n\n当一个线程访问同步块并获取锁时，**会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁**，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。\n\n##### 偏向锁的撤销\n\n**偏向锁使用了一种等到竞争出现才释放锁的机制**，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。\n\n##### 偏向锁的设置\n\n关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。\n\n#### 自旋锁\n\n线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。\n所谓“自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。\n自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。\n对自旋锁周期的选择上，HotSpot认为最佳时间应是一个线程上下文切换的时间，但目前并没有做到。经过调查，目前只是通过汇编暂停了几个CPU周期，除了自旋周期选择，HotSpot还进行许多其他的自旋优化策略，具体如下：\n如果平均负载小于CPUs则一直自旋\n如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞\n如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞 如果CPU处于节电模式则停止自旋\n自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）\n\n#### 轻量级锁\n\n##### 轻量级锁加锁\n\n线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。**然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。**\n\n##### 轻量级锁解锁\n\n**轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。**如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。下图是两个线程同时争夺锁，导致锁膨胀的流程图。\n\n![你想输入的替代文字](JVM-Lock/light_lock_flow.jpg)\n\n### 锁的优缺点总结\n\n| 锁 | 优点 | 缺点 | 适用场景 |\n| --------- |:-----------:|:-----------|:-----------|\n| 偏向锁\t | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景\n| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程使用自旋会消耗CPU | 追求响应时间,锁占用时间很短\n| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量,锁占用时间较长\n\n> 内容参考：http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/\n","slug":"JVM-Lock","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyv001d3iq2r9wnctq8","content":"<h3 id=\"同步的原理\"><a href=\"#同步的原理\" class=\"headerlink\" title=\"同步的原理\"></a>同步的原理</h3><p>JVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。</p>\n<h3 id=\"Java对象头\"><a href=\"#Java对象头\" class=\"headerlink\" title=\"Java对象头\"></a>Java对象头</h3><p>锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。</p>\n<table>\n<thead>\n<tr>\n<th>长度</th>\n<th style=\"text-align:center\">内容</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>32/64bit</td>\n<td style=\"text-align:center\">Mark Word</td>\n<td style=\"text-align:left\">存储对象的hashCode或锁信息等</td>\n</tr>\n<tr>\n<td>32/64bit</td>\n<td style=\"text-align:center\">Class Metadata Address</td>\n<td style=\"text-align:left\">存储到对象类型数据的指针</td>\n</tr>\n<tr>\n<td>32/64bit</td>\n<td style=\"text-align:center\">Array length</td>\n<td style=\"text-align:left\">数组的长度（如果当前对象是数组）</td>\n</tr>\n</tbody>\n</table>\n<p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：</p>\n<p>25 bit    4bit    1bit<br>是否是偏向锁    2bit<br>锁标志位<br>无锁状态    对象的hashCode    对象分代年龄    0    01</p>\n<p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：<br><img src=\"/2017/11/06/JVM-Lock/markword_state.jpg\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"几种锁的类型\"><a href=\"#几种锁的类型\" class=\"headerlink\" title=\"几种锁的类型\"></a>几种锁的类型</h3><p><strong>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。</strong><br>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。<br><strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</strong></p>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><p>Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。<br><img src=\"/2017/11/06/JVM-Lock/biased_lock_flow.jpg\" alt=\"你想输入的替代文字\"></p>\n<h5 id=\"偏向锁的进一步理解\"><a href=\"#偏向锁的进一步理解\" class=\"headerlink\" title=\"偏向锁的进一步理解\"></a>偏向锁的进一步理解</h5><p>偏向锁的释放不需要做任何事情，这也就意味着加过偏向锁的MarkValue会一直保留偏向锁的状态，因此即便同一个线程持续不断地加锁解锁，也是没有开销的。</p>\n<p>另一方面，偏向锁比轻量锁更容易被终结，轻量锁是在有锁竞争出现时升级为重量锁，而一般偏向锁是在有不同线程申请锁时升级为轻量锁，这也就意味着假如一个对象先被线程1加锁解锁，再被线程2加锁解锁，这过程中没有锁冲突，也一样会发生偏向锁失效，不同的是这回要先退化为无锁的状态，再加轻量锁，如图：</p>\n<p>另外，JVM对那种会有多线程加锁，但不存在锁竞争的情况也做了优化，听起来比较拗口，但在现实应用中确实是可能出现这种情况，因为线程之前除了互斥之外也可能发生同步关系，被同步的两个线程（一前一后）对共享对象锁的竞争很可能是没有冲突的。对这种情况，JVM用一个epoch表示一个偏向锁的时间戳（真实地生成一个时间戳代价还是蛮大的，因此这里应当理解为一种类似时间戳的identifier），对epoch，官方是这么解释的：</p>\n<h5 id=\"偏向锁的获取\"><a href=\"#偏向锁的获取\" class=\"headerlink\" title=\"偏向锁的获取\"></a>偏向锁的获取</h5><p>当一个线程访问同步块并获取锁时，<strong>会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁</strong>，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>\n<h5 id=\"偏向锁的撤销\"><a href=\"#偏向锁的撤销\" class=\"headerlink\" title=\"偏向锁的撤销\"></a>偏向锁的撤销</h5><p><strong>偏向锁使用了一种等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p>\n<h5 id=\"偏向锁的设置\"><a href=\"#偏向锁的设置\" class=\"headerlink\" title=\"偏向锁的设置\"></a>偏向锁的设置</h5><p>关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。</p>\n<h4 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h4><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。<br>所谓“自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。<br>自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。<br>对自旋锁周期的选择上，HotSpot认为最佳时间应是一个线程上下文切换的时间，但目前并没有做到。经过调查，目前只是通过汇编暂停了几个CPU周期，除了自旋周期选择，HotSpot还进行许多其他的自旋优化策略，具体如下：<br>如果平均负载小于CPUs则一直自旋<br>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞<br>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞 如果CPU处于节电模式则停止自旋<br>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）</p>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><h5 id=\"轻量级锁加锁\"><a href=\"#轻量级锁加锁\" class=\"headerlink\" title=\"轻量级锁加锁\"></a>轻量级锁加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。<strong>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。</strong></p>\n<h5 id=\"轻量级锁解锁\"><a href=\"#轻量级锁解锁\" class=\"headerlink\" title=\"轻量级锁解锁\"></a>轻量级锁解锁</h5><p><strong>轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。</strong>如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p>\n<p><img src=\"/2017/11/06/JVM-Lock/light_lock_flow.jpg\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"锁的优缺点总结\"><a href=\"#锁的优缺点总结\" class=\"headerlink\" title=\"锁的优缺点总结\"></a>锁的优缺点总结</h3><table>\n<thead>\n<tr>\n<th>锁</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:left\">缺点</th>\n<th style=\"text-align:left\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td style=\"text-align:center\">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距</td>\n<td style=\"text-align:left\">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>\n<td style=\"text-align:left\">适用于只有一个线程访问同步块场景</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td style=\"text-align:center\">竞争的线程不会阻塞，提高了程序的响应速度</td>\n<td style=\"text-align:left\">如果始终得不到锁竞争的线程使用自旋会消耗CPU</td>\n<td style=\"text-align:left\">追求响应时间,锁占用时间很短</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td style=\"text-align:center\">线程竞争不使用自旋，不会消耗CPU</td>\n<td style=\"text-align:left\">线程阻塞，响应时间缓慢</td>\n<td style=\"text-align:left\">追求吞吐量,锁占用时间较长</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>内容参考：<a href=\"http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"external\">http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"同步的原理\"><a href=\"#同步的原理\" class=\"headerlink\" title=\"同步的原理\"></a>同步的原理</h3><p>JVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。</p>\n<h3 id=\"Java对象头\"><a href=\"#Java对象头\" class=\"headerlink\" title=\"Java对象头\"></a>Java对象头</h3><p>锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。</p>\n<table>\n<thead>\n<tr>\n<th>长度</th>\n<th style=\"text-align:center\">内容</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>32/64bit</td>\n<td style=\"text-align:center\">Mark Word</td>\n<td style=\"text-align:left\">存储对象的hashCode或锁信息等</td>\n</tr>\n<tr>\n<td>32/64bit</td>\n<td style=\"text-align:center\">Class Metadata Address</td>\n<td style=\"text-align:left\">存储到对象类型数据的指针</td>\n</tr>\n<tr>\n<td>32/64bit</td>\n<td style=\"text-align:center\">Array length</td>\n<td style=\"text-align:left\">数组的长度（如果当前对象是数组）</td>\n</tr>\n</tbody>\n</table>\n<p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：</p>\n<p>25 bit    4bit    1bit<br>是否是偏向锁    2bit<br>锁标志位<br>无锁状态    对象的hashCode    对象分代年龄    0    01</p>\n<p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：<br><img src=\"/2017/11/06/JVM-Lock/markword_state.jpg\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"几种锁的类型\"><a href=\"#几种锁的类型\" class=\"headerlink\" title=\"几种锁的类型\"></a>几种锁的类型</h3><p><strong>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。</strong><br>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。<br><strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</strong></p>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><p>Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。<br><img src=\"/2017/11/06/JVM-Lock/biased_lock_flow.jpg\" alt=\"你想输入的替代文字\"></p>\n<h5 id=\"偏向锁的进一步理解\"><a href=\"#偏向锁的进一步理解\" class=\"headerlink\" title=\"偏向锁的进一步理解\"></a>偏向锁的进一步理解</h5><p>偏向锁的释放不需要做任何事情，这也就意味着加过偏向锁的MarkValue会一直保留偏向锁的状态，因此即便同一个线程持续不断地加锁解锁，也是没有开销的。</p>\n<p>另一方面，偏向锁比轻量锁更容易被终结，轻量锁是在有锁竞争出现时升级为重量锁，而一般偏向锁是在有不同线程申请锁时升级为轻量锁，这也就意味着假如一个对象先被线程1加锁解锁，再被线程2加锁解锁，这过程中没有锁冲突，也一样会发生偏向锁失效，不同的是这回要先退化为无锁的状态，再加轻量锁，如图：</p>\n<p>另外，JVM对那种会有多线程加锁，但不存在锁竞争的情况也做了优化，听起来比较拗口，但在现实应用中确实是可能出现这种情况，因为线程之前除了互斥之外也可能发生同步关系，被同步的两个线程（一前一后）对共享对象锁的竞争很可能是没有冲突的。对这种情况，JVM用一个epoch表示一个偏向锁的时间戳（真实地生成一个时间戳代价还是蛮大的，因此这里应当理解为一种类似时间戳的identifier），对epoch，官方是这么解释的：</p>\n<h5 id=\"偏向锁的获取\"><a href=\"#偏向锁的获取\" class=\"headerlink\" title=\"偏向锁的获取\"></a>偏向锁的获取</h5><p>当一个线程访问同步块并获取锁时，<strong>会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁</strong>，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>\n<h5 id=\"偏向锁的撤销\"><a href=\"#偏向锁的撤销\" class=\"headerlink\" title=\"偏向锁的撤销\"></a>偏向锁的撤销</h5><p><strong>偏向锁使用了一种等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p>\n<h5 id=\"偏向锁的设置\"><a href=\"#偏向锁的设置\" class=\"headerlink\" title=\"偏向锁的设置\"></a>偏向锁的设置</h5><p>关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。</p>\n<h4 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h4><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。<br>所谓“自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。<br>自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。<br>对自旋锁周期的选择上，HotSpot认为最佳时间应是一个线程上下文切换的时间，但目前并没有做到。经过调查，目前只是通过汇编暂停了几个CPU周期，除了自旋周期选择，HotSpot还进行许多其他的自旋优化策略，具体如下：<br>如果平均负载小于CPUs则一直自旋<br>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞<br>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞 如果CPU处于节电模式则停止自旋<br>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）</p>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><h5 id=\"轻量级锁加锁\"><a href=\"#轻量级锁加锁\" class=\"headerlink\" title=\"轻量级锁加锁\"></a>轻量级锁加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。<strong>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。</strong></p>\n<h5 id=\"轻量级锁解锁\"><a href=\"#轻量级锁解锁\" class=\"headerlink\" title=\"轻量级锁解锁\"></a>轻量级锁解锁</h5><p><strong>轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。</strong>如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p>\n<p><img src=\"/2017/11/06/JVM-Lock/light_lock_flow.jpg\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"锁的优缺点总结\"><a href=\"#锁的优缺点总结\" class=\"headerlink\" title=\"锁的优缺点总结\"></a>锁的优缺点总结</h3><table>\n<thead>\n<tr>\n<th>锁</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:left\">缺点</th>\n<th style=\"text-align:left\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td style=\"text-align:center\">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距</td>\n<td style=\"text-align:left\">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>\n<td style=\"text-align:left\">适用于只有一个线程访问同步块场景</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td style=\"text-align:center\">竞争的线程不会阻塞，提高了程序的响应速度</td>\n<td style=\"text-align:left\">如果始终得不到锁竞争的线程使用自旋会消耗CPU</td>\n<td style=\"text-align:left\">追求响应时间,锁占用时间很短</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td style=\"text-align:center\">线程竞争不使用自旋，不会消耗CPU</td>\n<td style=\"text-align:left\">线程阻塞，响应时间缓慢</td>\n<td style=\"text-align:left\">追求吞吐量,锁占用时间较长</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>内容参考：<a href=\"http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"external\">http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/</a></p>\n</blockquote>\n"},{"title":"JVM-Off-Heap-Memory","date":"2017-12-02T07:05:06.000Z","_content":"\nhttp://www.jianshu.com/p/007052ee3773\nfull gc是怎么回收堆外内存的？\n\nhttp://www.cnblogs.com/holoyong/p/7266240.html\n","source":"_posts/JVM-Off-Heap-Memory.md","raw":"---\ntitle: JVM-Off-Heap-Memory\ndate: 2017-12-02 15:05:06\ntags: JVM\n---\n\nhttp://www.jianshu.com/p/007052ee3773\nfull gc是怎么回收堆外内存的？\n\nhttp://www.cnblogs.com/holoyong/p/7266240.html\n","slug":"JVM-Off-Heap-Memory","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyw001f3iq2bm65fbv1","content":"<p><a href=\"http://www.jianshu.com/p/007052ee3773\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/007052ee3773</a><br>full gc是怎么回收堆外内存的？</p>\n<p><a href=\"http://www.cnblogs.com/holoyong/p/7266240.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/holoyong/p/7266240.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.jianshu.com/p/007052ee3773\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/007052ee3773</a><br>full gc是怎么回收堆外内存的？</p>\n<p><a href=\"http://www.cnblogs.com/holoyong/p/7266240.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/holoyong/p/7266240.html</a></p>\n"},{"title":"JVM-Optimization","date":"2017-11-06T06:43:26.000Z","_content":"\nhttp://blog.csdn.net/matt8/article/details/52298397\n\nhttps://www.ibm.com/developerworks/cn/java/j-lo-jvm-optimize-experience/index.html#icomments\n\nhttps://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/#icomments\n\nJava ReentrantLock（重入锁）带来的改变\n\n\n### 前言\n> ReentrantLock称为重入锁，它比内部锁synchronized拥有更强大的功能，它可中断、可定时，JDK5中，在高并发的情况下，它比synchronized有明显的性能优势，在JDK6中由于jvm的优化，两者差别不是很大。\n\n\nsynchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。 \n1.某个线程在等待一个锁的控制权的这段时间需要中断 \n2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程 \n3.具有公平锁功能，每个到来的线程都将排队等候 \n\n先说第一种情况，ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。（如果你没有了解java的中断机制，请参考下相关资料，再回头看这篇文章，80%的人根本没有真正理解什么是java的中断，呵呵） \n\n这里来做个试验，首先搞一个Buffer类，它有读操作和写操作，为了不读到脏数据，写和读都需要加锁，我们先用synchronized原语来加锁，如下： \n\n``` java\npackage com.eric.lock;\n\npublic class Buffer {\n\n    private Object lock;\n\n    public Buffer() {\n        lock = this;\n    }\n\n    public void write() {\n        synchronized (lock) {\n            long startTime = System.currentTimeMillis();\n            System.out.println(\"开始往这个buff写入数据…\");\n            // 模拟要处理很长时间\n            for (; ; ) {\n                if (System.currentTimeMillis() - startTime > Integer.MAX_VALUE)\n                    break;\n            }\n            System.out.println(\"终于写完了\");\n        }\n    }\n\n    public void read() {\n        synchronized (lock) {\n            System.out.println(\"从这个buff读数据\");\n        }\n    }\n}\n```\n\n接着，我们来定义2个线程，一个线程去写，一个线程去读。\n\nhttp://www.importnew.com/15311.html\nG1垃圾回收","source":"_posts/JVM-Optimization.md","raw":"---\ntitle: JVM-Optimization\ndate: 2017-11-06 14:43:26\ntags: JVM\n---\n\nhttp://blog.csdn.net/matt8/article/details/52298397\n\nhttps://www.ibm.com/developerworks/cn/java/j-lo-jvm-optimize-experience/index.html#icomments\n\nhttps://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/#icomments\n\nJava ReentrantLock（重入锁）带来的改变\n\n\n### 前言\n> ReentrantLock称为重入锁，它比内部锁synchronized拥有更强大的功能，它可中断、可定时，JDK5中，在高并发的情况下，它比synchronized有明显的性能优势，在JDK6中由于jvm的优化，两者差别不是很大。\n\n\nsynchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。 \n1.某个线程在等待一个锁的控制权的这段时间需要中断 \n2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程 \n3.具有公平锁功能，每个到来的线程都将排队等候 \n\n先说第一种情况，ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。（如果你没有了解java的中断机制，请参考下相关资料，再回头看这篇文章，80%的人根本没有真正理解什么是java的中断，呵呵） \n\n这里来做个试验，首先搞一个Buffer类，它有读操作和写操作，为了不读到脏数据，写和读都需要加锁，我们先用synchronized原语来加锁，如下： \n\n``` java\npackage com.eric.lock;\n\npublic class Buffer {\n\n    private Object lock;\n\n    public Buffer() {\n        lock = this;\n    }\n\n    public void write() {\n        synchronized (lock) {\n            long startTime = System.currentTimeMillis();\n            System.out.println(\"开始往这个buff写入数据…\");\n            // 模拟要处理很长时间\n            for (; ; ) {\n                if (System.currentTimeMillis() - startTime > Integer.MAX_VALUE)\n                    break;\n            }\n            System.out.println(\"终于写完了\");\n        }\n    }\n\n    public void read() {\n        synchronized (lock) {\n            System.out.println(\"从这个buff读数据\");\n        }\n    }\n}\n```\n\n接着，我们来定义2个线程，一个线程去写，一个线程去读。\n\nhttp://www.importnew.com/15311.html\nG1垃圾回收","slug":"JVM-Optimization","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyx001h3iq236xbkaoq","content":"<p><a href=\"http://blog.csdn.net/matt8/article/details/52298397\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/matt8/article/details/52298397</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jvm-optimize-experience/index.html#icomments\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/java/j-lo-jvm-optimize-experience/index.html#icomments</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/#icomments\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/#icomments</a></p>\n<p>Java ReentrantLock（重入锁）带来的改变</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>ReentrantLock称为重入锁，它比内部锁synchronized拥有更强大的功能，它可中断、可定时，JDK5中，在高并发的情况下，它比synchronized有明显的性能优势，在JDK6中由于jvm的优化，两者差别不是很大。</p>\n</blockquote>\n<p>synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。<br>1.某个线程在等待一个锁的控制权的这段时间需要中断<br>2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程<br>3.具有公平锁功能，每个到来的线程都将排队等候 </p>\n<p>先说第一种情况，ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。（如果你没有了解java的中断机制，请参考下相关资料，再回头看这篇文章，80%的人根本没有真正理解什么是java的中断，呵呵） </p>\n<p>这里来做个试验，首先搞一个Buffer类，它有读操作和写操作，为了不读到脏数据，写和读都需要加锁，我们先用synchronized原语来加锁，如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.eric.lock;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buffer</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> Object lock;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Buffer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        lock = <span class=\"keyword\">this</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</div><div class=\"line\">            <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</div><div class=\"line\">            System.out.println(<span class=\"string\">\"开始往这个buff写入数据…\"</span>);</div><div class=\"line\">            <span class=\"comment\">// 模拟要处理很长时间</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (; ; ) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (System.currentTimeMillis() - startTime &gt; Integer.MAX_VALUE)</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"终于写完了\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"从这个buff读数据\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着，我们来定义2个线程，一个线程去写，一个线程去读。</p>\n<p><a href=\"http://www.importnew.com/15311.html\" target=\"_blank\" rel=\"external\">http://www.importnew.com/15311.html</a><br>G1垃圾回收</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://blog.csdn.net/matt8/article/details/52298397\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/matt8/article/details/52298397</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jvm-optimize-experience/index.html#icomments\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/java/j-lo-jvm-optimize-experience/index.html#icomments</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/#icomments\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/#icomments</a></p>\n<p>Java ReentrantLock（重入锁）带来的改变</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>ReentrantLock称为重入锁，它比内部锁synchronized拥有更强大的功能，它可中断、可定时，JDK5中，在高并发的情况下，它比synchronized有明显的性能优势，在JDK6中由于jvm的优化，两者差别不是很大。</p>\n</blockquote>\n<p>synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。<br>1.某个线程在等待一个锁的控制权的这段时间需要中断<br>2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程<br>3.具有公平锁功能，每个到来的线程都将排队等候 </p>\n<p>先说第一种情况，ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。（如果你没有了解java的中断机制，请参考下相关资料，再回头看这篇文章，80%的人根本没有真正理解什么是java的中断，呵呵） </p>\n<p>这里来做个试验，首先搞一个Buffer类，它有读操作和写操作，为了不读到脏数据，写和读都需要加锁，我们先用synchronized原语来加锁，如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.eric.lock;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buffer</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> Object lock;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Buffer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        lock = <span class=\"keyword\">this</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</div><div class=\"line\">            <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</div><div class=\"line\">            System.out.println(<span class=\"string\">\"开始往这个buff写入数据…\"</span>);</div><div class=\"line\">            <span class=\"comment\">// 模拟要处理很长时间</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (; ; ) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (System.currentTimeMillis() - startTime &gt; Integer.MAX_VALUE)</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"终于写完了\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"从这个buff读数据\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着，我们来定义2个线程，一个线程去写，一个线程去读。</p>\n<p><a href=\"http://www.importnew.com/15311.html\" target=\"_blank\" rel=\"external\">http://www.importnew.com/15311.html</a><br>G1垃圾回收</p>\n"},{"title":"JVM-Profiling","date":"2017-11-07T07:36:54.000Z","_content":"\nhttps://yq.aliyun.com/articles/2390\n\n### heap dump\njmap -dump:format=b,file=heap.bin [java_process_id]","source":"_posts/JVM-Profiling.md","raw":"---\ntitle: JVM-Profiling\ndate: 2017-11-07 15:36:54\ntags: JVM\n---\n\nhttps://yq.aliyun.com/articles/2390\n\n### heap dump\njmap -dump:format=b,file=heap.bin [java_process_id]","slug":"JVM-Profiling","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyy001j3iq2svsv8eib","content":"<p><a href=\"https://yq.aliyun.com/articles/2390\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/articles/2390</a></p>\n<h3 id=\"heap-dump\"><a href=\"#heap-dump\" class=\"headerlink\" title=\"heap dump\"></a>heap dump</h3><p>jmap -dump:format=b,file=heap.bin [java_process_id]</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://yq.aliyun.com/articles/2390\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/articles/2390</a></p>\n<h3 id=\"heap-dump\"><a href=\"#heap-dump\" class=\"headerlink\" title=\"heap dump\"></a>heap dump</h3><p>jmap -dump:format=b,file=heap.bin [java_process_id]</p>\n"},{"title":"JVM——线程中断","date":"2017-11-09T12:36:45.000Z","_content":"\n\nhttp://luojinping.com/2015/04/13/Java%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/","source":"_posts/JVM-Thread-interupt.md","raw":"---\ntitle: JVM——线程中断\ndate: 2017-11-09 20:36:45\ntags: JVM\n---\n\n\nhttp://luojinping.com/2015/04/13/Java%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/","slug":"JVM-Thread-interupt","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyz001l3iq2xv0kkf5u","content":"<p><a href=\"http://luojinping.com/2015/04/13/Java%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/\" target=\"_blank\" rel=\"external\">http://luojinping.com/2015/04/13/Java%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://luojinping.com/2015/04/13/Java%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/\" target=\"_blank\" rel=\"external\">http://luojinping.com/2015/04/13/Java%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</a></p>\n"},{"title":"Kafka-FAQ","date":"2017-11-17T07:33:16.000Z","_content":"\nKafka写CommitLog时用了什么锁机制?\n\nsync;lock-free;reentrant lock\n\n\n### kafka和RocketMQ设计导致得关键性差异——对多队列得支持程度\n\nhttp://blog.csdn.net/chunlongyu/article/details/54576649\n\n\n### 学习资料\nhttp://blog.csdn.net/chunlongyu/article/category/6638499\n\nhttp://blog.csdn.net/chunlongyu/article/details/54407633\n\nhttp://blog.csdn.net/a417930422/article/category/6086259\n\nhttp://blog.csdn.net/lizhitao\n\nhttp://www.cnblogs.com/huxi2b\n\nhttp://blog.csdn.net/u014393917/article/category/6332828\n\n阿里中间件团队博客 \nhttp://jm.taobao.org/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/\n\n\n第九课. Kafka高性能之道\n    9.1 顺序写磁盘\n    9.2 零拷贝\n    9.3 批处理\n    9.4 基于ISR的动态平衡一致性算法","source":"_posts/Kafka-FAQ.md","raw":"---\ntitle: Kafka-FAQ\ndate: 2017-11-17 15:33:16\ntags: Kafka\n---\n\nKafka写CommitLog时用了什么锁机制?\n\nsync;lock-free;reentrant lock\n\n\n### kafka和RocketMQ设计导致得关键性差异——对多队列得支持程度\n\nhttp://blog.csdn.net/chunlongyu/article/details/54576649\n\n\n### 学习资料\nhttp://blog.csdn.net/chunlongyu/article/category/6638499\n\nhttp://blog.csdn.net/chunlongyu/article/details/54407633\n\nhttp://blog.csdn.net/a417930422/article/category/6086259\n\nhttp://blog.csdn.net/lizhitao\n\nhttp://www.cnblogs.com/huxi2b\n\nhttp://blog.csdn.net/u014393917/article/category/6332828\n\n阿里中间件团队博客 \nhttp://jm.taobao.org/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/\n\n\n第九课. Kafka高性能之道\n    9.1 顺序写磁盘\n    9.2 零拷贝\n    9.3 批处理\n    9.4 基于ISR的动态平衡一致性算法","slug":"Kafka-FAQ","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsyz001m3iq22f2w8ej8","content":"<p>Kafka写CommitLog时用了什么锁机制?</p>\n<p>sync;lock-free;reentrant lock</p>\n<h3 id=\"kafka和RocketMQ设计导致得关键性差异——对多队列得支持程度\"><a href=\"#kafka和RocketMQ设计导致得关键性差异——对多队列得支持程度\" class=\"headerlink\" title=\"kafka和RocketMQ设计导致得关键性差异——对多队列得支持程度\"></a>kafka和RocketMQ设计导致得关键性差异——对多队列得支持程度</h3><p><a href=\"http://blog.csdn.net/chunlongyu/article/details/54576649\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chunlongyu/article/details/54576649</a></p>\n<h3 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h3><p><a href=\"http://blog.csdn.net/chunlongyu/article/category/6638499\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chunlongyu/article/category/6638499</a></p>\n<p><a href=\"http://blog.csdn.net/chunlongyu/article/details/54407633\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chunlongyu/article/details/54407633</a></p>\n<p><a href=\"http://blog.csdn.net/a417930422/article/category/6086259\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/a417930422/article/category/6086259</a></p>\n<p><a href=\"http://blog.csdn.net/lizhitao\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lizhitao</a></p>\n<p><a href=\"http://www.cnblogs.com/huxi2b\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/huxi2b</a></p>\n<p><a href=\"http://blog.csdn.net/u014393917/article/category/6332828\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u014393917/article/category/6332828</a></p>\n<p>阿里中间件团队博客<br><a href=\"http://jm.taobao.org/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/\" target=\"_blank\" rel=\"external\">http://jm.taobao.org/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</a></p>\n<p>第九课. Kafka高性能之道<br>    9.1 顺序写磁盘<br>    9.2 零拷贝<br>    9.3 批处理<br>    9.4 基于ISR的动态平衡一致性算法</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Kafka写CommitLog时用了什么锁机制?</p>\n<p>sync;lock-free;reentrant lock</p>\n<h3 id=\"kafka和RocketMQ设计导致得关键性差异——对多队列得支持程度\"><a href=\"#kafka和RocketMQ设计导致得关键性差异——对多队列得支持程度\" class=\"headerlink\" title=\"kafka和RocketMQ设计导致得关键性差异——对多队列得支持程度\"></a>kafka和RocketMQ设计导致得关键性差异——对多队列得支持程度</h3><p><a href=\"http://blog.csdn.net/chunlongyu/article/details/54576649\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chunlongyu/article/details/54576649</a></p>\n<h3 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h3><p><a href=\"http://blog.csdn.net/chunlongyu/article/category/6638499\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chunlongyu/article/category/6638499</a></p>\n<p><a href=\"http://blog.csdn.net/chunlongyu/article/details/54407633\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chunlongyu/article/details/54407633</a></p>\n<p><a href=\"http://blog.csdn.net/a417930422/article/category/6086259\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/a417930422/article/category/6086259</a></p>\n<p><a href=\"http://blog.csdn.net/lizhitao\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lizhitao</a></p>\n<p><a href=\"http://www.cnblogs.com/huxi2b\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/huxi2b</a></p>\n<p><a href=\"http://blog.csdn.net/u014393917/article/category/6332828\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u014393917/article/category/6332828</a></p>\n<p>阿里中间件团队博客<br><a href=\"http://jm.taobao.org/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/\" target=\"_blank\" rel=\"external\">http://jm.taobao.org/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</a></p>\n<p>第九课. Kafka高性能之道<br>    9.1 顺序写磁盘<br>    9.2 零拷贝<br>    9.3 批处理<br>    9.4 基于ISR的动态平衡一致性算法</p>\n"},{"title":"实用Linux命令整理","date":"2017-09-09T09:16:00.000Z","_content":"\n#### 文件内容替换\n\n``` bash\nsudo sed -i 's/aaa/bbb/g' `grep -Rl aaa order_migrate_conf/`\n```\n\n#### 查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名\n\n``` bash\ngrep -Rl 1496628000000 order_migrate_conf/\n```\n\n#### 查看超大文件，vim 慎用\n\n``` bash\nless file.log\n```\n\n\n#### 超大文件从后往前查找关键词kind_pay\n\n``` bash\ntac file_path | grep kind_pay\n```\n\nless file_path, G(go to file end), /kind_pay + enter, N(search key word reversely)\n\n#### 分类查看各种状态的TCP连接\n\n``` bash\nss  -tan|awk 'NR>1{++S[$1]}END{for (a in S) print a,S[a]}'\n```\n\n#### 查看logs目录下所有文件夹及其内容的大小\n\n``` bash\ndu -sh logs/*\n```\n```\n$ du -sh Movies/* | sort -nr\n 28G\tMovies/Pan's.Labyrinth.潘神的迷宫.2006.1080p.BluRay.REMUX.MPEG-4.AVC.PCM-WARHD\n 19G\tMovies/The.Lord.Of.The.Rings.The.Return.Of.The.King.2003.1080p.BluRay.x264-SiNNERS\n 16G\tMovies/The.Lord.Of.The.Rings.The.Fellowship.Of.The.Ring.2001.1080p.BluRay.x264-SiNNERS\n 15G\tMovies/Interstellar.星际穿越.2014.1080p.BluRay.x264.DTS-RARBG\n 14G\tMovies/Witness.for.the.Prosecution.控方证人.1957.1080p.BluRay.x264.DTS-WiKi\n 14G\tMovies/Se7en.七宗罪.1995.REMASTERED.1080p.BluRay.x264.DTS-ES-FGT\n 14G\tMovies/In.Bruges.杀手没有假期.2008.1080p.BluRay.x264.DTS-FGT\n 13G\tMovies/Saving.Private.Ryan.拯救大兵瑞恩.1998.1080p.BluRay.x264-LEVERAGE\n 13G\tMovies/Braveheart.勇敢的心.1995.1080p.BluRay.x264-CiNEFiLE\n 12G\tMovies/The.Hunt.狩猎.2012.DANISH.1080p.BluRay.x264.DTS-FGT\n 12G\tMovies/The.Dark.Knight.Rises.蝙蝠侠.黑暗骑士崛起.2012.1080p.BluRay.x264-ALLiANCE\n 12G\tMovies/Life.of.Pi.少年派的奇幻漂流.2012.1080p.BluRay.x264.DTS-FGT\n 11G\tMovies/The.Lost.City.of.Z.迷失Z城.2016.1080p.BluRay.x264-GECKOS[rarbg]\n 11G\tMovies/Manhattan.Murder.Mystery.曼哈顿谋杀疑案.1993.1080p.BluRay.X264-AMIABLE[rarbg]\n 11G\tMovies/Like.Father.Like.Son.如父如子.2013.1080p.BluRay.DTS.x264-PublicHD\n```\n\n#### 将需要交互的命令的结果重定向到文件中\n\n``` bash\ntelnet zk_ip 2181 | tee -a  -i someFile\n\nenvi\n```\n\n#### 查看上下文切换\n\n``` bash\nnmon\n```\n\n#### 查看某个端口的应用程序PID\n``` bash\n$ lsof -i:9696\nCOMMAND    PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME\nkingshard 4994 eric   24u  IPv6 0x2dd5bc594d052b1f      0t0  TCP *:9696 (LISTEN)\n\n```\n\n#### 模拟网络抖动\nhttp://blog.csdn.net/weiweicao0429/article/details/17578011\n``` bash\n# tc qdisc add dev eth0 root netem delay 100ms\n# tc qdisc del dev eth0 root netem delay 100ms\n# tc qdisc del dev eth0 root\n```\n\n#### 进程死亡\ndmesg","source":"_posts/Linux-Useful-command.md","raw":"---\ntitle: 实用Linux命令整理\ndate: 2017-09-09 17:16:00\ntags: Linux\n---\n\n#### 文件内容替换\n\n``` bash\nsudo sed -i 's/aaa/bbb/g' `grep -Rl aaa order_migrate_conf/`\n```\n\n#### 查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名\n\n``` bash\ngrep -Rl 1496628000000 order_migrate_conf/\n```\n\n#### 查看超大文件，vim 慎用\n\n``` bash\nless file.log\n```\n\n\n#### 超大文件从后往前查找关键词kind_pay\n\n``` bash\ntac file_path | grep kind_pay\n```\n\nless file_path, G(go to file end), /kind_pay + enter, N(search key word reversely)\n\n#### 分类查看各种状态的TCP连接\n\n``` bash\nss  -tan|awk 'NR>1{++S[$1]}END{for (a in S) print a,S[a]}'\n```\n\n#### 查看logs目录下所有文件夹及其内容的大小\n\n``` bash\ndu -sh logs/*\n```\n```\n$ du -sh Movies/* | sort -nr\n 28G\tMovies/Pan's.Labyrinth.潘神的迷宫.2006.1080p.BluRay.REMUX.MPEG-4.AVC.PCM-WARHD\n 19G\tMovies/The.Lord.Of.The.Rings.The.Return.Of.The.King.2003.1080p.BluRay.x264-SiNNERS\n 16G\tMovies/The.Lord.Of.The.Rings.The.Fellowship.Of.The.Ring.2001.1080p.BluRay.x264-SiNNERS\n 15G\tMovies/Interstellar.星际穿越.2014.1080p.BluRay.x264.DTS-RARBG\n 14G\tMovies/Witness.for.the.Prosecution.控方证人.1957.1080p.BluRay.x264.DTS-WiKi\n 14G\tMovies/Se7en.七宗罪.1995.REMASTERED.1080p.BluRay.x264.DTS-ES-FGT\n 14G\tMovies/In.Bruges.杀手没有假期.2008.1080p.BluRay.x264.DTS-FGT\n 13G\tMovies/Saving.Private.Ryan.拯救大兵瑞恩.1998.1080p.BluRay.x264-LEVERAGE\n 13G\tMovies/Braveheart.勇敢的心.1995.1080p.BluRay.x264-CiNEFiLE\n 12G\tMovies/The.Hunt.狩猎.2012.DANISH.1080p.BluRay.x264.DTS-FGT\n 12G\tMovies/The.Dark.Knight.Rises.蝙蝠侠.黑暗骑士崛起.2012.1080p.BluRay.x264-ALLiANCE\n 12G\tMovies/Life.of.Pi.少年派的奇幻漂流.2012.1080p.BluRay.x264.DTS-FGT\n 11G\tMovies/The.Lost.City.of.Z.迷失Z城.2016.1080p.BluRay.x264-GECKOS[rarbg]\n 11G\tMovies/Manhattan.Murder.Mystery.曼哈顿谋杀疑案.1993.1080p.BluRay.X264-AMIABLE[rarbg]\n 11G\tMovies/Like.Father.Like.Son.如父如子.2013.1080p.BluRay.DTS.x264-PublicHD\n```\n\n#### 将需要交互的命令的结果重定向到文件中\n\n``` bash\ntelnet zk_ip 2181 | tee -a  -i someFile\n\nenvi\n```\n\n#### 查看上下文切换\n\n``` bash\nnmon\n```\n\n#### 查看某个端口的应用程序PID\n``` bash\n$ lsof -i:9696\nCOMMAND    PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME\nkingshard 4994 eric   24u  IPv6 0x2dd5bc594d052b1f      0t0  TCP *:9696 (LISTEN)\n\n```\n\n#### 模拟网络抖动\nhttp://blog.csdn.net/weiweicao0429/article/details/17578011\n``` bash\n# tc qdisc add dev eth0 root netem delay 100ms\n# tc qdisc del dev eth0 root netem delay 100ms\n# tc qdisc del dev eth0 root\n```\n\n#### 进程死亡\ndmesg","slug":"Linux-Useful-command","published":1,"updated":"2018-05-19T04:07:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz0001p3iq2blqyektp","content":"<h4 id=\"文件内容替换\"><a href=\"#文件内容替换\" class=\"headerlink\" title=\"文件内容替换\"></a>文件内容替换</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo sed -i <span class=\"string\">'s/aaa/bbb/g'</span> `grep -Rl aaa order_migrate_conf/`</div></pre></td></tr></table></figure>\n<h4 id=\"查找目录下的所有文件中是否含有某个字符串-并且只打印出文件名\"><a href=\"#查找目录下的所有文件中是否含有某个字符串-并且只打印出文件名\" class=\"headerlink\" title=\"查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名\"></a>查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -Rl 1496628000000 order_migrate_conf/</div></pre></td></tr></table></figure>\n<h4 id=\"查看超大文件，vim-慎用\"><a href=\"#查看超大文件，vim-慎用\" class=\"headerlink\" title=\"查看超大文件，vim 慎用\"></a>查看超大文件，vim 慎用</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">less file.log</div></pre></td></tr></table></figure>\n<h4 id=\"超大文件从后往前查找关键词kind-pay\"><a href=\"#超大文件从后往前查找关键词kind-pay\" class=\"headerlink\" title=\"超大文件从后往前查找关键词kind_pay\"></a>超大文件从后往前查找关键词kind_pay</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">tac file_path | grep kind_pay</div></pre></td></tr></table></figure>\n<p>less file_path, G(go to file end), /kind_pay + enter, N(search key word reversely)</p>\n<h4 id=\"分类查看各种状态的TCP连接\"><a href=\"#分类查看各种状态的TCP连接\" class=\"headerlink\" title=\"分类查看各种状态的TCP连接\"></a>分类查看各种状态的TCP连接</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ss  -tan|awk <span class=\"string\">'NR&gt;1&#123;++S[$1]&#125;END&#123;for (a in S) print a,S[a]&#125;'</span></div></pre></td></tr></table></figure>\n<h4 id=\"查看logs目录下所有文件夹及其内容的大小\"><a href=\"#查看logs目录下所有文件夹及其内容的大小\" class=\"headerlink\" title=\"查看logs目录下所有文件夹及其内容的大小\"></a>查看logs目录下所有文件夹及其内容的大小</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">du -sh logs/*</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ du -sh Movies/* | sort -nr</div><div class=\"line\"> 28G\tMovies/Pan&apos;s.Labyrinth.潘神的迷宫.2006.1080p.BluRay.REMUX.MPEG-4.AVC.PCM-WARHD</div><div class=\"line\"> 19G\tMovies/The.Lord.Of.The.Rings.The.Return.Of.The.King.2003.1080p.BluRay.x264-SiNNERS</div><div class=\"line\"> 16G\tMovies/The.Lord.Of.The.Rings.The.Fellowship.Of.The.Ring.2001.1080p.BluRay.x264-SiNNERS</div><div class=\"line\"> 15G\tMovies/Interstellar.星际穿越.2014.1080p.BluRay.x264.DTS-RARBG</div><div class=\"line\"> 14G\tMovies/Witness.for.the.Prosecution.控方证人.1957.1080p.BluRay.x264.DTS-WiKi</div><div class=\"line\"> 14G\tMovies/Se7en.七宗罪.1995.REMASTERED.1080p.BluRay.x264.DTS-ES-FGT</div><div class=\"line\"> 14G\tMovies/In.Bruges.杀手没有假期.2008.1080p.BluRay.x264.DTS-FGT</div><div class=\"line\"> 13G\tMovies/Saving.Private.Ryan.拯救大兵瑞恩.1998.1080p.BluRay.x264-LEVERAGE</div><div class=\"line\"> 13G\tMovies/Braveheart.勇敢的心.1995.1080p.BluRay.x264-CiNEFiLE</div><div class=\"line\"> 12G\tMovies/The.Hunt.狩猎.2012.DANISH.1080p.BluRay.x264.DTS-FGT</div><div class=\"line\"> 12G\tMovies/The.Dark.Knight.Rises.蝙蝠侠.黑暗骑士崛起.2012.1080p.BluRay.x264-ALLiANCE</div><div class=\"line\"> 12G\tMovies/Life.of.Pi.少年派的奇幻漂流.2012.1080p.BluRay.x264.DTS-FGT</div><div class=\"line\"> 11G\tMovies/The.Lost.City.of.Z.迷失Z城.2016.1080p.BluRay.x264-GECKOS[rarbg]</div><div class=\"line\"> 11G\tMovies/Manhattan.Murder.Mystery.曼哈顿谋杀疑案.1993.1080p.BluRay.X264-AMIABLE[rarbg]</div><div class=\"line\"> 11G\tMovies/Like.Father.Like.Son.如父如子.2013.1080p.BluRay.DTS.x264-PublicHD</div></pre></td></tr></table></figure>\n<h4 id=\"将需要交互的命令的结果重定向到文件中\"><a href=\"#将需要交互的命令的结果重定向到文件中\" class=\"headerlink\" title=\"将需要交互的命令的结果重定向到文件中\"></a>将需要交互的命令的结果重定向到文件中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">telnet zk_ip 2181 | tee -a  -i someFile</div><div class=\"line\"></div><div class=\"line\">envi</div></pre></td></tr></table></figure>\n<h4 id=\"查看上下文切换\"><a href=\"#查看上下文切换\" class=\"headerlink\" title=\"查看上下文切换\"></a>查看上下文切换</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nmon</div></pre></td></tr></table></figure>\n<h4 id=\"查看某个端口的应用程序PID\"><a href=\"#查看某个端口的应用程序PID\" class=\"headerlink\" title=\"查看某个端口的应用程序PID\"></a>查看某个端口的应用程序PID</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ lsof -i:9696</div><div class=\"line\">COMMAND    PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</div><div class=\"line\">kingshard 4994 eric   24u  IPv6 0x2dd5bc594d052b1f      0t0  TCP *:9696 (LISTEN)</div></pre></td></tr></table></figure>\n<h4 id=\"模拟网络抖动\"><a href=\"#模拟网络抖动\" class=\"headerlink\" title=\"模拟网络抖动\"></a>模拟网络抖动</h4><p><a href=\"http://blog.csdn.net/weiweicao0429/article/details/17578011\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/weiweicao0429/article/details/17578011</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># tc qdisc add dev eth0 root netem delay 100ms</span></div><div class=\"line\"><span class=\"comment\"># tc qdisc del dev eth0 root netem delay 100ms</span></div><div class=\"line\"><span class=\"comment\"># tc qdisc del dev eth0 root</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"进程死亡\"><a href=\"#进程死亡\" class=\"headerlink\" title=\"进程死亡\"></a>进程死亡</h4><p>dmesg</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"文件内容替换\"><a href=\"#文件内容替换\" class=\"headerlink\" title=\"文件内容替换\"></a>文件内容替换</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo sed -i <span class=\"string\">'s/aaa/bbb/g'</span> `grep -Rl aaa order_migrate_conf/`</div></pre></td></tr></table></figure>\n<h4 id=\"查找目录下的所有文件中是否含有某个字符串-并且只打印出文件名\"><a href=\"#查找目录下的所有文件中是否含有某个字符串-并且只打印出文件名\" class=\"headerlink\" title=\"查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名\"></a>查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -Rl 1496628000000 order_migrate_conf/</div></pre></td></tr></table></figure>\n<h4 id=\"查看超大文件，vim-慎用\"><a href=\"#查看超大文件，vim-慎用\" class=\"headerlink\" title=\"查看超大文件，vim 慎用\"></a>查看超大文件，vim 慎用</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">less file.log</div></pre></td></tr></table></figure>\n<h4 id=\"超大文件从后往前查找关键词kind-pay\"><a href=\"#超大文件从后往前查找关键词kind-pay\" class=\"headerlink\" title=\"超大文件从后往前查找关键词kind_pay\"></a>超大文件从后往前查找关键词kind_pay</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">tac file_path | grep kind_pay</div></pre></td></tr></table></figure>\n<p>less file_path, G(go to file end), /kind_pay + enter, N(search key word reversely)</p>\n<h4 id=\"分类查看各种状态的TCP连接\"><a href=\"#分类查看各种状态的TCP连接\" class=\"headerlink\" title=\"分类查看各种状态的TCP连接\"></a>分类查看各种状态的TCP连接</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ss  -tan|awk <span class=\"string\">'NR&gt;1&#123;++S[$1]&#125;END&#123;for (a in S) print a,S[a]&#125;'</span></div></pre></td></tr></table></figure>\n<h4 id=\"查看logs目录下所有文件夹及其内容的大小\"><a href=\"#查看logs目录下所有文件夹及其内容的大小\" class=\"headerlink\" title=\"查看logs目录下所有文件夹及其内容的大小\"></a>查看logs目录下所有文件夹及其内容的大小</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">du -sh logs/*</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ du -sh Movies/* | sort -nr</div><div class=\"line\"> 28G\tMovies/Pan&apos;s.Labyrinth.潘神的迷宫.2006.1080p.BluRay.REMUX.MPEG-4.AVC.PCM-WARHD</div><div class=\"line\"> 19G\tMovies/The.Lord.Of.The.Rings.The.Return.Of.The.King.2003.1080p.BluRay.x264-SiNNERS</div><div class=\"line\"> 16G\tMovies/The.Lord.Of.The.Rings.The.Fellowship.Of.The.Ring.2001.1080p.BluRay.x264-SiNNERS</div><div class=\"line\"> 15G\tMovies/Interstellar.星际穿越.2014.1080p.BluRay.x264.DTS-RARBG</div><div class=\"line\"> 14G\tMovies/Witness.for.the.Prosecution.控方证人.1957.1080p.BluRay.x264.DTS-WiKi</div><div class=\"line\"> 14G\tMovies/Se7en.七宗罪.1995.REMASTERED.1080p.BluRay.x264.DTS-ES-FGT</div><div class=\"line\"> 14G\tMovies/In.Bruges.杀手没有假期.2008.1080p.BluRay.x264.DTS-FGT</div><div class=\"line\"> 13G\tMovies/Saving.Private.Ryan.拯救大兵瑞恩.1998.1080p.BluRay.x264-LEVERAGE</div><div class=\"line\"> 13G\tMovies/Braveheart.勇敢的心.1995.1080p.BluRay.x264-CiNEFiLE</div><div class=\"line\"> 12G\tMovies/The.Hunt.狩猎.2012.DANISH.1080p.BluRay.x264.DTS-FGT</div><div class=\"line\"> 12G\tMovies/The.Dark.Knight.Rises.蝙蝠侠.黑暗骑士崛起.2012.1080p.BluRay.x264-ALLiANCE</div><div class=\"line\"> 12G\tMovies/Life.of.Pi.少年派的奇幻漂流.2012.1080p.BluRay.x264.DTS-FGT</div><div class=\"line\"> 11G\tMovies/The.Lost.City.of.Z.迷失Z城.2016.1080p.BluRay.x264-GECKOS[rarbg]</div><div class=\"line\"> 11G\tMovies/Manhattan.Murder.Mystery.曼哈顿谋杀疑案.1993.1080p.BluRay.X264-AMIABLE[rarbg]</div><div class=\"line\"> 11G\tMovies/Like.Father.Like.Son.如父如子.2013.1080p.BluRay.DTS.x264-PublicHD</div></pre></td></tr></table></figure>\n<h4 id=\"将需要交互的命令的结果重定向到文件中\"><a href=\"#将需要交互的命令的结果重定向到文件中\" class=\"headerlink\" title=\"将需要交互的命令的结果重定向到文件中\"></a>将需要交互的命令的结果重定向到文件中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">telnet zk_ip 2181 | tee -a  -i someFile</div><div class=\"line\"></div><div class=\"line\">envi</div></pre></td></tr></table></figure>\n<h4 id=\"查看上下文切换\"><a href=\"#查看上下文切换\" class=\"headerlink\" title=\"查看上下文切换\"></a>查看上下文切换</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nmon</div></pre></td></tr></table></figure>\n<h4 id=\"查看某个端口的应用程序PID\"><a href=\"#查看某个端口的应用程序PID\" class=\"headerlink\" title=\"查看某个端口的应用程序PID\"></a>查看某个端口的应用程序PID</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ lsof -i:9696</div><div class=\"line\">COMMAND    PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</div><div class=\"line\">kingshard 4994 eric   24u  IPv6 0x2dd5bc594d052b1f      0t0  TCP *:9696 (LISTEN)</div></pre></td></tr></table></figure>\n<h4 id=\"模拟网络抖动\"><a href=\"#模拟网络抖动\" class=\"headerlink\" title=\"模拟网络抖动\"></a>模拟网络抖动</h4><p><a href=\"http://blog.csdn.net/weiweicao0429/article/details/17578011\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/weiweicao0429/article/details/17578011</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># tc qdisc add dev eth0 root netem delay 100ms</span></div><div class=\"line\"><span class=\"comment\"># tc qdisc del dev eth0 root netem delay 100ms</span></div><div class=\"line\"><span class=\"comment\"># tc qdisc del dev eth0 root</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"进程死亡\"><a href=\"#进程死亡\" class=\"headerlink\" title=\"进程死亡\"></a>进程死亡</h4><p>dmesg</p>\n"},{"title":"OS-Kernel-space-and-User-space","date":"2017-11-14T03:17:59.000Z","_content":"\nhttp://www.cnblogs.com/Anker/p/3269106.html\n","source":"_posts/Linux-Kernel-space-and-User-space.md","raw":"---\ntitle: OS-Kernel-space-and-User-space\ndate: 2017-11-14 11:17:59\ntags: Linux\n---\n\nhttp://www.cnblogs.com/Anker/p/3269106.html\n","slug":"Linux-Kernel-space-and-User-space","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz1001q3iq277vqqfxa","content":"<p><a href=\"http://www.cnblogs.com/Anker/p/3269106.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Anker/p/3269106.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.cnblogs.com/Anker/p/3269106.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Anker/p/3269106.html</a></p>\n"},{"title":"Kafka——高速低延时之秘诀「Page Cache」","date":"2017-11-12T14:47:44.000Z","_content":"\n\n> 一切的秘密，都在下面的几篇文章中\n\nhttp://blog.csdn.net/tototuzuoquan/article/details/73437890\n\nhttp://www.jianshu.com/p/eba0067b1e1a\n大神作者\n\nhttps://tech.meituan.com/kafka-fs-design-theory.html\n\n\n_java.nio.channels.FileChannel_\n`public abstract void force(boolean metaData) throws java.io.IOException`\nForces any updates to this channel's file to be written to the storage device that contains it.\nIf this channel's file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash.\nIf the file does not reside on a local device then no such guarantee is made.\nThe metaData parameter can be used to limit the number of I/O operations that this method is required to perform. Passing false for this parameter indicates that only updates to the file's content need be written to storage; passing true indicates that updates to both the file's content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified.\nInvoking this method may cause an I/O operation to occur even if the channel was only opened for reading. Some operating systems, for example, maintain a last-access time as part of a file's metadata, and this time is updated whenever the file is read. Whether or not this is actually done is system-dependent and is therefore unspecified.\nThis method is only guaranteed to force changes that were made to this channel's file via the methods defined in this class. **It may or may not force changes that were made by modifying the content of a mapped byte buffer obtained by invoking the map method. Invoking the force method of the mapped byte buffer will force changes made to the buffer's content to be written.**\n\n_java.nio.MappedByteBuffer_\n`public final MappedByteBuffer force()`\nForces any changes made to this buffer's content to be written to the storage device containing the mapped file.\nIf the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.\nIf the file does not reside on a local device then no such guarantee is made.\nIf this buffer was not mapped in read/write mode (java.nio.channels.FileChannel.MapMode.READ_WRITE) then invoking this method has no effect.\n\n\n### Don't fear the filesystem!\n\nKafka relies heavily on the filesystem for storing and caching messages. There is a general perception that \"disks are slow\" which makes people skeptical that a persistent structure can offer competitive performance. In fact disks are both much slower and much faster than people expect depending on how they are used; and a properly designed disk structure can often be as fast as the network.\n\nThe key fact about disk performance is that the throughput of hard drives has been diverging from the latency of a disk seek for the last decade. As a result the performance of linear writes on a JBOD configuration with six 7200rpm SATA RAID-5 array is about 600MB/sec but the performance of random writes is only about 100k/sec—a difference of over 6000X. These linear reads and writes are the most predictable of all usage patterns, and are heavily optimized by the operating system. A modern operating system provides read-ahead and write-behind techniques that prefetch data in large block multiples and group smaller logical writes into large physical writes. A further discussion of this issue can be found in this ACM Queue article; they actually find that sequential disk access can in some cases be faster than random memory access!\n\n![你想输入的替代文字](Kafka-High-performance-design-with-pagecache/disk_read_write_speed.jpg)\n\nTo compensate for this performance divergence, modern operating systems have become increasingly aggressive in their use of main memory for disk caching. A modern OS will happily divert all free memory to disk caching with little performance penalty when the memory is reclaimed. All disk reads and writes will go through this unified cache. This feature cannot easily be turned off without using direct I/O, so even if a process maintains an in-process cache of the data, this data will likely be duplicated in OS pagecache, effectively storing everything twice.\n\nFurthermore, we are building on top of the JVM, and anyone who has spent any time with Java memory usage knows two things:\n\nThe memory overhead of objects is very high, often doubling the size of the data stored (or worse).\nJava garbage collection becomes increasingly fiddly and slow as the in-heap data increases.\nAs a result of these factors using the filesystem and relying on pagecache is superior to maintaining an in-memory cache or other structure—we at least double the available cache by having automatic access to all free memory, and likely double again by storing a compact byte structure rather than individual objects. Doing so will result in a cache of up to 28-30GB on a 32GB machine without GC penalties. Furthermore, this cache will stay warm even if the service is restarted, whereas the in-process cache will need to be rebuilt in memory (which for a 10GB cache may take 10 minutes) or else it will need to start with a completely cold cache (which likely means terrible initial performance). This also greatly simplifies the code as all logic for maintaining coherency between the cache and filesystem is now in the OS, which tends to do so more efficiently and more correctly than one-off in-process attempts. If your disk usage favors linear reads then read-ahead is effectively pre-populating this cache with useful data on each disk read.\n\nThis suggests a design which is very simple: rather than maintain as much as possible in-memory and flush it all out to the filesystem in a panic when we run out of space, we invert that. All data is immediately written to a persistent log on the filesystem without necessarily flushing to disk. In effect this just means that it is transferred into the kernel's pagecache.\n\nThis style of pagecache-centric design is described in an article on the design of Varnish here (along with a healthy dose of arrogance).\n\n### sendfile\n\nsendfile() copies data between one file descriptor and another.\n\nBecause this copying is done within the kernel, sendfile() is more\nefficient than the combination of read(2) and write(2), which would\nrequire transferring data to and from user space.\n\n![你想输入的替代文字](Kafka-High-performance-design-with-pagecache/read_write.gif)\n\nconventional read and write\n\n\n关于脏页，有什么需要注意的？\n\nhttp://blog.csdn.net/stark_summer/article/details/50144591\n\nTips\n1. Kafka官方并不建议通过Broker端的log.flush.interval.messages和log.flush.interval.ms来强制写盘，认为数据的可靠性应该通过Replica来保证，而强制Flush数据到磁盘会对整体性能产生影响。\n2. 可以通过调整/proc/sys/vm/dirty_background_ratio和/proc/sys/vm/dirty_ratio来调优性能。\na. 脏页率超过第一个指标会启动pdflush开始Flush Dirty PageCache。\nb. 脏页率超过第二个指标会阻塞所有的写操作来进行Flush。\nc. 根据不同的业务需求可以适当的降低dirty_background_ratio和提高dirty_ratio。","source":"_posts/Kafka-High-performance-design-with-pagecache.md","raw":"---\ntitle: Kafka——高速低延时之秘诀「Page Cache」\ndate: 2017-11-12 22:47:44\ntags: Kafka\n---\n\n\n> 一切的秘密，都在下面的几篇文章中\n\nhttp://blog.csdn.net/tototuzuoquan/article/details/73437890\n\nhttp://www.jianshu.com/p/eba0067b1e1a\n大神作者\n\nhttps://tech.meituan.com/kafka-fs-design-theory.html\n\n\n_java.nio.channels.FileChannel_\n`public abstract void force(boolean metaData) throws java.io.IOException`\nForces any updates to this channel's file to be written to the storage device that contains it.\nIf this channel's file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash.\nIf the file does not reside on a local device then no such guarantee is made.\nThe metaData parameter can be used to limit the number of I/O operations that this method is required to perform. Passing false for this parameter indicates that only updates to the file's content need be written to storage; passing true indicates that updates to both the file's content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified.\nInvoking this method may cause an I/O operation to occur even if the channel was only opened for reading. Some operating systems, for example, maintain a last-access time as part of a file's metadata, and this time is updated whenever the file is read. Whether or not this is actually done is system-dependent and is therefore unspecified.\nThis method is only guaranteed to force changes that were made to this channel's file via the methods defined in this class. **It may or may not force changes that were made by modifying the content of a mapped byte buffer obtained by invoking the map method. Invoking the force method of the mapped byte buffer will force changes made to the buffer's content to be written.**\n\n_java.nio.MappedByteBuffer_\n`public final MappedByteBuffer force()`\nForces any changes made to this buffer's content to be written to the storage device containing the mapped file.\nIf the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.\nIf the file does not reside on a local device then no such guarantee is made.\nIf this buffer was not mapped in read/write mode (java.nio.channels.FileChannel.MapMode.READ_WRITE) then invoking this method has no effect.\n\n\n### Don't fear the filesystem!\n\nKafka relies heavily on the filesystem for storing and caching messages. There is a general perception that \"disks are slow\" which makes people skeptical that a persistent structure can offer competitive performance. In fact disks are both much slower and much faster than people expect depending on how they are used; and a properly designed disk structure can often be as fast as the network.\n\nThe key fact about disk performance is that the throughput of hard drives has been diverging from the latency of a disk seek for the last decade. As a result the performance of linear writes on a JBOD configuration with six 7200rpm SATA RAID-5 array is about 600MB/sec but the performance of random writes is only about 100k/sec—a difference of over 6000X. These linear reads and writes are the most predictable of all usage patterns, and are heavily optimized by the operating system. A modern operating system provides read-ahead and write-behind techniques that prefetch data in large block multiples and group smaller logical writes into large physical writes. A further discussion of this issue can be found in this ACM Queue article; they actually find that sequential disk access can in some cases be faster than random memory access!\n\n![你想输入的替代文字](Kafka-High-performance-design-with-pagecache/disk_read_write_speed.jpg)\n\nTo compensate for this performance divergence, modern operating systems have become increasingly aggressive in their use of main memory for disk caching. A modern OS will happily divert all free memory to disk caching with little performance penalty when the memory is reclaimed. All disk reads and writes will go through this unified cache. This feature cannot easily be turned off without using direct I/O, so even if a process maintains an in-process cache of the data, this data will likely be duplicated in OS pagecache, effectively storing everything twice.\n\nFurthermore, we are building on top of the JVM, and anyone who has spent any time with Java memory usage knows two things:\n\nThe memory overhead of objects is very high, often doubling the size of the data stored (or worse).\nJava garbage collection becomes increasingly fiddly and slow as the in-heap data increases.\nAs a result of these factors using the filesystem and relying on pagecache is superior to maintaining an in-memory cache or other structure—we at least double the available cache by having automatic access to all free memory, and likely double again by storing a compact byte structure rather than individual objects. Doing so will result in a cache of up to 28-30GB on a 32GB machine without GC penalties. Furthermore, this cache will stay warm even if the service is restarted, whereas the in-process cache will need to be rebuilt in memory (which for a 10GB cache may take 10 minutes) or else it will need to start with a completely cold cache (which likely means terrible initial performance). This also greatly simplifies the code as all logic for maintaining coherency between the cache and filesystem is now in the OS, which tends to do so more efficiently and more correctly than one-off in-process attempts. If your disk usage favors linear reads then read-ahead is effectively pre-populating this cache with useful data on each disk read.\n\nThis suggests a design which is very simple: rather than maintain as much as possible in-memory and flush it all out to the filesystem in a panic when we run out of space, we invert that. All data is immediately written to a persistent log on the filesystem without necessarily flushing to disk. In effect this just means that it is transferred into the kernel's pagecache.\n\nThis style of pagecache-centric design is described in an article on the design of Varnish here (along with a healthy dose of arrogance).\n\n### sendfile\n\nsendfile() copies data between one file descriptor and another.\n\nBecause this copying is done within the kernel, sendfile() is more\nefficient than the combination of read(2) and write(2), which would\nrequire transferring data to and from user space.\n\n![你想输入的替代文字](Kafka-High-performance-design-with-pagecache/read_write.gif)\n\nconventional read and write\n\n\n关于脏页，有什么需要注意的？\n\nhttp://blog.csdn.net/stark_summer/article/details/50144591\n\nTips\n1. Kafka官方并不建议通过Broker端的log.flush.interval.messages和log.flush.interval.ms来强制写盘，认为数据的可靠性应该通过Replica来保证，而强制Flush数据到磁盘会对整体性能产生影响。\n2. 可以通过调整/proc/sys/vm/dirty_background_ratio和/proc/sys/vm/dirty_ratio来调优性能。\na. 脏页率超过第一个指标会启动pdflush开始Flush Dirty PageCache。\nb. 脏页率超过第二个指标会阻塞所有的写操作来进行Flush。\nc. 根据不同的业务需求可以适当的降低dirty_background_ratio和提高dirty_ratio。","slug":"Kafka-High-performance-design-with-pagecache","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz2001s3iq2vlvq2mg0","content":"<blockquote>\n<p>一切的秘密，都在下面的几篇文章中</p>\n</blockquote>\n<p><a href=\"http://blog.csdn.net/tototuzuoquan/article/details/73437890\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/tototuzuoquan/article/details/73437890</a></p>\n<p><a href=\"http://www.jianshu.com/p/eba0067b1e1a\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/eba0067b1e1a</a><br>大神作者</p>\n<p><a href=\"https://tech.meituan.com/kafka-fs-design-theory.html\" target=\"_blank\" rel=\"external\">https://tech.meituan.com/kafka-fs-design-theory.html</a></p>\n<p><em>java.nio.channels.FileChannel</em><br><code>public abstract void force(boolean metaData) throws java.io.IOException</code><br>Forces any updates to this channel’s file to be written to the storage device that contains it.<br>If this channel’s file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash.<br>If the file does not reside on a local device then no such guarantee is made.<br>The metaData parameter can be used to limit the number of I/O operations that this method is required to perform. Passing false for this parameter indicates that only updates to the file’s content need be written to storage; passing true indicates that updates to both the file’s content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified.<br>Invoking this method may cause an I/O operation to occur even if the channel was only opened for reading. Some operating systems, for example, maintain a last-access time as part of a file’s metadata, and this time is updated whenever the file is read. Whether or not this is actually done is system-dependent and is therefore unspecified.<br>This method is only guaranteed to force changes that were made to this channel’s file via the methods defined in this class. <strong>It may or may not force changes that were made by modifying the content of a mapped byte buffer obtained by invoking the map method. Invoking the force method of the mapped byte buffer will force changes made to the buffer’s content to be written.</strong></p>\n<p><em>java.nio.MappedByteBuffer</em><br><code>public final MappedByteBuffer force()</code><br>Forces any changes made to this buffer’s content to be written to the storage device containing the mapped file.<br>If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.<br>If the file does not reside on a local device then no such guarantee is made.<br>If this buffer was not mapped in read/write mode (java.nio.channels.FileChannel.MapMode.READ_WRITE) then invoking this method has no effect.</p>\n<h3 id=\"Don’t-fear-the-filesystem\"><a href=\"#Don’t-fear-the-filesystem\" class=\"headerlink\" title=\"Don’t fear the filesystem!\"></a>Don’t fear the filesystem!</h3><p>Kafka relies heavily on the filesystem for storing and caching messages. There is a general perception that “disks are slow” which makes people skeptical that a persistent structure can offer competitive performance. In fact disks are both much slower and much faster than people expect depending on how they are used; and a properly designed disk structure can often be as fast as the network.</p>\n<p>The key fact about disk performance is that the throughput of hard drives has been diverging from the latency of a disk seek for the last decade. As a result the performance of linear writes on a JBOD configuration with six 7200rpm SATA RAID-5 array is about 600MB/sec but the performance of random writes is only about 100k/sec—a difference of over 6000X. These linear reads and writes are the most predictable of all usage patterns, and are heavily optimized by the operating system. A modern operating system provides read-ahead and write-behind techniques that prefetch data in large block multiples and group smaller logical writes into large physical writes. A further discussion of this issue can be found in this ACM Queue article; they actually find that sequential disk access can in some cases be faster than random memory access!</p>\n<p><img src=\"/2017/11/12/Kafka-High-performance-design-with-pagecache/disk_read_write_speed.jpg\" alt=\"你想输入的替代文字\"></p>\n<p>To compensate for this performance divergence, modern operating systems have become increasingly aggressive in their use of main memory for disk caching. A modern OS will happily divert all free memory to disk caching with little performance penalty when the memory is reclaimed. All disk reads and writes will go through this unified cache. This feature cannot easily be turned off without using direct I/O, so even if a process maintains an in-process cache of the data, this data will likely be duplicated in OS pagecache, effectively storing everything twice.</p>\n<p>Furthermore, we are building on top of the JVM, and anyone who has spent any time with Java memory usage knows two things:</p>\n<p>The memory overhead of objects is very high, often doubling the size of the data stored (or worse).<br>Java garbage collection becomes increasingly fiddly and slow as the in-heap data increases.<br>As a result of these factors using the filesystem and relying on pagecache is superior to maintaining an in-memory cache or other structure—we at least double the available cache by having automatic access to all free memory, and likely double again by storing a compact byte structure rather than individual objects. Doing so will result in a cache of up to 28-30GB on a 32GB machine without GC penalties. Furthermore, this cache will stay warm even if the service is restarted, whereas the in-process cache will need to be rebuilt in memory (which for a 10GB cache may take 10 minutes) or else it will need to start with a completely cold cache (which likely means terrible initial performance). This also greatly simplifies the code as all logic for maintaining coherency between the cache and filesystem is now in the OS, which tends to do so more efficiently and more correctly than one-off in-process attempts. If your disk usage favors linear reads then read-ahead is effectively pre-populating this cache with useful data on each disk read.</p>\n<p>This suggests a design which is very simple: rather than maintain as much as possible in-memory and flush it all out to the filesystem in a panic when we run out of space, we invert that. All data is immediately written to a persistent log on the filesystem without necessarily flushing to disk. In effect this just means that it is transferred into the kernel’s pagecache.</p>\n<p>This style of pagecache-centric design is described in an article on the design of Varnish here (along with a healthy dose of arrogance).</p>\n<h3 id=\"sendfile\"><a href=\"#sendfile\" class=\"headerlink\" title=\"sendfile\"></a>sendfile</h3><p>sendfile() copies data between one file descriptor and another.</p>\n<p>Because this copying is done within the kernel, sendfile() is more<br>efficient than the combination of read(2) and write(2), which would<br>require transferring data to and from user space.</p>\n<p><img src=\"/2017/11/12/Kafka-High-performance-design-with-pagecache/read_write.gif\" alt=\"你想输入的替代文字\"></p>\n<p>conventional read and write</p>\n<p>关于脏页，有什么需要注意的？</p>\n<p><a href=\"http://blog.csdn.net/stark_summer/article/details/50144591\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/stark_summer/article/details/50144591</a></p>\n<p>Tips</p>\n<ol>\n<li>Kafka官方并不建议通过Broker端的log.flush.interval.messages和log.flush.interval.ms来强制写盘，认为数据的可靠性应该通过Replica来保证，而强制Flush数据到磁盘会对整体性能产生影响。</li>\n<li>可以通过调整/proc/sys/vm/dirty_background_ratio和/proc/sys/vm/dirty_ratio来调优性能。<br>a. 脏页率超过第一个指标会启动pdflush开始Flush Dirty PageCache。<br>b. 脏页率超过第二个指标会阻塞所有的写操作来进行Flush。<br>c. 根据不同的业务需求可以适当的降低dirty_background_ratio和提高dirty_ratio。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一切的秘密，都在下面的几篇文章中</p>\n</blockquote>\n<p><a href=\"http://blog.csdn.net/tototuzuoquan/article/details/73437890\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/tototuzuoquan/article/details/73437890</a></p>\n<p><a href=\"http://www.jianshu.com/p/eba0067b1e1a\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/eba0067b1e1a</a><br>大神作者</p>\n<p><a href=\"https://tech.meituan.com/kafka-fs-design-theory.html\" target=\"_blank\" rel=\"external\">https://tech.meituan.com/kafka-fs-design-theory.html</a></p>\n<p><em>java.nio.channels.FileChannel</em><br><code>public abstract void force(boolean metaData) throws java.io.IOException</code><br>Forces any updates to this channel’s file to be written to the storage device that contains it.<br>If this channel’s file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash.<br>If the file does not reside on a local device then no such guarantee is made.<br>The metaData parameter can be used to limit the number of I/O operations that this method is required to perform. Passing false for this parameter indicates that only updates to the file’s content need be written to storage; passing true indicates that updates to both the file’s content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified.<br>Invoking this method may cause an I/O operation to occur even if the channel was only opened for reading. Some operating systems, for example, maintain a last-access time as part of a file’s metadata, and this time is updated whenever the file is read. Whether or not this is actually done is system-dependent and is therefore unspecified.<br>This method is only guaranteed to force changes that were made to this channel’s file via the methods defined in this class. <strong>It may or may not force changes that were made by modifying the content of a mapped byte buffer obtained by invoking the map method. Invoking the force method of the mapped byte buffer will force changes made to the buffer’s content to be written.</strong></p>\n<p><em>java.nio.MappedByteBuffer</em><br><code>public final MappedByteBuffer force()</code><br>Forces any changes made to this buffer’s content to be written to the storage device containing the mapped file.<br>If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.<br>If the file does not reside on a local device then no such guarantee is made.<br>If this buffer was not mapped in read/write mode (java.nio.channels.FileChannel.MapMode.READ_WRITE) then invoking this method has no effect.</p>\n<h3 id=\"Don’t-fear-the-filesystem\"><a href=\"#Don’t-fear-the-filesystem\" class=\"headerlink\" title=\"Don’t fear the filesystem!\"></a>Don’t fear the filesystem!</h3><p>Kafka relies heavily on the filesystem for storing and caching messages. There is a general perception that “disks are slow” which makes people skeptical that a persistent structure can offer competitive performance. In fact disks are both much slower and much faster than people expect depending on how they are used; and a properly designed disk structure can often be as fast as the network.</p>\n<p>The key fact about disk performance is that the throughput of hard drives has been diverging from the latency of a disk seek for the last decade. As a result the performance of linear writes on a JBOD configuration with six 7200rpm SATA RAID-5 array is about 600MB/sec but the performance of random writes is only about 100k/sec—a difference of over 6000X. These linear reads and writes are the most predictable of all usage patterns, and are heavily optimized by the operating system. A modern operating system provides read-ahead and write-behind techniques that prefetch data in large block multiples and group smaller logical writes into large physical writes. A further discussion of this issue can be found in this ACM Queue article; they actually find that sequential disk access can in some cases be faster than random memory access!</p>\n<p><img src=\"/2017/11/12/Kafka-High-performance-design-with-pagecache/disk_read_write_speed.jpg\" alt=\"你想输入的替代文字\"></p>\n<p>To compensate for this performance divergence, modern operating systems have become increasingly aggressive in their use of main memory for disk caching. A modern OS will happily divert all free memory to disk caching with little performance penalty when the memory is reclaimed. All disk reads and writes will go through this unified cache. This feature cannot easily be turned off without using direct I/O, so even if a process maintains an in-process cache of the data, this data will likely be duplicated in OS pagecache, effectively storing everything twice.</p>\n<p>Furthermore, we are building on top of the JVM, and anyone who has spent any time with Java memory usage knows two things:</p>\n<p>The memory overhead of objects is very high, often doubling the size of the data stored (or worse).<br>Java garbage collection becomes increasingly fiddly and slow as the in-heap data increases.<br>As a result of these factors using the filesystem and relying on pagecache is superior to maintaining an in-memory cache or other structure—we at least double the available cache by having automatic access to all free memory, and likely double again by storing a compact byte structure rather than individual objects. Doing so will result in a cache of up to 28-30GB on a 32GB machine without GC penalties. Furthermore, this cache will stay warm even if the service is restarted, whereas the in-process cache will need to be rebuilt in memory (which for a 10GB cache may take 10 minutes) or else it will need to start with a completely cold cache (which likely means terrible initial performance). This also greatly simplifies the code as all logic for maintaining coherency between the cache and filesystem is now in the OS, which tends to do so more efficiently and more correctly than one-off in-process attempts. If your disk usage favors linear reads then read-ahead is effectively pre-populating this cache with useful data on each disk read.</p>\n<p>This suggests a design which is very simple: rather than maintain as much as possible in-memory and flush it all out to the filesystem in a panic when we run out of space, we invert that. All data is immediately written to a persistent log on the filesystem without necessarily flushing to disk. In effect this just means that it is transferred into the kernel’s pagecache.</p>\n<p>This style of pagecache-centric design is described in an article on the design of Varnish here (along with a healthy dose of arrogance).</p>\n<h3 id=\"sendfile\"><a href=\"#sendfile\" class=\"headerlink\" title=\"sendfile\"></a>sendfile</h3><p>sendfile() copies data between one file descriptor and another.</p>\n<p>Because this copying is done within the kernel, sendfile() is more<br>efficient than the combination of read(2) and write(2), which would<br>require transferring data to and from user space.</p>\n<p><img src=\"/2017/11/12/Kafka-High-performance-design-with-pagecache/read_write.gif\" alt=\"你想输入的替代文字\"></p>\n<p>conventional read and write</p>\n<p>关于脏页，有什么需要注意的？</p>\n<p><a href=\"http://blog.csdn.net/stark_summer/article/details/50144591\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/stark_summer/article/details/50144591</a></p>\n<p>Tips</p>\n<ol>\n<li>Kafka官方并不建议通过Broker端的log.flush.interval.messages和log.flush.interval.ms来强制写盘，认为数据的可靠性应该通过Replica来保证，而强制Flush数据到磁盘会对整体性能产生影响。</li>\n<li>可以通过调整/proc/sys/vm/dirty_background_ratio和/proc/sys/vm/dirty_ratio来调优性能。<br>a. 脏页率超过第一个指标会启动pdflush开始Flush Dirty PageCache。<br>b. 脏页率超过第二个指标会阻塞所有的写操作来进行Flush。<br>c. 根据不同的业务需求可以适当的降低dirty_background_ratio和提高dirty_ratio。</li>\n</ol>\n"},{"title":"Linux-Mmap","date":"2017-11-20T09:22:52.000Z","_content":"\nhttp://xiaoz5919.iteye.com/blog/2093323","source":"_posts/Linux-Mmap.md","raw":"---\ntitle: Linux-Mmap\ndate: 2017-11-20 17:22:52\ntags: Linux\n---\n\nhttp://xiaoz5919.iteye.com/blog/2093323","slug":"Linux-Mmap","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz2001u3iq25sb2tc7q","content":"<p><a href=\"http://xiaoz5919.iteye.com/blog/2093323\" target=\"_blank\" rel=\"external\">http://xiaoz5919.iteye.com/blog/2093323</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://xiaoz5919.iteye.com/blog/2093323\" target=\"_blank\" rel=\"external\">http://xiaoz5919.iteye.com/blog/2093323</a></p>\n"},{"title":"Linux-Zero-Copy","date":"2017-11-16T07:26:51.000Z","_content":"\n如今的系统，感觉没有用到 Zero copy 都不好意思拿出手\n\n\n### 参考资料\nhttps://www.ibm.com/developerworks/library/j-zerocopy/\nhttp://www.cnblogs.com/zemliu/p/3695549.html","source":"_posts/Linux-Zero-Copy.md","raw":"---\ntitle: Linux-Zero-Copy\ndate: 2017-11-16 15:26:51\ntags: Linux\n---\n\n如今的系统，感觉没有用到 Zero copy 都不好意思拿出手\n\n\n### 参考资料\nhttps://www.ibm.com/developerworks/library/j-zerocopy/\nhttp://www.cnblogs.com/zemliu/p/3695549.html","slug":"Linux-Zero-Copy","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz4001w3iq2ekv8tzku","content":"<p>如今的系统，感觉没有用到 Zero copy 都不好意思拿出手</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://www.ibm.com/developerworks/library/j-zerocopy/\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/library/j-zerocopy/</a><br><a href=\"http://www.cnblogs.com/zemliu/p/3695549.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/zemliu/p/3695549.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>如今的系统，感觉没有用到 Zero copy 都不好意思拿出手</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://www.ibm.com/developerworks/library/j-zerocopy/\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/library/j-zerocopy/</a><br><a href=\"http://www.cnblogs.com/zemliu/p/3695549.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/zemliu/p/3695549.html</a></p>\n"},{"title":"OS-sync-async-blocking-noblocking","date":"2017-11-01T07:01:02.000Z","_content":"\nhttps://github.com/calidion/calidion.github.io/issues/40","source":"_posts/Linux-sync-async-blocking-noblocking.md","raw":"---\ntitle: OS-sync-async-blocking-noblocking\ndate: 2017-11-01 15:01:02\ntags: Linux\n---\n\nhttps://github.com/calidion/calidion.github.io/issues/40","slug":"Linux-sync-async-blocking-noblocking","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz4001y3iq21upnlcfx","content":"<p><a href=\"https://github.com/calidion/calidion.github.io/issues/40\" target=\"_blank\" rel=\"external\">https://github.com/calidion/calidion.github.io/issues/40</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/calidion/calidion.github.io/issues/40\" target=\"_blank\" rel=\"external\">https://github.com/calidion/calidion.github.io/issues/40</a></p>\n"},{"title":"MySQL Explain 整理","date":"2017-09-10T05:11:34.000Z","_content":"\n## select id\n\n``` sql\nexplain select * from student where stu_id = '1000003';\nexplain delete from student where stu_id = '11111';\n#数值越大越先执行\nexplain select * from (select * from student where stu_id = '1000003') tmp; \n#只有union的结果是没有 select id 的\nexplain select * from student where stu_id = '1000003' union select * from student where stu_id = '1000004';\n```\n\nMore info: [MySQL DOC](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)","source":"_posts/MySQL-Explain.md","raw":"---\ntitle: MySQL Explain 整理\ndate: 2017-09-10 13:11:34\ntags: MySQL\n---\n\n## select id\n\n``` sql\nexplain select * from student where stu_id = '1000003';\nexplain delete from student where stu_id = '11111';\n#数值越大越先执行\nexplain select * from (select * from student where stu_id = '1000003') tmp; \n#只有union的结果是没有 select id 的\nexplain select * from student where stu_id = '1000003' union select * from student where stu_id = '1000004';\n```\n\nMore info: [MySQL DOC](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)","slug":"MySQL-Explain","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz600203iq26rajsf3m","content":"<h2 id=\"select-id\"><a href=\"#select-id\" class=\"headerlink\" title=\"select id\"></a>select id</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> stu_id = <span class=\"string\">'1000003'</span>;</div><div class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> stu_id = <span class=\"string\">'11111'</span>;</div><div class=\"line\">#数值越大越先执行</div><div class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> (<span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> stu_id = <span class=\"string\">'1000003'</span>) tmp; </div><div class=\"line\">#只有union的结果是没有 select id 的</div><div class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> stu_id = <span class=\"string\">'1000003'</span> <span class=\"keyword\">union</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> stu_id = <span class=\"string\">'1000004'</span>;</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://dev.mysql.com/doc/refman/5.7/en/explain-output.html\" target=\"_blank\" rel=\"external\">MySQL DOC</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"select-id\"><a href=\"#select-id\" class=\"headerlink\" title=\"select id\"></a>select id</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> stu_id = <span class=\"string\">'1000003'</span>;</div><div class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> stu_id = <span class=\"string\">'11111'</span>;</div><div class=\"line\">#数值越大越先执行</div><div class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> (<span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> stu_id = <span class=\"string\">'1000003'</span>) tmp; </div><div class=\"line\">#只有union的结果是没有 select id 的</div><div class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> stu_id = <span class=\"string\">'1000003'</span> <span class=\"keyword\">union</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> stu_id = <span class=\"string\">'1000004'</span>;</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://dev.mysql.com/doc/refman/5.7/en/explain-output.html\" target=\"_blank\" rel=\"external\">MySQL DOC</a></p>\n"},{"title":"Netty-Bind-Port","date":"2017-12-04T02:05:04.000Z","_content":"\n``` java\n@Override\npublic void execute(Runnable task) {\n    if (task == null) {\n        throw new NullPointerException(\"task\");\n    }\n\n    boolean inEventLoop = inEventLoop();\n    if (inEventLoop) {\n        addTask(task);\n    } else {\n        // 启动 eventLoop\n        startThread();\n        addTask(task);\n        if (isShutdown() && removeTask(task)) {\n            reject();\n        }\n    }\n\n    if (!addTaskWakesUp && wakesUpForTask(task)) {\n        wakeup(inEventLoop);\n    }\n}\n\nprivate void doStartThread() {\n    assert thread == null;\n    executor.execute(new Runnable() {\n        @Override\n        public void run() {\n            thread = Thread.currentThread();\n            if (interrupted) {\n                thread.interrupt();\n            }\n\n            boolean success = false;\n            updateLastExecutionTime();\n            try {\n                SingleThreadEventExecutor.this.run();\n                success = true;\n            } catch (Throwable t) {\n                logger.warn(\"Unexpected exception from an event executor: \", t);\n            } finally {\n                for (;;) {\n                    int oldState = STATE_UPDATER.get(SingleThreadEventExecutor.this);\n                    if (oldState >= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(\n                            SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) {\n                        break;\n                    }\n                }\n\n                // Check if confirmShutdown() was called at the end of the loop.\n                if (success && gracefulShutdownStartTime == 0) {\n                    logger.error(\"Buggy \" + EventExecutor.class.getSimpleName() + \" implementation; \" +\n                            SingleThreadEventExecutor.class.getSimpleName() + \".confirmShutdown() must be called \" +\n                            \"before run() implementation terminates.\");\n                }\n\n                try {\n                    // Run all remaining tasks and shutdown hooks.\n                    for (;;) {\n                        if (confirmShutdown()) {\n                            break;\n                        }\n                    }\n                } finally {\n                    try {\n                        cleanup();\n                    } finally {\n                        STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED);\n                        threadLock.release();\n                        if (!taskQueue.isEmpty()) {\n                            logger.warn(\n                                    \"An event executor terminated with \" +\n                                            \"non-empty task queue (\" + taskQueue.size() + ')');\n                        }\n\n                        terminationFuture.setSuccess(null);\n                    }\n                }\n            }\n        }\n    });\n}\n\n\n@Override\nprotected void run() {\n    for (;;) {\n        try {\n            switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {\n                case SelectStrategy.CONTINUE:\n                    continue;\n                case SelectStrategy.SELECT:\n                    select(wakenUp.getAndSet(false));\n\n                    // 'wakenUp.compareAndSet(false, true)' is always evaluated\n                    // before calling 'selector.wakeup()' to reduce the wake-up\n                    // overhead. (Selector.wakeup() is an expensive operation.)\n                    //\n                    // However, there is a race condition in this approach.\n                    // The race condition is triggered when 'wakenUp' is set to\n                    // true too early.\n                    //\n                    // 'wakenUp' is set to true too early if:\n                    // 1) Selector is waken up between 'wakenUp.set(false)' and\n                    //    'selector.select(...)'. (BAD)\n                    // 2) Selector is waken up between 'selector.select(...)' and\n                    //    'if (wakenUp.get()) { ... }'. (OK)\n                    //\n                    // In the first case, 'wakenUp' is set to true and the\n                    // following 'selector.select(...)' will wake up immediately.\n                    // Until 'wakenUp' is set to false again in the next round,\n                    // 'wakenUp.compareAndSet(false, true)' will fail, and therefore\n                    // any attempt to wake up the Selector will fail, too, causing\n                    // the following 'selector.select(...)' call to block\n                    // unnecessarily.\n                    //\n                    // To fix this problem, we wake up the selector again if wakenUp\n                    // is true immediately after selector.select(...).\n                    // It is inefficient in that it wakes up the selector for both\n                    // the first case (BAD - wake-up required) and the second case\n                    // (OK - no wake-up required).\n\n                    if (wakenUp.get()) {\n                        selector.wakeup();\n                    }\n                default:\n                    // fallthrough\n            }\n\n            cancelledKeys = 0;\n            needsToSelectAgain = false;\n            final int ioRatio = this.ioRatio;\n            if (ioRatio == 100) {\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // Ensure we always run tasks.\n                    runAllTasks();\n                }\n            } else {\n                final long ioStartTime = System.nanoTime();\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // Ensure we always run tasks.\n                    final long ioTime = System.nanoTime() - ioStartTime;\n                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n        // Always handle shutdown even if the loop processing threw an exception.\n        try {\n            if (isShuttingDown()) {\n                closeAll();\n                if (confirmShutdown()) {\n                    return;\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n    }\n}\n```\n\n``` java\nfinal long ioStartTime = System.nanoTime();\ntry {\n    processSelectedKeys();\n} finally {\n    // Ensure we always run tasks.\n    final long ioTime = System.nanoTime() - ioStartTime;\n    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n}\n```\n\nhttps://github.com/netty/netty/issues/6058\nprocessSelectedKeys();指的是IO任务\nrunAllTasks();指的是除了IO的任务\n\nioTime / (n + ioTime) = ioRatio / (100)\n=> n = ioTime * (100 - ioRatio) / ioRatio\n\nhttp://budairenqin.iteye.com/blog/2215896","source":"_posts/Netty-Bind-Port.md","raw":"---\ntitle: Netty-Bind-Port\ndate: 2017-12-04 10:05:04\ntags: Netty\n---\n\n``` java\n@Override\npublic void execute(Runnable task) {\n    if (task == null) {\n        throw new NullPointerException(\"task\");\n    }\n\n    boolean inEventLoop = inEventLoop();\n    if (inEventLoop) {\n        addTask(task);\n    } else {\n        // 启动 eventLoop\n        startThread();\n        addTask(task);\n        if (isShutdown() && removeTask(task)) {\n            reject();\n        }\n    }\n\n    if (!addTaskWakesUp && wakesUpForTask(task)) {\n        wakeup(inEventLoop);\n    }\n}\n\nprivate void doStartThread() {\n    assert thread == null;\n    executor.execute(new Runnable() {\n        @Override\n        public void run() {\n            thread = Thread.currentThread();\n            if (interrupted) {\n                thread.interrupt();\n            }\n\n            boolean success = false;\n            updateLastExecutionTime();\n            try {\n                SingleThreadEventExecutor.this.run();\n                success = true;\n            } catch (Throwable t) {\n                logger.warn(\"Unexpected exception from an event executor: \", t);\n            } finally {\n                for (;;) {\n                    int oldState = STATE_UPDATER.get(SingleThreadEventExecutor.this);\n                    if (oldState >= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(\n                            SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) {\n                        break;\n                    }\n                }\n\n                // Check if confirmShutdown() was called at the end of the loop.\n                if (success && gracefulShutdownStartTime == 0) {\n                    logger.error(\"Buggy \" + EventExecutor.class.getSimpleName() + \" implementation; \" +\n                            SingleThreadEventExecutor.class.getSimpleName() + \".confirmShutdown() must be called \" +\n                            \"before run() implementation terminates.\");\n                }\n\n                try {\n                    // Run all remaining tasks and shutdown hooks.\n                    for (;;) {\n                        if (confirmShutdown()) {\n                            break;\n                        }\n                    }\n                } finally {\n                    try {\n                        cleanup();\n                    } finally {\n                        STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED);\n                        threadLock.release();\n                        if (!taskQueue.isEmpty()) {\n                            logger.warn(\n                                    \"An event executor terminated with \" +\n                                            \"non-empty task queue (\" + taskQueue.size() + ')');\n                        }\n\n                        terminationFuture.setSuccess(null);\n                    }\n                }\n            }\n        }\n    });\n}\n\n\n@Override\nprotected void run() {\n    for (;;) {\n        try {\n            switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {\n                case SelectStrategy.CONTINUE:\n                    continue;\n                case SelectStrategy.SELECT:\n                    select(wakenUp.getAndSet(false));\n\n                    // 'wakenUp.compareAndSet(false, true)' is always evaluated\n                    // before calling 'selector.wakeup()' to reduce the wake-up\n                    // overhead. (Selector.wakeup() is an expensive operation.)\n                    //\n                    // However, there is a race condition in this approach.\n                    // The race condition is triggered when 'wakenUp' is set to\n                    // true too early.\n                    //\n                    // 'wakenUp' is set to true too early if:\n                    // 1) Selector is waken up between 'wakenUp.set(false)' and\n                    //    'selector.select(...)'. (BAD)\n                    // 2) Selector is waken up between 'selector.select(...)' and\n                    //    'if (wakenUp.get()) { ... }'. (OK)\n                    //\n                    // In the first case, 'wakenUp' is set to true and the\n                    // following 'selector.select(...)' will wake up immediately.\n                    // Until 'wakenUp' is set to false again in the next round,\n                    // 'wakenUp.compareAndSet(false, true)' will fail, and therefore\n                    // any attempt to wake up the Selector will fail, too, causing\n                    // the following 'selector.select(...)' call to block\n                    // unnecessarily.\n                    //\n                    // To fix this problem, we wake up the selector again if wakenUp\n                    // is true immediately after selector.select(...).\n                    // It is inefficient in that it wakes up the selector for both\n                    // the first case (BAD - wake-up required) and the second case\n                    // (OK - no wake-up required).\n\n                    if (wakenUp.get()) {\n                        selector.wakeup();\n                    }\n                default:\n                    // fallthrough\n            }\n\n            cancelledKeys = 0;\n            needsToSelectAgain = false;\n            final int ioRatio = this.ioRatio;\n            if (ioRatio == 100) {\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // Ensure we always run tasks.\n                    runAllTasks();\n                }\n            } else {\n                final long ioStartTime = System.nanoTime();\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // Ensure we always run tasks.\n                    final long ioTime = System.nanoTime() - ioStartTime;\n                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n        // Always handle shutdown even if the loop processing threw an exception.\n        try {\n            if (isShuttingDown()) {\n                closeAll();\n                if (confirmShutdown()) {\n                    return;\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n    }\n}\n```\n\n``` java\nfinal long ioStartTime = System.nanoTime();\ntry {\n    processSelectedKeys();\n} finally {\n    // Ensure we always run tasks.\n    final long ioTime = System.nanoTime() - ioStartTime;\n    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n}\n```\n\nhttps://github.com/netty/netty/issues/6058\nprocessSelectedKeys();指的是IO任务\nrunAllTasks();指的是除了IO的任务\n\nioTime / (n + ioTime) = ioRatio / (100)\n=> n = ioTime * (100 - ioRatio) / ioRatio\n\nhttp://budairenqin.iteye.com/blog/2215896","slug":"Netty-Bind-Port","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz600223iq21j7hapdn","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable task)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"task\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">boolean</span> inEventLoop = inEventLoop();</div><div class=\"line\">    <span class=\"keyword\">if</span> (inEventLoop) &#123;</div><div class=\"line\">        addTask(task);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 启动 eventLoop</span></div><div class=\"line\">        startThread();</div><div class=\"line\">        addTask(task);</div><div class=\"line\">        <span class=\"keyword\">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class=\"line\">            reject();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class=\"line\">        wakeup(inEventLoop);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doStartThread</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">assert</span> thread == <span class=\"keyword\">null</span>;</div><div class=\"line\">    executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            thread = Thread.currentThread();</div><div class=\"line\">            <span class=\"keyword\">if</span> (interrupted) &#123;</div><div class=\"line\">                thread.interrupt();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">boolean</span> success = <span class=\"keyword\">false</span>;</div><div class=\"line\">            updateLastExecutionTime();</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                SingleThreadEventExecutor.<span class=\"keyword\">this</span>.run();</div><div class=\"line\">                success = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</div><div class=\"line\">                logger.warn(<span class=\"string\">\"Unexpected exception from an event executor: \"</span>, t);</div><div class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">                    <span class=\"keyword\">int</span> oldState = STATE_UPDATER.get(SingleThreadEventExecutor.<span class=\"keyword\">this</span>);</div><div class=\"line\">                    <span class=\"keyword\">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</div><div class=\"line\">                            SingleThreadEventExecutor.<span class=\"keyword\">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Check if confirmShutdown() was called at the end of the loop.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (success &amp;&amp; gracefulShutdownStartTime == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    logger.error(<span class=\"string\">\"Buggy \"</span> + EventExecutor.class.getSimpleName() + <span class=\"string\">\" implementation; \"</span> +</div><div class=\"line\">                            SingleThreadEventExecutor.class.getSimpleName() + <span class=\"string\">\".confirmShutdown() must be called \"</span> +</div><div class=\"line\">                            <span class=\"string\">\"before run() implementation terminates.\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    <span class=\"comment\">// Run all remaining tasks and shutdown hooks.</span></div><div class=\"line\">                    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (confirmShutdown()) &#123;</div><div class=\"line\">                            <span class=\"keyword\">break</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        cleanup();</div><div class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class=\"keyword\">this</span>, ST_TERMINATED);</div><div class=\"line\">                        threadLock.release();</div><div class=\"line\">                        <span class=\"keyword\">if</span> (!taskQueue.isEmpty()) &#123;</div><div class=\"line\">                            logger.warn(</div><div class=\"line\">                                    <span class=\"string\">\"An event executor terminated with \"</span> +</div><div class=\"line\">                                            <span class=\"string\">\"non-empty task queue (\"</span> + taskQueue.size() + <span class=\"string\">')'</span>);</div><div class=\"line\">                        &#125;</div><div class=\"line\"></div><div class=\"line\">                        terminationFuture.setSuccess(<span class=\"keyword\">null</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> SelectStrategy.CONTINUE:</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> SelectStrategy.SELECT:</div><div class=\"line\">                    select(wakenUp.getAndSet(<span class=\"keyword\">false</span>));</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"comment\">// 'wakenUp.compareAndSet(false, true)' is always evaluated</span></div><div class=\"line\">                    <span class=\"comment\">// before calling 'selector.wakeup()' to reduce the wake-up</span></div><div class=\"line\">                    <span class=\"comment\">// overhead. (Selector.wakeup() is an expensive operation.)</span></div><div class=\"line\">                    <span class=\"comment\">//</span></div><div class=\"line\">                    <span class=\"comment\">// However, there is a race condition in this approach.</span></div><div class=\"line\">                    <span class=\"comment\">// The race condition is triggered when 'wakenUp' is set to</span></div><div class=\"line\">                    <span class=\"comment\">// true too early.</span></div><div class=\"line\">                    <span class=\"comment\">//</span></div><div class=\"line\">                    <span class=\"comment\">// 'wakenUp' is set to true too early if:</span></div><div class=\"line\">                    <span class=\"comment\">// 1) Selector is waken up between 'wakenUp.set(false)' and</span></div><div class=\"line\">                    <span class=\"comment\">//    'selector.select(...)'. (BAD)</span></div><div class=\"line\">                    <span class=\"comment\">// 2) Selector is waken up between 'selector.select(...)' and</span></div><div class=\"line\">                    <span class=\"comment\">//    'if (wakenUp.get()) &#123; ... &#125;'. (OK)</span></div><div class=\"line\">                    <span class=\"comment\">//</span></div><div class=\"line\">                    <span class=\"comment\">// In the first case, 'wakenUp' is set to true and the</span></div><div class=\"line\">                    <span class=\"comment\">// following 'selector.select(...)' will wake up immediately.</span></div><div class=\"line\">                    <span class=\"comment\">// Until 'wakenUp' is set to false again in the next round,</span></div><div class=\"line\">                    <span class=\"comment\">// 'wakenUp.compareAndSet(false, true)' will fail, and therefore</span></div><div class=\"line\">                    <span class=\"comment\">// any attempt to wake up the Selector will fail, too, causing</span></div><div class=\"line\">                    <span class=\"comment\">// the following 'selector.select(...)' call to block</span></div><div class=\"line\">                    <span class=\"comment\">// unnecessarily.</span></div><div class=\"line\">                    <span class=\"comment\">//</span></div><div class=\"line\">                    <span class=\"comment\">// To fix this problem, we wake up the selector again if wakenUp</span></div><div class=\"line\">                    <span class=\"comment\">// is true immediately after selector.select(...).</span></div><div class=\"line\">                    <span class=\"comment\">// It is inefficient in that it wakes up the selector for both</span></div><div class=\"line\">                    <span class=\"comment\">// the first case (BAD - wake-up required) and the second case</span></div><div class=\"line\">                    <span class=\"comment\">// (OK - no wake-up required).</span></div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">if</span> (wakenUp.get()) &#123;</div><div class=\"line\">                        selector.wakeup();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">default</span>:</div><div class=\"line\">                    <span class=\"comment\">// fallthrough</span></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            cancelledKeys = <span class=\"number\">0</span>;</div><div class=\"line\">            needsToSelectAgain = <span class=\"keyword\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ioRatio = <span class=\"keyword\">this</span>.ioRatio;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ioRatio == <span class=\"number\">100</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    processSelectedKeys();</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    <span class=\"comment\">// Ensure we always run tasks.</span></div><div class=\"line\">                    runAllTasks();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ioStartTime = System.nanoTime();</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    processSelectedKeys();</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    <span class=\"comment\">// Ensure we always run tasks.</span></div><div class=\"line\">                    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ioTime = System.nanoTime() - ioStartTime;</div><div class=\"line\">                    runAllTasks(ioTime * (<span class=\"number\">100</span> - ioRatio) / ioRatio);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</div><div class=\"line\">            handleLoopException(t);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// Always handle shutdown even if the loop processing threw an exception.</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (isShuttingDown()) &#123;</div><div class=\"line\">                closeAll();</div><div class=\"line\">                <span class=\"keyword\">if</span> (confirmShutdown()) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</div><div class=\"line\">            handleLoopException(t);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ioStartTime = System.nanoTime();</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    processSelectedKeys();</div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Ensure we always run tasks.</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ioTime = System.nanoTime() - ioStartTime;</div><div class=\"line\">    runAllTasks(ioTime * (<span class=\"number\">100</span> - ioRatio) / ioRatio);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/netty/netty/issues/6058\" target=\"_blank\" rel=\"external\">https://github.com/netty/netty/issues/6058</a><br>processSelectedKeys();指的是IO任务<br>runAllTasks();指的是除了IO的任务</p>\n<p>ioTime / (n + ioTime) = ioRatio / (100)<br>=&gt; n = ioTime * (100 - ioRatio) / ioRatio</p>\n<p><a href=\"http://budairenqin.iteye.com/blog/2215896\" target=\"_blank\" rel=\"external\">http://budairenqin.iteye.com/blog/2215896</a></p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable task)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"task\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">boolean</span> inEventLoop = inEventLoop();</div><div class=\"line\">    <span class=\"keyword\">if</span> (inEventLoop) &#123;</div><div class=\"line\">        addTask(task);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 启动 eventLoop</span></div><div class=\"line\">        startThread();</div><div class=\"line\">        addTask(task);</div><div class=\"line\">        <span class=\"keyword\">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class=\"line\">            reject();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class=\"line\">        wakeup(inEventLoop);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doStartThread</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">assert</span> thread == <span class=\"keyword\">null</span>;</div><div class=\"line\">    executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            thread = Thread.currentThread();</div><div class=\"line\">            <span class=\"keyword\">if</span> (interrupted) &#123;</div><div class=\"line\">                thread.interrupt();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">boolean</span> success = <span class=\"keyword\">false</span>;</div><div class=\"line\">            updateLastExecutionTime();</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                SingleThreadEventExecutor.<span class=\"keyword\">this</span>.run();</div><div class=\"line\">                success = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</div><div class=\"line\">                logger.warn(<span class=\"string\">\"Unexpected exception from an event executor: \"</span>, t);</div><div class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">                    <span class=\"keyword\">int</span> oldState = STATE_UPDATER.get(SingleThreadEventExecutor.<span class=\"keyword\">this</span>);</div><div class=\"line\">                    <span class=\"keyword\">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</div><div class=\"line\">                            SingleThreadEventExecutor.<span class=\"keyword\">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Check if confirmShutdown() was called at the end of the loop.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (success &amp;&amp; gracefulShutdownStartTime == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    logger.error(<span class=\"string\">\"Buggy \"</span> + EventExecutor.class.getSimpleName() + <span class=\"string\">\" implementation; \"</span> +</div><div class=\"line\">                            SingleThreadEventExecutor.class.getSimpleName() + <span class=\"string\">\".confirmShutdown() must be called \"</span> +</div><div class=\"line\">                            <span class=\"string\">\"before run() implementation terminates.\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    <span class=\"comment\">// Run all remaining tasks and shutdown hooks.</span></div><div class=\"line\">                    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (confirmShutdown()) &#123;</div><div class=\"line\">                            <span class=\"keyword\">break</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        cleanup();</div><div class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class=\"keyword\">this</span>, ST_TERMINATED);</div><div class=\"line\">                        threadLock.release();</div><div class=\"line\">                        <span class=\"keyword\">if</span> (!taskQueue.isEmpty()) &#123;</div><div class=\"line\">                            logger.warn(</div><div class=\"line\">                                    <span class=\"string\">\"An event executor terminated with \"</span> +</div><div class=\"line\">                                            <span class=\"string\">\"non-empty task queue (\"</span> + taskQueue.size() + <span class=\"string\">')'</span>);</div><div class=\"line\">                        &#125;</div><div class=\"line\"></div><div class=\"line\">                        terminationFuture.setSuccess(<span class=\"keyword\">null</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> SelectStrategy.CONTINUE:</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> SelectStrategy.SELECT:</div><div class=\"line\">                    select(wakenUp.getAndSet(<span class=\"keyword\">false</span>));</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"comment\">// 'wakenUp.compareAndSet(false, true)' is always evaluated</span></div><div class=\"line\">                    <span class=\"comment\">// before calling 'selector.wakeup()' to reduce the wake-up</span></div><div class=\"line\">                    <span class=\"comment\">// overhead. (Selector.wakeup() is an expensive operation.)</span></div><div class=\"line\">                    <span class=\"comment\">//</span></div><div class=\"line\">                    <span class=\"comment\">// However, there is a race condition in this approach.</span></div><div class=\"line\">                    <span class=\"comment\">// The race condition is triggered when 'wakenUp' is set to</span></div><div class=\"line\">                    <span class=\"comment\">// true too early.</span></div><div class=\"line\">                    <span class=\"comment\">//</span></div><div class=\"line\">                    <span class=\"comment\">// 'wakenUp' is set to true too early if:</span></div><div class=\"line\">                    <span class=\"comment\">// 1) Selector is waken up between 'wakenUp.set(false)' and</span></div><div class=\"line\">                    <span class=\"comment\">//    'selector.select(...)'. (BAD)</span></div><div class=\"line\">                    <span class=\"comment\">// 2) Selector is waken up between 'selector.select(...)' and</span></div><div class=\"line\">                    <span class=\"comment\">//    'if (wakenUp.get()) &#123; ... &#125;'. (OK)</span></div><div class=\"line\">                    <span class=\"comment\">//</span></div><div class=\"line\">                    <span class=\"comment\">// In the first case, 'wakenUp' is set to true and the</span></div><div class=\"line\">                    <span class=\"comment\">// following 'selector.select(...)' will wake up immediately.</span></div><div class=\"line\">                    <span class=\"comment\">// Until 'wakenUp' is set to false again in the next round,</span></div><div class=\"line\">                    <span class=\"comment\">// 'wakenUp.compareAndSet(false, true)' will fail, and therefore</span></div><div class=\"line\">                    <span class=\"comment\">// any attempt to wake up the Selector will fail, too, causing</span></div><div class=\"line\">                    <span class=\"comment\">// the following 'selector.select(...)' call to block</span></div><div class=\"line\">                    <span class=\"comment\">// unnecessarily.</span></div><div class=\"line\">                    <span class=\"comment\">//</span></div><div class=\"line\">                    <span class=\"comment\">// To fix this problem, we wake up the selector again if wakenUp</span></div><div class=\"line\">                    <span class=\"comment\">// is true immediately after selector.select(...).</span></div><div class=\"line\">                    <span class=\"comment\">// It is inefficient in that it wakes up the selector for both</span></div><div class=\"line\">                    <span class=\"comment\">// the first case (BAD - wake-up required) and the second case</span></div><div class=\"line\">                    <span class=\"comment\">// (OK - no wake-up required).</span></div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">if</span> (wakenUp.get()) &#123;</div><div class=\"line\">                        selector.wakeup();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">default</span>:</div><div class=\"line\">                    <span class=\"comment\">// fallthrough</span></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            cancelledKeys = <span class=\"number\">0</span>;</div><div class=\"line\">            needsToSelectAgain = <span class=\"keyword\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ioRatio = <span class=\"keyword\">this</span>.ioRatio;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ioRatio == <span class=\"number\">100</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    processSelectedKeys();</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    <span class=\"comment\">// Ensure we always run tasks.</span></div><div class=\"line\">                    runAllTasks();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ioStartTime = System.nanoTime();</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    processSelectedKeys();</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    <span class=\"comment\">// Ensure we always run tasks.</span></div><div class=\"line\">                    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ioTime = System.nanoTime() - ioStartTime;</div><div class=\"line\">                    runAllTasks(ioTime * (<span class=\"number\">100</span> - ioRatio) / ioRatio);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</div><div class=\"line\">            handleLoopException(t);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// Always handle shutdown even if the loop processing threw an exception.</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (isShuttingDown()) &#123;</div><div class=\"line\">                closeAll();</div><div class=\"line\">                <span class=\"keyword\">if</span> (confirmShutdown()) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</div><div class=\"line\">            handleLoopException(t);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ioStartTime = System.nanoTime();</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    processSelectedKeys();</div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Ensure we always run tasks.</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ioTime = System.nanoTime() - ioStartTime;</div><div class=\"line\">    runAllTasks(ioTime * (<span class=\"number\">100</span> - ioRatio) / ioRatio);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/netty/netty/issues/6058\" target=\"_blank\" rel=\"external\">https://github.com/netty/netty/issues/6058</a><br>processSelectedKeys();指的是IO任务<br>runAllTasks();指的是除了IO的任务</p>\n<p>ioTime / (n + ioTime) = ioRatio / (100)<br>=&gt; n = ioTime * (100 - ioRatio) / ioRatio</p>\n<p><a href=\"http://budairenqin.iteye.com/blog/2215896\" target=\"_blank\" rel=\"external\">http://budairenqin.iteye.com/blog/2215896</a></p>\n"},{"title":"Netty-Buffer-Allocator","date":"2017-11-15T02:05:55.000Z","_content":"\npage  - a page is the smallest unit of memory chunk that can be allocated\n\n一般操作系统的内存page都是4kb    既然这么讲，不是可以     byte a = 1; 这样不就是分配了一个byte么???\n\nhttp://www.jianshu.com/p/cec977b28079\n\nhttp://www.jianshu.com/u/dbcfb30ec5e4","source":"_posts/Netty-Buffer-Allocator.md","raw":"---\ntitle: Netty-Buffer-Allocator\ndate: 2017-11-15 10:05:55\ntags: Netty\n---\n\npage  - a page is the smallest unit of memory chunk that can be allocated\n\n一般操作系统的内存page都是4kb    既然这么讲，不是可以     byte a = 1; 这样不就是分配了一个byte么???\n\nhttp://www.jianshu.com/p/cec977b28079\n\nhttp://www.jianshu.com/u/dbcfb30ec5e4","slug":"Netty-Buffer-Allocator","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz700243iq2rifp8qvr","content":"<p>page  - a page is the smallest unit of memory chunk that can be allocated</p>\n<p>一般操作系统的内存page都是4kb    既然这么讲，不是可以     byte a = 1; 这样不就是分配了一个byte么???</p>\n<p><a href=\"http://www.jianshu.com/p/cec977b28079\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/cec977b28079</a></p>\n<p><a href=\"http://www.jianshu.com/u/dbcfb30ec5e4\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/u/dbcfb30ec5e4</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>page  - a page is the smallest unit of memory chunk that can be allocated</p>\n<p>一般操作系统的内存page都是4kb    既然这么讲，不是可以     byte a = 1; 这样不就是分配了一个byte么???</p>\n<p><a href=\"http://www.jianshu.com/p/cec977b28079\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/cec977b28079</a></p>\n<p><a href=\"http://www.jianshu.com/u/dbcfb30ec5e4\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/u/dbcfb30ec5e4</a></p>\n"},{"title":"Netty-ChannelOption-Backlog","date":"2017-12-07T09:34:59.000Z","_content":"\nhttp://www.jianshu.com/p/e6f2036621f4","source":"_posts/Netty-ChannelOption-Backlog.md","raw":"---\ntitle: Netty-ChannelOption-Backlog\ndate: 2017-12-07 17:34:59\ntags:\n---\n\nhttp://www.jianshu.com/p/e6f2036621f4","slug":"Netty-ChannelOption-Backlog","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz800263iq2bmpvjcw5","content":"<p><a href=\"http://www.jianshu.com/p/e6f2036621f4\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/e6f2036621f4</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.jianshu.com/p/e6f2036621f4\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/e6f2036621f4</a></p>\n"},{"title":"Netty-ChannelOption","date":"2017-11-20T07:53:52.000Z","_content":"\n\n在用netty作为底层网络通信的时候关于ChannelOption的参数让我一直模糊不清楚，于是去看一下linux网络编程，发现ChannelOption的各种属性在套接字选项中都有对应\n\n下面简单的总结一下ChannelOption的含义已及使用的场景\n\n1、ChannelOption.SO_BACKLOG\n\nhttp://budairenqin.iteye.com/blog/2215899\n\nChannelOption.SO_BACKLOG对应的是tcp/ip协议listen函数中的backlog参数，函数listen(int socketfd,int backlog)用来初始化服务端可连接队列，\n\n服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接，多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog参数指定了队列的大小\n\n2、ChannelOption.SO_REUSEADDR\n\nChanneOption.SO_REUSEADDR对应于套接字选项中的SO_REUSEADDR，这个参数表示允许重复使用本地地址和端口，\n\n比如，某个服务器进程占用了TCP的80端口进行监听，此时再次监听该端口就会返回错误，使用该参数就可以解决问题，该参数允许共用该端口，这个在服务器程序中比较常使用，\n\n比如某个进程非正常退出，该程序占用的端口可能要被占用一段时间才能允许其他进程使用，而且程序死掉以后，内核一需要一定的时间才能够释放此端口，不设置SO_REUSEADDR\n\n就无法正常使用该端口。\n\n3、ChannelOption.SO_KEEPALIVE\n\nChanneloption.SO_KEEPALIVE参数对应于套接字选项中的SO_KEEPALIVE，该参数用于设置TCP连接，当设置该选项以后，连接会测试链接的状态，这个选项用于可能长时间没有数据交流的\n\n连接。当设置该选项以后，如果在两小时内没有数据的通信时，TCP会自动发送一个活动探测数据报文。\n\n4、ChannelOption.SO_SNDBUF和ChannelOpSNDBUF和ChannelOptiontion.SO_RCVBUF\n\nChannelOption.SO_SNDBUF参数对应于套接字选项中的SO_SNDBUF，ChannelOption.SO_RCVBUF参数对应于套接字选项中的SO_RCVBUF这两个参数用于操作接收缓冲区和发送缓冲区\n\n的大小，接收缓冲区用于保存网络协议站内收到的数据，直到应用程序读取成功，发送缓冲区用于保存发送数据，直到发送成功。\n\n5、ChannelOption.SO_LINGER\n\nChannelOption.SO_LINGER参数对应于套接字选项中的SO_LINGER,Linux内核默认的处理方式是当用户调用close（）方法的时候，函数返回，在可能的情况下，尽量发送数据，不一定保证\n\n会发生剩余的数据，造成了数据的不确定性，使用SO_LINGER可以阻塞close()的调用时间，直到数据完全发送\n\n6、ChannelOption.TCP_NODELAY\n\nChannelOption.TCP_NODELAY参数对应于套接字选项中的TCP_NODELAY,该参数的使用与Nagle算法有关\n\nNagle算法是将小的数据包组装为更大的帧然后进行发送，而不是输入一次发送一次,因此在数据包不足的时候会等待其他数据的到了，组装成大的数据包进行发送，虽然该方式有效提高网络的有效\n\n负载，但是却造成了延时，而该参数的作用就是禁止使用Nagle算法，使用于小数据即时传输，于TCP_NODELAY相对应的是TCP_CORK，该选项是需要等到发送的数据量最大的时候，一次性发送\n\n数据，适用于文件传输。\n\n","source":"_posts/Netty-ChannelOption.md","raw":"---\ntitle: Netty-ChannelOption\ndate: 2017-11-20 15:53:52\ntags: Netty\n---\n\n\n在用netty作为底层网络通信的时候关于ChannelOption的参数让我一直模糊不清楚，于是去看一下linux网络编程，发现ChannelOption的各种属性在套接字选项中都有对应\n\n下面简单的总结一下ChannelOption的含义已及使用的场景\n\n1、ChannelOption.SO_BACKLOG\n\nhttp://budairenqin.iteye.com/blog/2215899\n\nChannelOption.SO_BACKLOG对应的是tcp/ip协议listen函数中的backlog参数，函数listen(int socketfd,int backlog)用来初始化服务端可连接队列，\n\n服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接，多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog参数指定了队列的大小\n\n2、ChannelOption.SO_REUSEADDR\n\nChanneOption.SO_REUSEADDR对应于套接字选项中的SO_REUSEADDR，这个参数表示允许重复使用本地地址和端口，\n\n比如，某个服务器进程占用了TCP的80端口进行监听，此时再次监听该端口就会返回错误，使用该参数就可以解决问题，该参数允许共用该端口，这个在服务器程序中比较常使用，\n\n比如某个进程非正常退出，该程序占用的端口可能要被占用一段时间才能允许其他进程使用，而且程序死掉以后，内核一需要一定的时间才能够释放此端口，不设置SO_REUSEADDR\n\n就无法正常使用该端口。\n\n3、ChannelOption.SO_KEEPALIVE\n\nChanneloption.SO_KEEPALIVE参数对应于套接字选项中的SO_KEEPALIVE，该参数用于设置TCP连接，当设置该选项以后，连接会测试链接的状态，这个选项用于可能长时间没有数据交流的\n\n连接。当设置该选项以后，如果在两小时内没有数据的通信时，TCP会自动发送一个活动探测数据报文。\n\n4、ChannelOption.SO_SNDBUF和ChannelOpSNDBUF和ChannelOptiontion.SO_RCVBUF\n\nChannelOption.SO_SNDBUF参数对应于套接字选项中的SO_SNDBUF，ChannelOption.SO_RCVBUF参数对应于套接字选项中的SO_RCVBUF这两个参数用于操作接收缓冲区和发送缓冲区\n\n的大小，接收缓冲区用于保存网络协议站内收到的数据，直到应用程序读取成功，发送缓冲区用于保存发送数据，直到发送成功。\n\n5、ChannelOption.SO_LINGER\n\nChannelOption.SO_LINGER参数对应于套接字选项中的SO_LINGER,Linux内核默认的处理方式是当用户调用close（）方法的时候，函数返回，在可能的情况下，尽量发送数据，不一定保证\n\n会发生剩余的数据，造成了数据的不确定性，使用SO_LINGER可以阻塞close()的调用时间，直到数据完全发送\n\n6、ChannelOption.TCP_NODELAY\n\nChannelOption.TCP_NODELAY参数对应于套接字选项中的TCP_NODELAY,该参数的使用与Nagle算法有关\n\nNagle算法是将小的数据包组装为更大的帧然后进行发送，而不是输入一次发送一次,因此在数据包不足的时候会等待其他数据的到了，组装成大的数据包进行发送，虽然该方式有效提高网络的有效\n\n负载，但是却造成了延时，而该参数的作用就是禁止使用Nagle算法，使用于小数据即时传输，于TCP_NODELAY相对应的是TCP_CORK，该选项是需要等到发送的数据量最大的时候，一次性发送\n\n数据，适用于文件传输。\n\n","slug":"Netty-ChannelOption","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsz900283iq2sa3t8x1m","content":"<p>在用netty作为底层网络通信的时候关于ChannelOption的参数让我一直模糊不清楚，于是去看一下linux网络编程，发现ChannelOption的各种属性在套接字选项中都有对应</p>\n<p>下面简单的总结一下ChannelOption的含义已及使用的场景</p>\n<p>1、ChannelOption.SO_BACKLOG</p>\n<p><a href=\"http://budairenqin.iteye.com/blog/2215899\" target=\"_blank\" rel=\"external\">http://budairenqin.iteye.com/blog/2215899</a></p>\n<p>ChannelOption.SO_BACKLOG对应的是tcp/ip协议listen函数中的backlog参数，函数listen(int socketfd,int backlog)用来初始化服务端可连接队列，</p>\n<p>服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接，多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog参数指定了队列的大小</p>\n<p>2、ChannelOption.SO_REUSEADDR</p>\n<p>ChanneOption.SO_REUSEADDR对应于套接字选项中的SO_REUSEADDR，这个参数表示允许重复使用本地地址和端口，</p>\n<p>比如，某个服务器进程占用了TCP的80端口进行监听，此时再次监听该端口就会返回错误，使用该参数就可以解决问题，该参数允许共用该端口，这个在服务器程序中比较常使用，</p>\n<p>比如某个进程非正常退出，该程序占用的端口可能要被占用一段时间才能允许其他进程使用，而且程序死掉以后，内核一需要一定的时间才能够释放此端口，不设置SO_REUSEADDR</p>\n<p>就无法正常使用该端口。</p>\n<p>3、ChannelOption.SO_KEEPALIVE</p>\n<p>Channeloption.SO_KEEPALIVE参数对应于套接字选项中的SO_KEEPALIVE，该参数用于设置TCP连接，当设置该选项以后，连接会测试链接的状态，这个选项用于可能长时间没有数据交流的</p>\n<p>连接。当设置该选项以后，如果在两小时内没有数据的通信时，TCP会自动发送一个活动探测数据报文。</p>\n<p>4、ChannelOption.SO_SNDBUF和ChannelOpSNDBUF和ChannelOptiontion.SO_RCVBUF</p>\n<p>ChannelOption.SO_SNDBUF参数对应于套接字选项中的SO_SNDBUF，ChannelOption.SO_RCVBUF参数对应于套接字选项中的SO_RCVBUF这两个参数用于操作接收缓冲区和发送缓冲区</p>\n<p>的大小，接收缓冲区用于保存网络协议站内收到的数据，直到应用程序读取成功，发送缓冲区用于保存发送数据，直到发送成功。</p>\n<p>5、ChannelOption.SO_LINGER</p>\n<p>ChannelOption.SO_LINGER参数对应于套接字选项中的SO_LINGER,Linux内核默认的处理方式是当用户调用close（）方法的时候，函数返回，在可能的情况下，尽量发送数据，不一定保证</p>\n<p>会发生剩余的数据，造成了数据的不确定性，使用SO_LINGER可以阻塞close()的调用时间，直到数据完全发送</p>\n<p>6、ChannelOption.TCP_NODELAY</p>\n<p>ChannelOption.TCP_NODELAY参数对应于套接字选项中的TCP_NODELAY,该参数的使用与Nagle算法有关</p>\n<p>Nagle算法是将小的数据包组装为更大的帧然后进行发送，而不是输入一次发送一次,因此在数据包不足的时候会等待其他数据的到了，组装成大的数据包进行发送，虽然该方式有效提高网络的有效</p>\n<p>负载，但是却造成了延时，而该参数的作用就是禁止使用Nagle算法，使用于小数据即时传输，于TCP_NODELAY相对应的是TCP_CORK，该选项是需要等到发送的数据量最大的时候，一次性发送</p>\n<p>数据，适用于文件传输。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在用netty作为底层网络通信的时候关于ChannelOption的参数让我一直模糊不清楚，于是去看一下linux网络编程，发现ChannelOption的各种属性在套接字选项中都有对应</p>\n<p>下面简单的总结一下ChannelOption的含义已及使用的场景</p>\n<p>1、ChannelOption.SO_BACKLOG</p>\n<p><a href=\"http://budairenqin.iteye.com/blog/2215899\" target=\"_blank\" rel=\"external\">http://budairenqin.iteye.com/blog/2215899</a></p>\n<p>ChannelOption.SO_BACKLOG对应的是tcp/ip协议listen函数中的backlog参数，函数listen(int socketfd,int backlog)用来初始化服务端可连接队列，</p>\n<p>服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接，多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog参数指定了队列的大小</p>\n<p>2、ChannelOption.SO_REUSEADDR</p>\n<p>ChanneOption.SO_REUSEADDR对应于套接字选项中的SO_REUSEADDR，这个参数表示允许重复使用本地地址和端口，</p>\n<p>比如，某个服务器进程占用了TCP的80端口进行监听，此时再次监听该端口就会返回错误，使用该参数就可以解决问题，该参数允许共用该端口，这个在服务器程序中比较常使用，</p>\n<p>比如某个进程非正常退出，该程序占用的端口可能要被占用一段时间才能允许其他进程使用，而且程序死掉以后，内核一需要一定的时间才能够释放此端口，不设置SO_REUSEADDR</p>\n<p>就无法正常使用该端口。</p>\n<p>3、ChannelOption.SO_KEEPALIVE</p>\n<p>Channeloption.SO_KEEPALIVE参数对应于套接字选项中的SO_KEEPALIVE，该参数用于设置TCP连接，当设置该选项以后，连接会测试链接的状态，这个选项用于可能长时间没有数据交流的</p>\n<p>连接。当设置该选项以后，如果在两小时内没有数据的通信时，TCP会自动发送一个活动探测数据报文。</p>\n<p>4、ChannelOption.SO_SNDBUF和ChannelOpSNDBUF和ChannelOptiontion.SO_RCVBUF</p>\n<p>ChannelOption.SO_SNDBUF参数对应于套接字选项中的SO_SNDBUF，ChannelOption.SO_RCVBUF参数对应于套接字选项中的SO_RCVBUF这两个参数用于操作接收缓冲区和发送缓冲区</p>\n<p>的大小，接收缓冲区用于保存网络协议站内收到的数据，直到应用程序读取成功，发送缓冲区用于保存发送数据，直到发送成功。</p>\n<p>5、ChannelOption.SO_LINGER</p>\n<p>ChannelOption.SO_LINGER参数对应于套接字选项中的SO_LINGER,Linux内核默认的处理方式是当用户调用close（）方法的时候，函数返回，在可能的情况下，尽量发送数据，不一定保证</p>\n<p>会发生剩余的数据，造成了数据的不确定性，使用SO_LINGER可以阻塞close()的调用时间，直到数据完全发送</p>\n<p>6、ChannelOption.TCP_NODELAY</p>\n<p>ChannelOption.TCP_NODELAY参数对应于套接字选项中的TCP_NODELAY,该参数的使用与Nagle算法有关</p>\n<p>Nagle算法是将小的数据包组装为更大的帧然后进行发送，而不是输入一次发送一次,因此在数据包不足的时候会等待其他数据的到了，组装成大的数据包进行发送，虽然该方式有效提高网络的有效</p>\n<p>负载，但是却造成了延时，而该参数的作用就是禁止使用Nagle算法，使用于小数据即时传输，于TCP_NODELAY相对应的是TCP_CORK，该选项是需要等到发送的数据量最大的时候，一次性发送</p>\n<p>数据，适用于文件传输。</p>\n"},{"title":"Netty-原理整理","date":"2017-10-16T06:25:04.000Z","_content":"\n### Netty 编解码器\nByteToMessageDecoder与LengthFieldBasedFrameDecoder的区别\n\n### 重要概念 Future and Promise\n\n### Netty处理的对象\n\nbytes and messages.\n\n### 如何调试时间循环线程\n当我们用debug启动netty server时，我们不知道boss线程运行的代码，那怎么样才能发现boss线程当前的执行轨迹呢。如果能找到轨迹，对我们研究boss线程有非常大的帮助。\n\n给boss时间循环线程池起个名字\n``` java\n NioEventLoopGroup boss = new NioEventLoopGroup(0, new ThreadFactory() {\n    @Override\n    public Thread newThread(Runnable r) {\n        return new Thread(r, \"boss-event-loop\");\n    }\n});\n```\n如果用的Intellij，就能实现这个效果，首先用debug模式启动netty server。在debug tag下，我们进入Threads，展开**Thread Group \"main\"**，发现**boss-event-loop**正在处于Running状态。选中**boss-event-loop**，右键点击**suspend**，之后就能看到代码停了下来，去**Frames**tab中选择某一行进行断点调试。\n\n### 聊天程序\nWeb Socket技术\nLong Pooling技术\n\n### 原生NIO可能会被问到的问题\n\n### Netty线程管理，高低水位线(watermark)控制，高低水位指的是线程\nhttps://stackoverflow.com/questions/25281124/netty-4-high-and-low-write-watermarks\nhttp://adolgarev.blogspot.ru/2013/12/pipelining-and-flow-control.html?view=flipcard\n\n看下这个文章，是不是可以用Netty的限流来完成这个事情\n\n### Netty线程模型，Netty异常对Inbound(入站)和Outbound(出站) Handler的影响\n\n### Netty内存管理，怎么防止内存过度使用\n\nio模型，上面图里的问题，内存池怎么管理，怎么防止泄露。\nmq主从切换，但是网络原因master假死， 这时候slave升级为主，怎么办？\n和mysql主从切换一个道理，我不知道怎么办。或者怎么屏蔽。\n\n\n### Netty bind()方法\n\n``` java\n@Override\nprotected void doRegister() throws Exception {\n    boolean selected = false;\n    for (;;) {\n        try {\n            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n            return;\n        } catch (CancelledKeyException e) {\n            if (!selected) {\n                // Force the Selector to select now as the \"canceled\" SelectionKey may still be\n                // cached and not removed because no Select.select(..) operation was called yet.\n                eventLoop().selectNow();\n                selected = true;\n            } else {\n                // We forced a select operation on the selector before but the SelectionKey is still cached\n                // for whatever reason. JDK bug ?\n                throw e;\n            }\n        }\n    }\n}\n```\n注意到，register的第二个参数为0，也就是说，selector和serverSocketChannel之间仅仅有了注册关系，但没有指定selector到底interest什么事件，那问题是，selector和serverSocketChannel之间的OP_ACCEPT是什么时候完成的？\n\n### 用sendBuf和RecBuf做系统之间的限流，这好像是一个天然的事情\n\n### Netty高性能开发备忘录\nhttp://blog.csdn.net/asdfayw/article/details/71730543\n\n### Netty中的那些坑\nhttp://www.jianshu.com/p/890525ff73cb\nhttp://www.jianshu.com/p/8f22675d71ac\n\n### 用Netty开发中间件：高并发性能优化\nhttp://blog.csdn.net/dc_726/article/details/48978891\n\n### handler和childHandler的区别\n\n### 问题\n\n``` java\nprivate static ServerSocketChannel newSocket(SelectorProvider provider) {\n        try {\n            /**\n             *  Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in\n             *  {@link SelectorProvider#provider()} which is called by each ServerSocketChannel.open() otherwise.\n             *\n             *  See <a href=\"https://github.com/netty/netty/issues/2308\">#2308</a>.\n             */\n            return provider.openServerSocketChannel();\n        } catch (IOException e) {\n            throw new ChannelException(\n                    \"Failed to open a server socket.\", e);\n        }\n    }\n```","source":"_posts/Netty-FAQ.md","raw":"---\ntitle: Netty-原理整理\ndate: 2017-10-16 14:25:04\ntags: Netty\n---\n\n### Netty 编解码器\nByteToMessageDecoder与LengthFieldBasedFrameDecoder的区别\n\n### 重要概念 Future and Promise\n\n### Netty处理的对象\n\nbytes and messages.\n\n### 如何调试时间循环线程\n当我们用debug启动netty server时，我们不知道boss线程运行的代码，那怎么样才能发现boss线程当前的执行轨迹呢。如果能找到轨迹，对我们研究boss线程有非常大的帮助。\n\n给boss时间循环线程池起个名字\n``` java\n NioEventLoopGroup boss = new NioEventLoopGroup(0, new ThreadFactory() {\n    @Override\n    public Thread newThread(Runnable r) {\n        return new Thread(r, \"boss-event-loop\");\n    }\n});\n```\n如果用的Intellij，就能实现这个效果，首先用debug模式启动netty server。在debug tag下，我们进入Threads，展开**Thread Group \"main\"**，发现**boss-event-loop**正在处于Running状态。选中**boss-event-loop**，右键点击**suspend**，之后就能看到代码停了下来，去**Frames**tab中选择某一行进行断点调试。\n\n### 聊天程序\nWeb Socket技术\nLong Pooling技术\n\n### 原生NIO可能会被问到的问题\n\n### Netty线程管理，高低水位线(watermark)控制，高低水位指的是线程\nhttps://stackoverflow.com/questions/25281124/netty-4-high-and-low-write-watermarks\nhttp://adolgarev.blogspot.ru/2013/12/pipelining-and-flow-control.html?view=flipcard\n\n看下这个文章，是不是可以用Netty的限流来完成这个事情\n\n### Netty线程模型，Netty异常对Inbound(入站)和Outbound(出站) Handler的影响\n\n### Netty内存管理，怎么防止内存过度使用\n\nio模型，上面图里的问题，内存池怎么管理，怎么防止泄露。\nmq主从切换，但是网络原因master假死， 这时候slave升级为主，怎么办？\n和mysql主从切换一个道理，我不知道怎么办。或者怎么屏蔽。\n\n\n### Netty bind()方法\n\n``` java\n@Override\nprotected void doRegister() throws Exception {\n    boolean selected = false;\n    for (;;) {\n        try {\n            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n            return;\n        } catch (CancelledKeyException e) {\n            if (!selected) {\n                // Force the Selector to select now as the \"canceled\" SelectionKey may still be\n                // cached and not removed because no Select.select(..) operation was called yet.\n                eventLoop().selectNow();\n                selected = true;\n            } else {\n                // We forced a select operation on the selector before but the SelectionKey is still cached\n                // for whatever reason. JDK bug ?\n                throw e;\n            }\n        }\n    }\n}\n```\n注意到，register的第二个参数为0，也就是说，selector和serverSocketChannel之间仅仅有了注册关系，但没有指定selector到底interest什么事件，那问题是，selector和serverSocketChannel之间的OP_ACCEPT是什么时候完成的？\n\n### 用sendBuf和RecBuf做系统之间的限流，这好像是一个天然的事情\n\n### Netty高性能开发备忘录\nhttp://blog.csdn.net/asdfayw/article/details/71730543\n\n### Netty中的那些坑\nhttp://www.jianshu.com/p/890525ff73cb\nhttp://www.jianshu.com/p/8f22675d71ac\n\n### 用Netty开发中间件：高并发性能优化\nhttp://blog.csdn.net/dc_726/article/details/48978891\n\n### handler和childHandler的区别\n\n### 问题\n\n``` java\nprivate static ServerSocketChannel newSocket(SelectorProvider provider) {\n        try {\n            /**\n             *  Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in\n             *  {@link SelectorProvider#provider()} which is called by each ServerSocketChannel.open() otherwise.\n             *\n             *  See <a href=\"https://github.com/netty/netty/issues/2308\">#2308</a>.\n             */\n            return provider.openServerSocketChannel();\n        } catch (IOException e) {\n            throw new ChannelException(\n                    \"Failed to open a server socket.\", e);\n        }\n    }\n```","slug":"Netty-FAQ","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsza002a3iq29m143btj","content":"<h3 id=\"Netty-编解码器\"><a href=\"#Netty-编解码器\" class=\"headerlink\" title=\"Netty 编解码器\"></a>Netty 编解码器</h3><p>ByteToMessageDecoder与LengthFieldBasedFrameDecoder的区别</p>\n<h3 id=\"重要概念-Future-and-Promise\"><a href=\"#重要概念-Future-and-Promise\" class=\"headerlink\" title=\"重要概念 Future and Promise\"></a>重要概念 Future and Promise</h3><h3 id=\"Netty处理的对象\"><a href=\"#Netty处理的对象\" class=\"headerlink\" title=\"Netty处理的对象\"></a>Netty处理的对象</h3><p>bytes and messages.</p>\n<h3 id=\"如何调试时间循环线程\"><a href=\"#如何调试时间循环线程\" class=\"headerlink\" title=\"如何调试时间循环线程\"></a>如何调试时间循环线程</h3><p>当我们用debug启动netty server时，我们不知道boss线程运行的代码，那怎么样才能发现boss线程当前的执行轨迹呢。如果能找到轨迹，对我们研究boss线程有非常大的帮助。</p>\n<p>给boss时间循环线程池起个名字<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> NioEventLoopGroup boss = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">0</span>, <span class=\"keyword\">new</span> ThreadFactory() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Thread(r, <span class=\"string\">\"boss-event-loop\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>如果用的Intellij，就能实现这个效果，首先用debug模式启动netty server。在debug tag下，我们进入Threads，展开<strong>Thread Group “main”</strong>，发现<strong>boss-event-loop</strong>正在处于Running状态。选中<strong>boss-event-loop</strong>，右键点击<strong>suspend</strong>，之后就能看到代码停了下来，去<strong>Frames</strong>tab中选择某一行进行断点调试。</p>\n<h3 id=\"聊天程序\"><a href=\"#聊天程序\" class=\"headerlink\" title=\"聊天程序\"></a>聊天程序</h3><p>Web Socket技术<br>Long Pooling技术</p>\n<h3 id=\"原生NIO可能会被问到的问题\"><a href=\"#原生NIO可能会被问到的问题\" class=\"headerlink\" title=\"原生NIO可能会被问到的问题\"></a>原生NIO可能会被问到的问题</h3><h3 id=\"Netty线程管理，高低水位线-watermark-控制，高低水位指的是线程\"><a href=\"#Netty线程管理，高低水位线-watermark-控制，高低水位指的是线程\" class=\"headerlink\" title=\"Netty线程管理，高低水位线(watermark)控制，高低水位指的是线程\"></a>Netty线程管理，高低水位线(watermark)控制，高低水位指的是线程</h3><p><a href=\"https://stackoverflow.com/questions/25281124/netty-4-high-and-low-write-watermarks\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/25281124/netty-4-high-and-low-write-watermarks</a><br><a href=\"http://adolgarev.blogspot.ru/2013/12/pipelining-and-flow-control.html?view=flipcard\" target=\"_blank\" rel=\"external\">http://adolgarev.blogspot.ru/2013/12/pipelining-and-flow-control.html?view=flipcard</a></p>\n<p>看下这个文章，是不是可以用Netty的限流来完成这个事情</p>\n<h3 id=\"Netty线程模型，Netty异常对Inbound-入站-和Outbound-出站-Handler的影响\"><a href=\"#Netty线程模型，Netty异常对Inbound-入站-和Outbound-出站-Handler的影响\" class=\"headerlink\" title=\"Netty线程模型，Netty异常对Inbound(入站)和Outbound(出站) Handler的影响\"></a>Netty线程模型，Netty异常对Inbound(入站)和Outbound(出站) Handler的影响</h3><h3 id=\"Netty内存管理，怎么防止内存过度使用\"><a href=\"#Netty内存管理，怎么防止内存过度使用\" class=\"headerlink\" title=\"Netty内存管理，怎么防止内存过度使用\"></a>Netty内存管理，怎么防止内存过度使用</h3><p>io模型，上面图里的问题，内存池怎么管理，怎么防止泄露。<br>mq主从切换，但是网络原因master假死， 这时候slave升级为主，怎么办？<br>和mysql主从切换一个道理，我不知道怎么办。或者怎么屏蔽。</p>\n<h3 id=\"Netty-bind-方法\"><a href=\"#Netty-bind-方法\" class=\"headerlink\" title=\"Netty bind()方法\"></a>Netty bind()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doRegister</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> selected = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class=\"number\">0</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CancelledKeyException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!selected) &#123;</div><div class=\"line\">                <span class=\"comment\">// Force the Selector to select now as the \"canceled\" SelectionKey may still be</span></div><div class=\"line\">                <span class=\"comment\">// cached and not removed because no Select.select(..) operation was called yet.</span></div><div class=\"line\">                eventLoop().selectNow();</div><div class=\"line\">                selected = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// We forced a select operation on the selector before but the SelectionKey is still cached</span></div><div class=\"line\">                <span class=\"comment\">// for whatever reason. JDK bug ?</span></div><div class=\"line\">                <span class=\"keyword\">throw</span> e;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意到，register的第二个参数为0，也就是说，selector和serverSocketChannel之间仅仅有了注册关系，但没有指定selector到底interest什么事件，那问题是，selector和serverSocketChannel之间的OP_ACCEPT是什么时候完成的？</p>\n<h3 id=\"用sendBuf和RecBuf做系统之间的限流，这好像是一个天然的事情\"><a href=\"#用sendBuf和RecBuf做系统之间的限流，这好像是一个天然的事情\" class=\"headerlink\" title=\"用sendBuf和RecBuf做系统之间的限流，这好像是一个天然的事情\"></a>用sendBuf和RecBuf做系统之间的限流，这好像是一个天然的事情</h3><h3 id=\"Netty高性能开发备忘录\"><a href=\"#Netty高性能开发备忘录\" class=\"headerlink\" title=\"Netty高性能开发备忘录\"></a>Netty高性能开发备忘录</h3><p><a href=\"http://blog.csdn.net/asdfayw/article/details/71730543\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/asdfayw/article/details/71730543</a></p>\n<h3 id=\"Netty中的那些坑\"><a href=\"#Netty中的那些坑\" class=\"headerlink\" title=\"Netty中的那些坑\"></a>Netty中的那些坑</h3><p><a href=\"http://www.jianshu.com/p/890525ff73cb\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/890525ff73cb</a><br><a href=\"http://www.jianshu.com/p/8f22675d71ac\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/8f22675d71ac</a></p>\n<h3 id=\"用Netty开发中间件：高并发性能优化\"><a href=\"#用Netty开发中间件：高并发性能优化\" class=\"headerlink\" title=\"用Netty开发中间件：高并发性能优化\"></a>用Netty开发中间件：高并发性能优化</h3><p><a href=\"http://blog.csdn.net/dc_726/article/details/48978891\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/dc_726/article/details/48978891</a></p>\n<h3 id=\"handler和childHandler的区别\"><a href=\"#handler和childHandler的区别\" class=\"headerlink\" title=\"handler和childHandler的区别\"></a>handler和childHandler的区别</h3><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ServerSocketChannel <span class=\"title\">newSocket</span><span class=\"params\">(SelectorProvider provider)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">             *  Use the &#123;<span class=\"doctag\">@link</span> SelectorProvider&#125; to open &#123;<span class=\"doctag\">@link</span> SocketChannel&#125; and so remove condition in</span></div><div class=\"line\"><span class=\"comment\">             *  &#123;<span class=\"doctag\">@link</span> SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise.</span></div><div class=\"line\"><span class=\"comment\">             *</span></div><div class=\"line\"><span class=\"comment\">             *  See &lt;a href=\"https://github.com/netty/netty/issues/2308\"&gt;#2308&lt;/a&gt;.</span></div><div class=\"line\"><span class=\"comment\">             */</span></div><div class=\"line\">            <span class=\"keyword\">return</span> provider.openServerSocketChannel();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ChannelException(</div><div class=\"line\">                    <span class=\"string\">\"Failed to open a server socket.\"</span>, e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Netty-编解码器\"><a href=\"#Netty-编解码器\" class=\"headerlink\" title=\"Netty 编解码器\"></a>Netty 编解码器</h3><p>ByteToMessageDecoder与LengthFieldBasedFrameDecoder的区别</p>\n<h3 id=\"重要概念-Future-and-Promise\"><a href=\"#重要概念-Future-and-Promise\" class=\"headerlink\" title=\"重要概念 Future and Promise\"></a>重要概念 Future and Promise</h3><h3 id=\"Netty处理的对象\"><a href=\"#Netty处理的对象\" class=\"headerlink\" title=\"Netty处理的对象\"></a>Netty处理的对象</h3><p>bytes and messages.</p>\n<h3 id=\"如何调试时间循环线程\"><a href=\"#如何调试时间循环线程\" class=\"headerlink\" title=\"如何调试时间循环线程\"></a>如何调试时间循环线程</h3><p>当我们用debug启动netty server时，我们不知道boss线程运行的代码，那怎么样才能发现boss线程当前的执行轨迹呢。如果能找到轨迹，对我们研究boss线程有非常大的帮助。</p>\n<p>给boss时间循环线程池起个名字<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> NioEventLoopGroup boss = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">0</span>, <span class=\"keyword\">new</span> ThreadFactory() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Thread(r, <span class=\"string\">\"boss-event-loop\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>如果用的Intellij，就能实现这个效果，首先用debug模式启动netty server。在debug tag下，我们进入Threads，展开<strong>Thread Group “main”</strong>，发现<strong>boss-event-loop</strong>正在处于Running状态。选中<strong>boss-event-loop</strong>，右键点击<strong>suspend</strong>，之后就能看到代码停了下来，去<strong>Frames</strong>tab中选择某一行进行断点调试。</p>\n<h3 id=\"聊天程序\"><a href=\"#聊天程序\" class=\"headerlink\" title=\"聊天程序\"></a>聊天程序</h3><p>Web Socket技术<br>Long Pooling技术</p>\n<h3 id=\"原生NIO可能会被问到的问题\"><a href=\"#原生NIO可能会被问到的问题\" class=\"headerlink\" title=\"原生NIO可能会被问到的问题\"></a>原生NIO可能会被问到的问题</h3><h3 id=\"Netty线程管理，高低水位线-watermark-控制，高低水位指的是线程\"><a href=\"#Netty线程管理，高低水位线-watermark-控制，高低水位指的是线程\" class=\"headerlink\" title=\"Netty线程管理，高低水位线(watermark)控制，高低水位指的是线程\"></a>Netty线程管理，高低水位线(watermark)控制，高低水位指的是线程</h3><p><a href=\"https://stackoverflow.com/questions/25281124/netty-4-high-and-low-write-watermarks\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/25281124/netty-4-high-and-low-write-watermarks</a><br><a href=\"http://adolgarev.blogspot.ru/2013/12/pipelining-and-flow-control.html?view=flipcard\" target=\"_blank\" rel=\"external\">http://adolgarev.blogspot.ru/2013/12/pipelining-and-flow-control.html?view=flipcard</a></p>\n<p>看下这个文章，是不是可以用Netty的限流来完成这个事情</p>\n<h3 id=\"Netty线程模型，Netty异常对Inbound-入站-和Outbound-出站-Handler的影响\"><a href=\"#Netty线程模型，Netty异常对Inbound-入站-和Outbound-出站-Handler的影响\" class=\"headerlink\" title=\"Netty线程模型，Netty异常对Inbound(入站)和Outbound(出站) Handler的影响\"></a>Netty线程模型，Netty异常对Inbound(入站)和Outbound(出站) Handler的影响</h3><h3 id=\"Netty内存管理，怎么防止内存过度使用\"><a href=\"#Netty内存管理，怎么防止内存过度使用\" class=\"headerlink\" title=\"Netty内存管理，怎么防止内存过度使用\"></a>Netty内存管理，怎么防止内存过度使用</h3><p>io模型，上面图里的问题，内存池怎么管理，怎么防止泄露。<br>mq主从切换，但是网络原因master假死， 这时候slave升级为主，怎么办？<br>和mysql主从切换一个道理，我不知道怎么办。或者怎么屏蔽。</p>\n<h3 id=\"Netty-bind-方法\"><a href=\"#Netty-bind-方法\" class=\"headerlink\" title=\"Netty bind()方法\"></a>Netty bind()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doRegister</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> selected = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class=\"number\">0</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CancelledKeyException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!selected) &#123;</div><div class=\"line\">                <span class=\"comment\">// Force the Selector to select now as the \"canceled\" SelectionKey may still be</span></div><div class=\"line\">                <span class=\"comment\">// cached and not removed because no Select.select(..) operation was called yet.</span></div><div class=\"line\">                eventLoop().selectNow();</div><div class=\"line\">                selected = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// We forced a select operation on the selector before but the SelectionKey is still cached</span></div><div class=\"line\">                <span class=\"comment\">// for whatever reason. JDK bug ?</span></div><div class=\"line\">                <span class=\"keyword\">throw</span> e;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意到，register的第二个参数为0，也就是说，selector和serverSocketChannel之间仅仅有了注册关系，但没有指定selector到底interest什么事件，那问题是，selector和serverSocketChannel之间的OP_ACCEPT是什么时候完成的？</p>\n<h3 id=\"用sendBuf和RecBuf做系统之间的限流，这好像是一个天然的事情\"><a href=\"#用sendBuf和RecBuf做系统之间的限流，这好像是一个天然的事情\" class=\"headerlink\" title=\"用sendBuf和RecBuf做系统之间的限流，这好像是一个天然的事情\"></a>用sendBuf和RecBuf做系统之间的限流，这好像是一个天然的事情</h3><h3 id=\"Netty高性能开发备忘录\"><a href=\"#Netty高性能开发备忘录\" class=\"headerlink\" title=\"Netty高性能开发备忘录\"></a>Netty高性能开发备忘录</h3><p><a href=\"http://blog.csdn.net/asdfayw/article/details/71730543\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/asdfayw/article/details/71730543</a></p>\n<h3 id=\"Netty中的那些坑\"><a href=\"#Netty中的那些坑\" class=\"headerlink\" title=\"Netty中的那些坑\"></a>Netty中的那些坑</h3><p><a href=\"http://www.jianshu.com/p/890525ff73cb\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/890525ff73cb</a><br><a href=\"http://www.jianshu.com/p/8f22675d71ac\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/8f22675d71ac</a></p>\n<h3 id=\"用Netty开发中间件：高并发性能优化\"><a href=\"#用Netty开发中间件：高并发性能优化\" class=\"headerlink\" title=\"用Netty开发中间件：高并发性能优化\"></a>用Netty开发中间件：高并发性能优化</h3><p><a href=\"http://blog.csdn.net/dc_726/article/details/48978891\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/dc_726/article/details/48978891</a></p>\n<h3 id=\"handler和childHandler的区别\"><a href=\"#handler和childHandler的区别\" class=\"headerlink\" title=\"handler和childHandler的区别\"></a>handler和childHandler的区别</h3><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ServerSocketChannel <span class=\"title\">newSocket</span><span class=\"params\">(SelectorProvider provider)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">             *  Use the &#123;<span class=\"doctag\">@link</span> SelectorProvider&#125; to open &#123;<span class=\"doctag\">@link</span> SocketChannel&#125; and so remove condition in</span></div><div class=\"line\"><span class=\"comment\">             *  &#123;<span class=\"doctag\">@link</span> SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise.</span></div><div class=\"line\"><span class=\"comment\">             *</span></div><div class=\"line\"><span class=\"comment\">             *  See &lt;a href=\"https://github.com/netty/netty/issues/2308\"&gt;#2308&lt;/a&gt;.</span></div><div class=\"line\"><span class=\"comment\">             */</span></div><div class=\"line\">            <span class=\"keyword\">return</span> provider.openServerSocketChannel();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ChannelException(</div><div class=\"line\">                    <span class=\"string\">\"Failed to open a server socket.\"</span>, e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>"},{"title":"OSAHS手术回忆","date":"2018-07-02T02:32:32.000Z","_content":"\n### OSAHS——「阻塞性睡眠呼吸暂停综合征」手术回忆\nOSAHS，最大的风险就是睡眠时上气道塌陷阻塞引起的呼吸暂停和低通气，导致血氧饱和度非常低，引起白天嗜睡，注意力不集中，记忆力下降等病症，更严重的可能导致窒息。我其实从高中开始就每天睡不好，白天没有精神，可能跟那个时候吃胖得有关。\n\n## 2018-06-25，周一\n请假来到「浙江大学医学院附属邵逸夫医院」办理住院手续，心情愉悦，一脸微笑，病床靠窗，窗外是钱江新城的高楼，着实有种度假的感觉，同病房的两位老爷爷还在奇怪我好像没有病啊。由于没有去查阅过任何治疗经历，所以也其实自己也不知道是怎么回事，只知道可能要切除下扁桃体。术前手续其实不多，作为医生的女朋友给我安排得妥妥当当的。\n\n下午被手术助手之一的金医生叫到办公室，简单得描述了下手术的原理还有流程，我只注意到，这哥们说，手术做完后，会很痛苦，我呢是被安排在周二早上第2台手术，10点左右开始，大概会持续一个小时，全程麻醉，由于要动刀，所以也有可能会痛，要忍，由于手术有窒息风险，插在呼吸道的管子必须到我意识恢复后才能拔出来，那时会非常不舒服，术后要大量饮水，把血冲到肚子里面，保证喉咙湿润。这时我算对这个手术有了一定的认识，还是有点紧张的，毕竟从小到大没有做过手术，还全麻，以上就是我在手术前所需要知道的所有东西。晚上在病床休息，临时被通知被换到明早第一台手术，心里有点慌。\n\n## 2018-06-26，周二\n早上6点左右就被工作人员拖出了病房，带到了一个「护士流动站」的地方，不知道有没有记错名字，我是最初几个被拉进来的，然后看着房间里面越来越多的病人被工作人员推进来。做肝肾，胆手术的都有，心情确实不好受，感觉是待宰的羔羊。最最难受的是，在这个房间里面，意识非常清醒的状态下，等了近两个小时，非常煎药，还不如直接来个痛快的。还好女朋友是本院医生，走关系进来陪我说说话，不然是心慌慌。大概8点半，我被推进了看上去挺豪华的手术室，主刀医生和各位助理医生早已在那里等我，随后就是在我身上贴了各种不知道干嘛的小片，还给我开了个玩笑，具体内容真忘记了，然后护士小姐给我带了个氧气罩，让我深呼吸，同时我知道输液的液体已经被换成了麻醉药，一小会儿，我就失去了意识，慢慢睡着了。。。\n\n当我醒来的时候，还好不是在动刀子的时候，不然想想挺奔溃的。只记得那时我口中插了管子，靠着呼吸机在呼吸，口中感觉不时冒出一点血，量不大，吸一吸就行，身边是女朋友和一个带着口罩面向着显示器的医院，不停得和我说话。我虽然有点头痛，但好像也不是特别难受，不时还能用动作回他们的话，我知道最危险的时候度过了。医生觉得我状态还行，就说可以把管子了，期间要忍一忍，可能有点恶心，其实我觉得也就这样。随后就被拉回了病房，我爸也在病房等我。\n\n接下去噩梦开始到来，由于从深度麻醉中醒来，头痛得不行，喉咙也非常痛，连舌头也不敢乱动，讲话几乎是不可能的，只能像小孩子一样发出点声音，右边的鼻子中被严严实实得塞了棉条，防止鼻子出血。交流只能是靠着半醒的状态在手机上打字，还时不时打错字。按照医嘱，我一天要喝2000ml的水和牛奶，米汤等东西，哪有那么容易啊，喝水变得非常非常苦难，主要是太痛了，还不能前仰得喝，会从鼻子里面出来，出来的还不是水，主要是血。每次吐口水，反正是各种黑色的淤血，一开始觉得好恶心，后面也就习惯了。呼吸只能靠嘴巴，病床上有氧气，我就只能洗着氧气，挂着点滴，处于半昏迷状态。由于有喝水的任务，我无数次被叫起来喝水，每次喝一口就吐一口，就是痛得喝不下，米粥也就是喝了一小口，基本也不喝了。还好每天挂着少量葡萄糖，不然我几乎就没有吃过东西。到了晚上睡觉，反正就是睡不着，不舒服，麻药的效果我觉得和醉酒是类似的，\n\n## 2018-06-27，周三\n医生把我鼻子里面的棉条用镊子夹了出来，非常痛，这时我才感受到这东西放得有多深，大概有10cm，拉出来的面条被黑色的淤血包裹着，不过没有新鲜的血流出来，说明鼻子没有出血，也算是一个好消息，毕竟当时鼻子里面也是切除了一点东西的。在漱口时，用镜子照了下嘴巴里面，舌苔上有很厚一层白色物质，咽腔两侧有一些手术缝的线，里面有黄黄的物质，感觉非常恶心。\n\n## 2018-06-28，周四\n麻药的效果基本上是过了，脖子也有力气了，头也没有那么痛，但是晚上睡觉嘴巴和喉咙真的太干了，这样醒了后又要喝水，但是喝水会很痛，我基本也是喝不了几口。鸡蛋羹吃得非常恶心，导致我现在都排斥吃东西。\n\n## 2018-06-29，周五\n每一天都比上一天好了点，但还是非常难熬，主要是不能吃喜欢吃的东西，精神和肉体上开始双重折磨。助理医生拿吸管从鼻子里面吸出了好多血，但鼻子还是不通。找到了和我做同一种手术的一个哥们，当时他的状态比我差很多，和他交流了下，基本也是非常痛苦。了解到，他是一名在四季青卖衣服的小老板，常年喝酒应酬，家人反应后他做了检测，也是OSAHS，但他现在已经40+岁了，肯定恢复得没有我快。\n\n## 2018-06-30，周六\n大概6点不到就抽了次血。上午主刀医生查房时，看到我在用嘴巴呼吸，把我叫到换药室，将涂了药水的棉花再一次赛到我的鼻子里，这次赛进去就比较痛，过了几秒再拔出来，又是全部都是黑色的淤血，但感觉鼻子有一点点通了，于是回病床上，叫老爸不停往我鼻子喷清洗剂，我用力把多余的脏东西都排了出来。这时，在站立状态下，我终于可以用鼻子呼吸了。但在躺下的状态下，我还是不能用鼻子呼吸，嘴巴还是很干，晚上根本不能睡好。但是，由于各种用药和点滴，我必须一直在病床上，很容易就睡着了，又开始用嘴巴呼吸，这时鼻子里面又会开始分泌各种物质，醒来时鼻子又会塞住，反反复复。\n\n## 2018-07-01，周日\n由于在医院睡不好，精神状态很差，发了一次脾气，非常后悔。但相对而言，我身体恢复得还行，我就打算提前一天出院，想想在家里睡得比在医院好些。周六的血液报告虽然有几项有问题，但不影响我出院，我就顺利在周日中午出院，我的那位病友当时血液检测都没有通过，他至少还要在医院多待3天。回到家整理了下东西，洗了个澡，伴随着开着中档的加湿器，就睡觉了。期间就醒了两三次，嘴巴还是很干，感觉比医院睡得好些。\n\n## 2018-07-02，周一\n现在是手术后的第7天，已经出院，选择来上班试试，意识还行，身体很疲惫，很饿，晚上睡觉呼吸只能靠嘴巴，会非常干，很容易干醒，讲话可以讲一点，但舌头太干，讲不清楚。早餐照例是流质食品——豆腐脑，咽下去时，喉咙有点痛，非常容易吃到鼻子里去，吃了几小口就吃不下了，如果按照这个速度继续吃，估计1个多小时才能把一碗2块钱的豆腐脑吃完。肚子里面一直是空的，也一直是饥饿的状态，接下去每一天估计只会吃牛奶和一点点糖水/汤水补充能量，加上一些纯净水平衡体内水盐，这样的情况要持续到2018-07-09拆线前。每天都挺漫长。。。","source":"_posts/OSAHS.md","raw":"---\ntitle: OSAHS手术回忆\ndate: 2018-07-02 10:32:32\ntags:\n---\n\n### OSAHS——「阻塞性睡眠呼吸暂停综合征」手术回忆\nOSAHS，最大的风险就是睡眠时上气道塌陷阻塞引起的呼吸暂停和低通气，导致血氧饱和度非常低，引起白天嗜睡，注意力不集中，记忆力下降等病症，更严重的可能导致窒息。我其实从高中开始就每天睡不好，白天没有精神，可能跟那个时候吃胖得有关。\n\n## 2018-06-25，周一\n请假来到「浙江大学医学院附属邵逸夫医院」办理住院手续，心情愉悦，一脸微笑，病床靠窗，窗外是钱江新城的高楼，着实有种度假的感觉，同病房的两位老爷爷还在奇怪我好像没有病啊。由于没有去查阅过任何治疗经历，所以也其实自己也不知道是怎么回事，只知道可能要切除下扁桃体。术前手续其实不多，作为医生的女朋友给我安排得妥妥当当的。\n\n下午被手术助手之一的金医生叫到办公室，简单得描述了下手术的原理还有流程，我只注意到，这哥们说，手术做完后，会很痛苦，我呢是被安排在周二早上第2台手术，10点左右开始，大概会持续一个小时，全程麻醉，由于要动刀，所以也有可能会痛，要忍，由于手术有窒息风险，插在呼吸道的管子必须到我意识恢复后才能拔出来，那时会非常不舒服，术后要大量饮水，把血冲到肚子里面，保证喉咙湿润。这时我算对这个手术有了一定的认识，还是有点紧张的，毕竟从小到大没有做过手术，还全麻，以上就是我在手术前所需要知道的所有东西。晚上在病床休息，临时被通知被换到明早第一台手术，心里有点慌。\n\n## 2018-06-26，周二\n早上6点左右就被工作人员拖出了病房，带到了一个「护士流动站」的地方，不知道有没有记错名字，我是最初几个被拉进来的，然后看着房间里面越来越多的病人被工作人员推进来。做肝肾，胆手术的都有，心情确实不好受，感觉是待宰的羔羊。最最难受的是，在这个房间里面，意识非常清醒的状态下，等了近两个小时，非常煎药，还不如直接来个痛快的。还好女朋友是本院医生，走关系进来陪我说说话，不然是心慌慌。大概8点半，我被推进了看上去挺豪华的手术室，主刀医生和各位助理医生早已在那里等我，随后就是在我身上贴了各种不知道干嘛的小片，还给我开了个玩笑，具体内容真忘记了，然后护士小姐给我带了个氧气罩，让我深呼吸，同时我知道输液的液体已经被换成了麻醉药，一小会儿，我就失去了意识，慢慢睡着了。。。\n\n当我醒来的时候，还好不是在动刀子的时候，不然想想挺奔溃的。只记得那时我口中插了管子，靠着呼吸机在呼吸，口中感觉不时冒出一点血，量不大，吸一吸就行，身边是女朋友和一个带着口罩面向着显示器的医院，不停得和我说话。我虽然有点头痛，但好像也不是特别难受，不时还能用动作回他们的话，我知道最危险的时候度过了。医生觉得我状态还行，就说可以把管子了，期间要忍一忍，可能有点恶心，其实我觉得也就这样。随后就被拉回了病房，我爸也在病房等我。\n\n接下去噩梦开始到来，由于从深度麻醉中醒来，头痛得不行，喉咙也非常痛，连舌头也不敢乱动，讲话几乎是不可能的，只能像小孩子一样发出点声音，右边的鼻子中被严严实实得塞了棉条，防止鼻子出血。交流只能是靠着半醒的状态在手机上打字，还时不时打错字。按照医嘱，我一天要喝2000ml的水和牛奶，米汤等东西，哪有那么容易啊，喝水变得非常非常苦难，主要是太痛了，还不能前仰得喝，会从鼻子里面出来，出来的还不是水，主要是血。每次吐口水，反正是各种黑色的淤血，一开始觉得好恶心，后面也就习惯了。呼吸只能靠嘴巴，病床上有氧气，我就只能洗着氧气，挂着点滴，处于半昏迷状态。由于有喝水的任务，我无数次被叫起来喝水，每次喝一口就吐一口，就是痛得喝不下，米粥也就是喝了一小口，基本也不喝了。还好每天挂着少量葡萄糖，不然我几乎就没有吃过东西。到了晚上睡觉，反正就是睡不着，不舒服，麻药的效果我觉得和醉酒是类似的，\n\n## 2018-06-27，周三\n医生把我鼻子里面的棉条用镊子夹了出来，非常痛，这时我才感受到这东西放得有多深，大概有10cm，拉出来的面条被黑色的淤血包裹着，不过没有新鲜的血流出来，说明鼻子没有出血，也算是一个好消息，毕竟当时鼻子里面也是切除了一点东西的。在漱口时，用镜子照了下嘴巴里面，舌苔上有很厚一层白色物质，咽腔两侧有一些手术缝的线，里面有黄黄的物质，感觉非常恶心。\n\n## 2018-06-28，周四\n麻药的效果基本上是过了，脖子也有力气了，头也没有那么痛，但是晚上睡觉嘴巴和喉咙真的太干了，这样醒了后又要喝水，但是喝水会很痛，我基本也是喝不了几口。鸡蛋羹吃得非常恶心，导致我现在都排斥吃东西。\n\n## 2018-06-29，周五\n每一天都比上一天好了点，但还是非常难熬，主要是不能吃喜欢吃的东西，精神和肉体上开始双重折磨。助理医生拿吸管从鼻子里面吸出了好多血，但鼻子还是不通。找到了和我做同一种手术的一个哥们，当时他的状态比我差很多，和他交流了下，基本也是非常痛苦。了解到，他是一名在四季青卖衣服的小老板，常年喝酒应酬，家人反应后他做了检测，也是OSAHS，但他现在已经40+岁了，肯定恢复得没有我快。\n\n## 2018-06-30，周六\n大概6点不到就抽了次血。上午主刀医生查房时，看到我在用嘴巴呼吸，把我叫到换药室，将涂了药水的棉花再一次赛到我的鼻子里，这次赛进去就比较痛，过了几秒再拔出来，又是全部都是黑色的淤血，但感觉鼻子有一点点通了，于是回病床上，叫老爸不停往我鼻子喷清洗剂，我用力把多余的脏东西都排了出来。这时，在站立状态下，我终于可以用鼻子呼吸了。但在躺下的状态下，我还是不能用鼻子呼吸，嘴巴还是很干，晚上根本不能睡好。但是，由于各种用药和点滴，我必须一直在病床上，很容易就睡着了，又开始用嘴巴呼吸，这时鼻子里面又会开始分泌各种物质，醒来时鼻子又会塞住，反反复复。\n\n## 2018-07-01，周日\n由于在医院睡不好，精神状态很差，发了一次脾气，非常后悔。但相对而言，我身体恢复得还行，我就打算提前一天出院，想想在家里睡得比在医院好些。周六的血液报告虽然有几项有问题，但不影响我出院，我就顺利在周日中午出院，我的那位病友当时血液检测都没有通过，他至少还要在医院多待3天。回到家整理了下东西，洗了个澡，伴随着开着中档的加湿器，就睡觉了。期间就醒了两三次，嘴巴还是很干，感觉比医院睡得好些。\n\n## 2018-07-02，周一\n现在是手术后的第7天，已经出院，选择来上班试试，意识还行，身体很疲惫，很饿，晚上睡觉呼吸只能靠嘴巴，会非常干，很容易干醒，讲话可以讲一点，但舌头太干，讲不清楚。早餐照例是流质食品——豆腐脑，咽下去时，喉咙有点痛，非常容易吃到鼻子里去，吃了几小口就吃不下了，如果按照这个速度继续吃，估计1个多小时才能把一碗2块钱的豆腐脑吃完。肚子里面一直是空的，也一直是饥饿的状态，接下去每一天估计只会吃牛奶和一点点糖水/汤水补充能量，加上一些纯净水平衡体内水盐，这样的情况要持续到2018-07-09拆线前。每天都挺漫长。。。","slug":"OSAHS","published":1,"updated":"2018-07-02T07:32:10.000Z","_id":"cjj3wcszb002c3iq2v7h2mb46","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"OSAHS——「阻塞性睡眠呼吸暂停综合征」手术回忆\"><a href=\"#OSAHS——「阻塞性睡眠呼吸暂停综合征」手术回忆\" class=\"headerlink\" title=\"OSAHS——「阻塞性睡眠呼吸暂停综合征」手术回忆\"></a>OSAHS——「阻塞性睡眠呼吸暂停综合征」手术回忆</h3><p>OSAHS，最大的风险就是睡眠时上气道塌陷阻塞引起的呼吸暂停和低通气，导致血氧饱和度非常低，引起白天嗜睡，注意力不集中，记忆力下降等病症，更严重的可能导致窒息。我其实从高中开始就每天睡不好，白天没有精神，可能跟那个时候吃胖得有关。</p>\n<h2 id=\"2018-06-25，周一\"><a href=\"#2018-06-25，周一\" class=\"headerlink\" title=\"2018-06-25，周一\"></a>2018-06-25，周一</h2><p>请假来到「浙江大学医学院附属邵逸夫医院」办理住院手续，心情愉悦，一脸微笑，病床靠窗，窗外是钱江新城的高楼，着实有种度假的感觉，同病房的两位老爷爷还在奇怪我好像没有病啊。由于没有去查阅过任何治疗经历，所以也其实自己也不知道是怎么回事，只知道可能要切除下扁桃体。术前手续其实不多，作为医生的女朋友给我安排得妥妥当当的。</p>\n<p>下午被手术助手之一的金医生叫到办公室，简单得描述了下手术的原理还有流程，我只注意到，这哥们说，手术做完后，会很痛苦，我呢是被安排在周二早上第2台手术，10点左右开始，大概会持续一个小时，全程麻醉，由于要动刀，所以也有可能会痛，要忍，由于手术有窒息风险，插在呼吸道的管子必须到我意识恢复后才能拔出来，那时会非常不舒服，术后要大量饮水，把血冲到肚子里面，保证喉咙湿润。这时我算对这个手术有了一定的认识，还是有点紧张的，毕竟从小到大没有做过手术，还全麻，以上就是我在手术前所需要知道的所有东西。晚上在病床休息，临时被通知被换到明早第一台手术，心里有点慌。</p>\n<h2 id=\"2018-06-26，周二\"><a href=\"#2018-06-26，周二\" class=\"headerlink\" title=\"2018-06-26，周二\"></a>2018-06-26，周二</h2><p>早上6点左右就被工作人员拖出了病房，带到了一个「护士流动站」的地方，不知道有没有记错名字，我是最初几个被拉进来的，然后看着房间里面越来越多的病人被工作人员推进来。做肝肾，胆手术的都有，心情确实不好受，感觉是待宰的羔羊。最最难受的是，在这个房间里面，意识非常清醒的状态下，等了近两个小时，非常煎药，还不如直接来个痛快的。还好女朋友是本院医生，走关系进来陪我说说话，不然是心慌慌。大概8点半，我被推进了看上去挺豪华的手术室，主刀医生和各位助理医生早已在那里等我，随后就是在我身上贴了各种不知道干嘛的小片，还给我开了个玩笑，具体内容真忘记了，然后护士小姐给我带了个氧气罩，让我深呼吸，同时我知道输液的液体已经被换成了麻醉药，一小会儿，我就失去了意识，慢慢睡着了。。。</p>\n<p>当我醒来的时候，还好不是在动刀子的时候，不然想想挺奔溃的。只记得那时我口中插了管子，靠着呼吸机在呼吸，口中感觉不时冒出一点血，量不大，吸一吸就行，身边是女朋友和一个带着口罩面向着显示器的医院，不停得和我说话。我虽然有点头痛，但好像也不是特别难受，不时还能用动作回他们的话，我知道最危险的时候度过了。医生觉得我状态还行，就说可以把管子了，期间要忍一忍，可能有点恶心，其实我觉得也就这样。随后就被拉回了病房，我爸也在病房等我。</p>\n<p>接下去噩梦开始到来，由于从深度麻醉中醒来，头痛得不行，喉咙也非常痛，连舌头也不敢乱动，讲话几乎是不可能的，只能像小孩子一样发出点声音，右边的鼻子中被严严实实得塞了棉条，防止鼻子出血。交流只能是靠着半醒的状态在手机上打字，还时不时打错字。按照医嘱，我一天要喝2000ml的水和牛奶，米汤等东西，哪有那么容易啊，喝水变得非常非常苦难，主要是太痛了，还不能前仰得喝，会从鼻子里面出来，出来的还不是水，主要是血。每次吐口水，反正是各种黑色的淤血，一开始觉得好恶心，后面也就习惯了。呼吸只能靠嘴巴，病床上有氧气，我就只能洗着氧气，挂着点滴，处于半昏迷状态。由于有喝水的任务，我无数次被叫起来喝水，每次喝一口就吐一口，就是痛得喝不下，米粥也就是喝了一小口，基本也不喝了。还好每天挂着少量葡萄糖，不然我几乎就没有吃过东西。到了晚上睡觉，反正就是睡不着，不舒服，麻药的效果我觉得和醉酒是类似的，</p>\n<h2 id=\"2018-06-27，周三\"><a href=\"#2018-06-27，周三\" class=\"headerlink\" title=\"2018-06-27，周三\"></a>2018-06-27，周三</h2><p>医生把我鼻子里面的棉条用镊子夹了出来，非常痛，这时我才感受到这东西放得有多深，大概有10cm，拉出来的面条被黑色的淤血包裹着，不过没有新鲜的血流出来，说明鼻子没有出血，也算是一个好消息，毕竟当时鼻子里面也是切除了一点东西的。在漱口时，用镜子照了下嘴巴里面，舌苔上有很厚一层白色物质，咽腔两侧有一些手术缝的线，里面有黄黄的物质，感觉非常恶心。</p>\n<h2 id=\"2018-06-28，周四\"><a href=\"#2018-06-28，周四\" class=\"headerlink\" title=\"2018-06-28，周四\"></a>2018-06-28，周四</h2><p>麻药的效果基本上是过了，脖子也有力气了，头也没有那么痛，但是晚上睡觉嘴巴和喉咙真的太干了，这样醒了后又要喝水，但是喝水会很痛，我基本也是喝不了几口。鸡蛋羹吃得非常恶心，导致我现在都排斥吃东西。</p>\n<h2 id=\"2018-06-29，周五\"><a href=\"#2018-06-29，周五\" class=\"headerlink\" title=\"2018-06-29，周五\"></a>2018-06-29，周五</h2><p>每一天都比上一天好了点，但还是非常难熬，主要是不能吃喜欢吃的东西，精神和肉体上开始双重折磨。助理医生拿吸管从鼻子里面吸出了好多血，但鼻子还是不通。找到了和我做同一种手术的一个哥们，当时他的状态比我差很多，和他交流了下，基本也是非常痛苦。了解到，他是一名在四季青卖衣服的小老板，常年喝酒应酬，家人反应后他做了检测，也是OSAHS，但他现在已经40+岁了，肯定恢复得没有我快。</p>\n<h2 id=\"2018-06-30，周六\"><a href=\"#2018-06-30，周六\" class=\"headerlink\" title=\"2018-06-30，周六\"></a>2018-06-30，周六</h2><p>大概6点不到就抽了次血。上午主刀医生查房时，看到我在用嘴巴呼吸，把我叫到换药室，将涂了药水的棉花再一次赛到我的鼻子里，这次赛进去就比较痛，过了几秒再拔出来，又是全部都是黑色的淤血，但感觉鼻子有一点点通了，于是回病床上，叫老爸不停往我鼻子喷清洗剂，我用力把多余的脏东西都排了出来。这时，在站立状态下，我终于可以用鼻子呼吸了。但在躺下的状态下，我还是不能用鼻子呼吸，嘴巴还是很干，晚上根本不能睡好。但是，由于各种用药和点滴，我必须一直在病床上，很容易就睡着了，又开始用嘴巴呼吸，这时鼻子里面又会开始分泌各种物质，醒来时鼻子又会塞住，反反复复。</p>\n<h2 id=\"2018-07-01，周日\"><a href=\"#2018-07-01，周日\" class=\"headerlink\" title=\"2018-07-01，周日\"></a>2018-07-01，周日</h2><p>由于在医院睡不好，精神状态很差，发了一次脾气，非常后悔。但相对而言，我身体恢复得还行，我就打算提前一天出院，想想在家里睡得比在医院好些。周六的血液报告虽然有几项有问题，但不影响我出院，我就顺利在周日中午出院，我的那位病友当时血液检测都没有通过，他至少还要在医院多待3天。回到家整理了下东西，洗了个澡，伴随着开着中档的加湿器，就睡觉了。期间就醒了两三次，嘴巴还是很干，感觉比医院睡得好些。</p>\n<h2 id=\"2018-07-02，周一\"><a href=\"#2018-07-02，周一\" class=\"headerlink\" title=\"2018-07-02，周一\"></a>2018-07-02，周一</h2><p>现在是手术后的第7天，已经出院，选择来上班试试，意识还行，身体很疲惫，很饿，晚上睡觉呼吸只能靠嘴巴，会非常干，很容易干醒，讲话可以讲一点，但舌头太干，讲不清楚。早餐照例是流质食品——豆腐脑，咽下去时，喉咙有点痛，非常容易吃到鼻子里去，吃了几小口就吃不下了，如果按照这个速度继续吃，估计1个多小时才能把一碗2块钱的豆腐脑吃完。肚子里面一直是空的，也一直是饥饿的状态，接下去每一天估计只会吃牛奶和一点点糖水/汤水补充能量，加上一些纯净水平衡体内水盐，这样的情况要持续到2018-07-09拆线前。每天都挺漫长。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"OSAHS——「阻塞性睡眠呼吸暂停综合征」手术回忆\"><a href=\"#OSAHS——「阻塞性睡眠呼吸暂停综合征」手术回忆\" class=\"headerlink\" title=\"OSAHS——「阻塞性睡眠呼吸暂停综合征」手术回忆\"></a>OSAHS——「阻塞性睡眠呼吸暂停综合征」手术回忆</h3><p>OSAHS，最大的风险就是睡眠时上气道塌陷阻塞引起的呼吸暂停和低通气，导致血氧饱和度非常低，引起白天嗜睡，注意力不集中，记忆力下降等病症，更严重的可能导致窒息。我其实从高中开始就每天睡不好，白天没有精神，可能跟那个时候吃胖得有关。</p>\n<h2 id=\"2018-06-25，周一\"><a href=\"#2018-06-25，周一\" class=\"headerlink\" title=\"2018-06-25，周一\"></a>2018-06-25，周一</h2><p>请假来到「浙江大学医学院附属邵逸夫医院」办理住院手续，心情愉悦，一脸微笑，病床靠窗，窗外是钱江新城的高楼，着实有种度假的感觉，同病房的两位老爷爷还在奇怪我好像没有病啊。由于没有去查阅过任何治疗经历，所以也其实自己也不知道是怎么回事，只知道可能要切除下扁桃体。术前手续其实不多，作为医生的女朋友给我安排得妥妥当当的。</p>\n<p>下午被手术助手之一的金医生叫到办公室，简单得描述了下手术的原理还有流程，我只注意到，这哥们说，手术做完后，会很痛苦，我呢是被安排在周二早上第2台手术，10点左右开始，大概会持续一个小时，全程麻醉，由于要动刀，所以也有可能会痛，要忍，由于手术有窒息风险，插在呼吸道的管子必须到我意识恢复后才能拔出来，那时会非常不舒服，术后要大量饮水，把血冲到肚子里面，保证喉咙湿润。这时我算对这个手术有了一定的认识，还是有点紧张的，毕竟从小到大没有做过手术，还全麻，以上就是我在手术前所需要知道的所有东西。晚上在病床休息，临时被通知被换到明早第一台手术，心里有点慌。</p>\n<h2 id=\"2018-06-26，周二\"><a href=\"#2018-06-26，周二\" class=\"headerlink\" title=\"2018-06-26，周二\"></a>2018-06-26，周二</h2><p>早上6点左右就被工作人员拖出了病房，带到了一个「护士流动站」的地方，不知道有没有记错名字，我是最初几个被拉进来的，然后看着房间里面越来越多的病人被工作人员推进来。做肝肾，胆手术的都有，心情确实不好受，感觉是待宰的羔羊。最最难受的是，在这个房间里面，意识非常清醒的状态下，等了近两个小时，非常煎药，还不如直接来个痛快的。还好女朋友是本院医生，走关系进来陪我说说话，不然是心慌慌。大概8点半，我被推进了看上去挺豪华的手术室，主刀医生和各位助理医生早已在那里等我，随后就是在我身上贴了各种不知道干嘛的小片，还给我开了个玩笑，具体内容真忘记了，然后护士小姐给我带了个氧气罩，让我深呼吸，同时我知道输液的液体已经被换成了麻醉药，一小会儿，我就失去了意识，慢慢睡着了。。。</p>\n<p>当我醒来的时候，还好不是在动刀子的时候，不然想想挺奔溃的。只记得那时我口中插了管子，靠着呼吸机在呼吸，口中感觉不时冒出一点血，量不大，吸一吸就行，身边是女朋友和一个带着口罩面向着显示器的医院，不停得和我说话。我虽然有点头痛，但好像也不是特别难受，不时还能用动作回他们的话，我知道最危险的时候度过了。医生觉得我状态还行，就说可以把管子了，期间要忍一忍，可能有点恶心，其实我觉得也就这样。随后就被拉回了病房，我爸也在病房等我。</p>\n<p>接下去噩梦开始到来，由于从深度麻醉中醒来，头痛得不行，喉咙也非常痛，连舌头也不敢乱动，讲话几乎是不可能的，只能像小孩子一样发出点声音，右边的鼻子中被严严实实得塞了棉条，防止鼻子出血。交流只能是靠着半醒的状态在手机上打字，还时不时打错字。按照医嘱，我一天要喝2000ml的水和牛奶，米汤等东西，哪有那么容易啊，喝水变得非常非常苦难，主要是太痛了，还不能前仰得喝，会从鼻子里面出来，出来的还不是水，主要是血。每次吐口水，反正是各种黑色的淤血，一开始觉得好恶心，后面也就习惯了。呼吸只能靠嘴巴，病床上有氧气，我就只能洗着氧气，挂着点滴，处于半昏迷状态。由于有喝水的任务，我无数次被叫起来喝水，每次喝一口就吐一口，就是痛得喝不下，米粥也就是喝了一小口，基本也不喝了。还好每天挂着少量葡萄糖，不然我几乎就没有吃过东西。到了晚上睡觉，反正就是睡不着，不舒服，麻药的效果我觉得和醉酒是类似的，</p>\n<h2 id=\"2018-06-27，周三\"><a href=\"#2018-06-27，周三\" class=\"headerlink\" title=\"2018-06-27，周三\"></a>2018-06-27，周三</h2><p>医生把我鼻子里面的棉条用镊子夹了出来，非常痛，这时我才感受到这东西放得有多深，大概有10cm，拉出来的面条被黑色的淤血包裹着，不过没有新鲜的血流出来，说明鼻子没有出血，也算是一个好消息，毕竟当时鼻子里面也是切除了一点东西的。在漱口时，用镜子照了下嘴巴里面，舌苔上有很厚一层白色物质，咽腔两侧有一些手术缝的线，里面有黄黄的物质，感觉非常恶心。</p>\n<h2 id=\"2018-06-28，周四\"><a href=\"#2018-06-28，周四\" class=\"headerlink\" title=\"2018-06-28，周四\"></a>2018-06-28，周四</h2><p>麻药的效果基本上是过了，脖子也有力气了，头也没有那么痛，但是晚上睡觉嘴巴和喉咙真的太干了，这样醒了后又要喝水，但是喝水会很痛，我基本也是喝不了几口。鸡蛋羹吃得非常恶心，导致我现在都排斥吃东西。</p>\n<h2 id=\"2018-06-29，周五\"><a href=\"#2018-06-29，周五\" class=\"headerlink\" title=\"2018-06-29，周五\"></a>2018-06-29，周五</h2><p>每一天都比上一天好了点，但还是非常难熬，主要是不能吃喜欢吃的东西，精神和肉体上开始双重折磨。助理医生拿吸管从鼻子里面吸出了好多血，但鼻子还是不通。找到了和我做同一种手术的一个哥们，当时他的状态比我差很多，和他交流了下，基本也是非常痛苦。了解到，他是一名在四季青卖衣服的小老板，常年喝酒应酬，家人反应后他做了检测，也是OSAHS，但他现在已经40+岁了，肯定恢复得没有我快。</p>\n<h2 id=\"2018-06-30，周六\"><a href=\"#2018-06-30，周六\" class=\"headerlink\" title=\"2018-06-30，周六\"></a>2018-06-30，周六</h2><p>大概6点不到就抽了次血。上午主刀医生查房时，看到我在用嘴巴呼吸，把我叫到换药室，将涂了药水的棉花再一次赛到我的鼻子里，这次赛进去就比较痛，过了几秒再拔出来，又是全部都是黑色的淤血，但感觉鼻子有一点点通了，于是回病床上，叫老爸不停往我鼻子喷清洗剂，我用力把多余的脏东西都排了出来。这时，在站立状态下，我终于可以用鼻子呼吸了。但在躺下的状态下，我还是不能用鼻子呼吸，嘴巴还是很干，晚上根本不能睡好。但是，由于各种用药和点滴，我必须一直在病床上，很容易就睡着了，又开始用嘴巴呼吸，这时鼻子里面又会开始分泌各种物质，醒来时鼻子又会塞住，反反复复。</p>\n<h2 id=\"2018-07-01，周日\"><a href=\"#2018-07-01，周日\" class=\"headerlink\" title=\"2018-07-01，周日\"></a>2018-07-01，周日</h2><p>由于在医院睡不好，精神状态很差，发了一次脾气，非常后悔。但相对而言，我身体恢复得还行，我就打算提前一天出院，想想在家里睡得比在医院好些。周六的血液报告虽然有几项有问题，但不影响我出院，我就顺利在周日中午出院，我的那位病友当时血液检测都没有通过，他至少还要在医院多待3天。回到家整理了下东西，洗了个澡，伴随着开着中档的加湿器，就睡觉了。期间就醒了两三次，嘴巴还是很干，感觉比医院睡得好些。</p>\n<h2 id=\"2018-07-02，周一\"><a href=\"#2018-07-02，周一\" class=\"headerlink\" title=\"2018-07-02，周一\"></a>2018-07-02，周一</h2><p>现在是手术后的第7天，已经出院，选择来上班试试，意识还行，身体很疲惫，很饿，晚上睡觉呼吸只能靠嘴巴，会非常干，很容易干醒，讲话可以讲一点，但舌头太干，讲不清楚。早餐照例是流质食品——豆腐脑，咽下去时，喉咙有点痛，非常容易吃到鼻子里去，吃了几小口就吃不下了，如果按照这个速度继续吃，估计1个多小时才能把一碗2块钱的豆腐脑吃完。肚子里面一直是空的，也一直是饥饿的状态，接下去每一天估计只会吃牛奶和一点点糖水/汤水补充能量，加上一些纯净水平衡体内水盐，这样的情况要持续到2018-07-09拆线前。每天都挺漫长。。。</p>\n"},{"title":"Netty-Performance-Test","date":"2017-12-07T04:52:29.000Z","_content":"\nhttps://www.infoq.com/news/2013/11/netty4-twitter","source":"_posts/Netty-Performance-Test.md","raw":"---\ntitle: Netty-Performance-Test\ndate: 2017-12-07 12:52:29\ntags: Netty\n---\n\nhttps://www.infoq.com/news/2013/11/netty4-twitter","slug":"Netty-Performance-Test","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszb002e3iq2xb0uzft0","content":"<p><a href=\"https://www.infoq.com/news/2013/11/netty4-twitter\" target=\"_blank\" rel=\"external\">https://www.infoq.com/news/2013/11/netty4-twitter</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.infoq.com/news/2013/11/netty4-twitter\" target=\"_blank\" rel=\"external\">https://www.infoq.com/news/2013/11/netty4-twitter</a></p>\n"},{"title":"Netty-Jemalloc","date":"2017-12-06T06:07:49.000Z","_content":"\nhttp://wangkaisino.blog.163.com/blog/static/1870444202011431112323846\n\n转载:\n\n在Netty4中引入了新的内存管理机制极大地提升其性能，本文将对该内在管理机制进行剖析。\n\n这里[有篇文章](http://www.infoq.com/news/2013/11/netty4-twitter)讲述了在推特(Twitter)内部\n使用Netty的状况以及Netty4所带来的性能收益。\n\n<!--more-->\n\n在分析Netty4的`PooledByteBufAllocator`之前，我们最好先认识一下[jemalloc](http://www.canonware.com/jemalloc/)。\nNetty在4.0之前的版本已经尝试过通过优化内存管理的方式来提高性能（如果我没有记错的话），但4.0中的改进则特别\n显著。在这个版本中，其内存管理实现主要是参考了`jemalloc`。\n\n# jemalloc\n\n**jemalloc** 是由Jason Evans在FreeBSD项目中引入的，其主旨是为了提升在并发环境下内存的分配效率。说白了就是替代\n`malloc`。malloc之所以没有照顾到并发环境，那是由于在那个时代并发还只在理论，未曾普及。而现在则是多核的天下，连\n手机都动则2、4核，甚至于8核了。与jemalloc齐名的还有Google的[tcmalloc](https://code.google.com/p/gperftools/)，其\n实现与jemalloc多少也有点相似，这里不做介绍。\n\n## jemalloc的理念\n\n我们以买火车票为例，来简单地说明一下jemalloc与malloc的区别。原来的malloc，相当于只有一个售票窗口的售票大厅，\n而jemalloc则在同一个售票大厅里面适量地增加的窗口。当然，火车票的总量(即内存大小)是不变的，买票的人相当于线程了。\n说起来这也是很自然的事情的。\n\n> 在这里，一个售票窗口就是相当于一个**Arena**。\n\nArena则按页(Page)来的管理内存，也就是说，一张车票就相当于一页。（后面就不太适合用火车票的例子了）。\n\n同时，jemalloc还根据所请求的内存大小，对其进行分类。如下图：\n\n![jemalloc allocation size category](http://farm4.staticflickr.com/3749/12402575993_30e006725c_o.png)\n\n默认情况下，Page的大小为4KB。如图，有三类，small、large和huge。small类的内存请求都属于一个内存页之内\n（没有半张车票出售:(）。另外，在small类里面，又分了三个子类，分别是Tiny、Quantum-Spaced和Sub-page。\n这几个概念都在Netty中得到应用。\n\n每个线程都与某个Arena绑定在一起，线程采用round-robin算法来绑定到某个Arena。\n\n> 这里有个问题，就是与某个Arena相关的一批线程使用内存资源过快，导致该Arena的内存资源全部消耗殆尽，\n> 而其它的Arena又有盈余，这时怎么处理？能否借用。\n> \n> 目前还没有对jemalloc本身的实现做过多的研究。\n\n通过对jemalloc有个简单的了解后，我们再来看看，Netty4是如何借鉴jemalloc的经验的。需要注意的是，\njemalloc的实现，要远比Netty4复杂，一个是系统层的，一个则是应用层的。但两者的思想是相通的。\n\n# Netty4中的内存管理\n\n以下内容所参考的代码是`netty-4.0.15.Final`。\n\nNetty4中，内存池管理的入口点是`PooledByteBufAllocator`。在该实现中，除了Arena和Page之外，\n还一个Chunk的概念。一个Arena由多个Chunk组成，而Chunk则由N个Page组成。\n\n默认配置中，\n\n\n``` java\n// 默认页面大小为8KB\nint defaultPageSize = SystemPropertyUtil.getInt(\"io.netty.allocator.pageSize\", 8192); \n\n// 默认的Chunk大小为16MB，即由2048个页面组成\nint defaultMaxOrder = SystemPropertyUtil.getInt(\"io.netty.allocator.maxOrder\", 11);\nfinal int defaultChunkSize = DEFAULT_PAGE_SIZE << DEFAULT_MAX_ORDER;\n\n// 默认情况下，一个Arena由3个Chunk组成，且所有Arena（就同一类而言）所占用的内存总数，\n// 不能超过可用内存的一半(50%)。\n\nDEFAULT_NUM_HEAP_ARENA = Math.max(0,\n        SystemPropertyUtil.getInt(\n                \"io.netty.allocator.numHeapArenas\",\n                (int) Math.min(\n                        runtime.availableProcessors(),\n                        Runtime.getRuntime().maxMemory() / defaultChunkSize / 2 / 3)));\nDEFAULT_NUM_DIRECT_ARENA = Math.max(0,\n        SystemPropertyUtil.getInt(\n                \"io.netty.allocator.numDirectArenas\",\n                (int) Math.min(\n                        runtime.availableProcessors(),\n                        PlatformDependent.maxDirectMemory() / defaultChunkSize / 2 / 3)));\n```\n\n\n根据以上代码，我们发现，Arena是分为两类的，一类是基于堆；另一类则是Direct内存（直接向操作系统请求的）。\n具体使用哪一类，默认是根据所使用的虚拟机而定，优先使用Direct类型（如果可用的话）。判断的条件是，\n看能否访问JVM的`Unsafe`类。具体可以参考`PlatformDependent.hasUnsafe()`方法。\n\n> 这里提到的两类不会被同时使用的！\n\n\n另外，对于内存请求大小的分类，这里也有一些变动。对于所请求内存的大小N\n\n``` java\nif N < PAGE_SIZE:\n\tif N < 512:\n\t\treturn TINY;\n\telse\n\t\treturn SMALL;\nelif N > CHUNK_SIZE:\n\treturn HUGE;\nelse\n\treturn LARGE;\n```\n\n## 内存管理\n\n现在，我们来仔细地看看内存分配的过程。\n\n\n``` java\nPooledByteBufAllocator alloc = new PooledByteBufAllocator(PlatformDependent.directBufferPreferred());\nByteBuf buff = alloc.ioBuffer(N);\n```\n\n\n假设在当前的JVM环境中，Direct内存可用的。那当我们尝试去申请N字节的内存时，其实现流程如下：\n\n1.  获取一个ByteBuf对象，但是该对象未与任何可用内存空间关联。\n2.  检查N的大小，并对N进行修正。。\n3.  分配内存。\n\n\n对N的修正：\n\n``` java\nprivate int normalizeCapacity(int reqCapacity) {\n    if (reqCapacity < 0) {\n        throw new IllegalArgumentException(\"capacity: \" + reqCapacity + \" (expected: 0+)\");\n    }\n    if (reqCapacity >= chunkSize) {\n        return reqCapacity;\n    }\n\n    if ((reqCapacity & 0xFFFFFE00) != 0) { // >= 512\n        // Doubled\n\n        int normalizedCapacity = reqCapacity;\n        normalizedCapacity |= normalizedCapacity >>>  1;\n        normalizedCapacity |= normalizedCapacity >>>  2;\n        normalizedCapacity |= normalizedCapacity >>>  4;\n        normalizedCapacity |= normalizedCapacity >>>  8;\n        normalizedCapacity |= normalizedCapacity >>> 16;\n        normalizedCapacity ++;\n\n        if (normalizedCapacity < 0) {\n            normalizedCapacity >>>= 1;\n        }\n\n        return normalizedCapacity;\n    }\n\n    // Quantum-spaced\n    if ((reqCapacity & 15) == 0) {\n        return reqCapacity;\n    }\n\n    return (reqCapacity & ~15) + 16;\n}\n```\n\n说到内存的分配，则需要对页的管理有一定的了解。\n\n### 内存页的管理模型\n\nNetty4使用了二叉树来管理每一个内存页。假设一个Chunk是由连续的N块内存页组成，\n则Netty4使用一个长度为`2N`的整型数组来记录和管理每一个内存页的使用情况。\n\n``` java\nint[] memoryMap = new int[N << 1]\n```\n\n假设N=4，则下图，基于`memoryMap`的二叉树的结构。每个结点的序号为数组的索引值。其中4、5、6、7是这四个叶子节点，\n分别用来记录4个内存页的使用状态。而2、3是用来表示其管辖的内存页的使用状态。节点1则管理整个Chunk的状态。\n\n![基于一维数组的二叉树](http://farm3.staticflickr.com/2805/12403894375_2ee7cf93a4_o.png)\n\n内存页的状态有四种：\n\n``` java\nprivate static final int ST_UNUSED = 0;  // 初始状态，未使用\n\nprivate static final int ST_BRANCH = 1;  // 只对非叶子节点有效，表明该节点下某一部分叶子节点被使用\n\n// 被使用，如果是叶子节点，则表明对应的内存页已经分配出去了\n// 如果是非叶子节点，则表明该节点所管辖的内存页已经全部分配出去了\nprivate static final int ST_ALLOCATED = 2; \n\n// 只对叶子节点有效，表示内存页里面的一部分被分配出去了。这种情况属于Tiny类型的内存请求。\nprivate static final int ST_ALLOCATED_SUBPAGE = ST_ALLOCATED | 1;\n```\n\n### 内存页的分配\n\n内存页的分配有两种情况，有多页分配和页内分配。这里我们先说多页（1个内存页以上）的分配。\n当请求的内存大小大于一个内存页时，`PooledByteBufAllocator`会通过遍历`memoryMap`来，来找出合适内存页。\n\n1. 首先，它要判断根节点1是否已经被分配，如果是，则表示当前的个Chunk已经没有可用的空间，它需要去其的Chunk找了。\n2. 接着，随机选择当前节点的某一个子节点（2或者3），判断是否有可用空间\n3. 重复步骤2，直到找到可用的内存页\n\n> 先写到这里，以下剩余内容的目录。另外，对`memoryMap`中的值，也需要进一步的说明,\n> 因为关系具体的内存位置。\n> \n> 写博客果然比较费事！\n\n### 页内分配\n\n# 内存的释放\n\n## 内存页的释放\n\n## 页内释放\n\n# 其它\n\n## ByteBuf实例缓存","source":"_posts/Netty-Jemalloc.md","raw":"---\ntitle: Netty-Jemalloc\ndate: 2017-12-06 14:07:49\ntags: Netty\n---\n\nhttp://wangkaisino.blog.163.com/blog/static/1870444202011431112323846\n\n转载:\n\n在Netty4中引入了新的内存管理机制极大地提升其性能，本文将对该内在管理机制进行剖析。\n\n这里[有篇文章](http://www.infoq.com/news/2013/11/netty4-twitter)讲述了在推特(Twitter)内部\n使用Netty的状况以及Netty4所带来的性能收益。\n\n<!--more-->\n\n在分析Netty4的`PooledByteBufAllocator`之前，我们最好先认识一下[jemalloc](http://www.canonware.com/jemalloc/)。\nNetty在4.0之前的版本已经尝试过通过优化内存管理的方式来提高性能（如果我没有记错的话），但4.0中的改进则特别\n显著。在这个版本中，其内存管理实现主要是参考了`jemalloc`。\n\n# jemalloc\n\n**jemalloc** 是由Jason Evans在FreeBSD项目中引入的，其主旨是为了提升在并发环境下内存的分配效率。说白了就是替代\n`malloc`。malloc之所以没有照顾到并发环境，那是由于在那个时代并发还只在理论，未曾普及。而现在则是多核的天下，连\n手机都动则2、4核，甚至于8核了。与jemalloc齐名的还有Google的[tcmalloc](https://code.google.com/p/gperftools/)，其\n实现与jemalloc多少也有点相似，这里不做介绍。\n\n## jemalloc的理念\n\n我们以买火车票为例，来简单地说明一下jemalloc与malloc的区别。原来的malloc，相当于只有一个售票窗口的售票大厅，\n而jemalloc则在同一个售票大厅里面适量地增加的窗口。当然，火车票的总量(即内存大小)是不变的，买票的人相当于线程了。\n说起来这也是很自然的事情的。\n\n> 在这里，一个售票窗口就是相当于一个**Arena**。\n\nArena则按页(Page)来的管理内存，也就是说，一张车票就相当于一页。（后面就不太适合用火车票的例子了）。\n\n同时，jemalloc还根据所请求的内存大小，对其进行分类。如下图：\n\n![jemalloc allocation size category](http://farm4.staticflickr.com/3749/12402575993_30e006725c_o.png)\n\n默认情况下，Page的大小为4KB。如图，有三类，small、large和huge。small类的内存请求都属于一个内存页之内\n（没有半张车票出售:(）。另外，在small类里面，又分了三个子类，分别是Tiny、Quantum-Spaced和Sub-page。\n这几个概念都在Netty中得到应用。\n\n每个线程都与某个Arena绑定在一起，线程采用round-robin算法来绑定到某个Arena。\n\n> 这里有个问题，就是与某个Arena相关的一批线程使用内存资源过快，导致该Arena的内存资源全部消耗殆尽，\n> 而其它的Arena又有盈余，这时怎么处理？能否借用。\n> \n> 目前还没有对jemalloc本身的实现做过多的研究。\n\n通过对jemalloc有个简单的了解后，我们再来看看，Netty4是如何借鉴jemalloc的经验的。需要注意的是，\njemalloc的实现，要远比Netty4复杂，一个是系统层的，一个则是应用层的。但两者的思想是相通的。\n\n# Netty4中的内存管理\n\n以下内容所参考的代码是`netty-4.0.15.Final`。\n\nNetty4中，内存池管理的入口点是`PooledByteBufAllocator`。在该实现中，除了Arena和Page之外，\n还一个Chunk的概念。一个Arena由多个Chunk组成，而Chunk则由N个Page组成。\n\n默认配置中，\n\n\n``` java\n// 默认页面大小为8KB\nint defaultPageSize = SystemPropertyUtil.getInt(\"io.netty.allocator.pageSize\", 8192); \n\n// 默认的Chunk大小为16MB，即由2048个页面组成\nint defaultMaxOrder = SystemPropertyUtil.getInt(\"io.netty.allocator.maxOrder\", 11);\nfinal int defaultChunkSize = DEFAULT_PAGE_SIZE << DEFAULT_MAX_ORDER;\n\n// 默认情况下，一个Arena由3个Chunk组成，且所有Arena（就同一类而言）所占用的内存总数，\n// 不能超过可用内存的一半(50%)。\n\nDEFAULT_NUM_HEAP_ARENA = Math.max(0,\n        SystemPropertyUtil.getInt(\n                \"io.netty.allocator.numHeapArenas\",\n                (int) Math.min(\n                        runtime.availableProcessors(),\n                        Runtime.getRuntime().maxMemory() / defaultChunkSize / 2 / 3)));\nDEFAULT_NUM_DIRECT_ARENA = Math.max(0,\n        SystemPropertyUtil.getInt(\n                \"io.netty.allocator.numDirectArenas\",\n                (int) Math.min(\n                        runtime.availableProcessors(),\n                        PlatformDependent.maxDirectMemory() / defaultChunkSize / 2 / 3)));\n```\n\n\n根据以上代码，我们发现，Arena是分为两类的，一类是基于堆；另一类则是Direct内存（直接向操作系统请求的）。\n具体使用哪一类，默认是根据所使用的虚拟机而定，优先使用Direct类型（如果可用的话）。判断的条件是，\n看能否访问JVM的`Unsafe`类。具体可以参考`PlatformDependent.hasUnsafe()`方法。\n\n> 这里提到的两类不会被同时使用的！\n\n\n另外，对于内存请求大小的分类，这里也有一些变动。对于所请求内存的大小N\n\n``` java\nif N < PAGE_SIZE:\n\tif N < 512:\n\t\treturn TINY;\n\telse\n\t\treturn SMALL;\nelif N > CHUNK_SIZE:\n\treturn HUGE;\nelse\n\treturn LARGE;\n```\n\n## 内存管理\n\n现在，我们来仔细地看看内存分配的过程。\n\n\n``` java\nPooledByteBufAllocator alloc = new PooledByteBufAllocator(PlatformDependent.directBufferPreferred());\nByteBuf buff = alloc.ioBuffer(N);\n```\n\n\n假设在当前的JVM环境中，Direct内存可用的。那当我们尝试去申请N字节的内存时，其实现流程如下：\n\n1.  获取一个ByteBuf对象，但是该对象未与任何可用内存空间关联。\n2.  检查N的大小，并对N进行修正。。\n3.  分配内存。\n\n\n对N的修正：\n\n``` java\nprivate int normalizeCapacity(int reqCapacity) {\n    if (reqCapacity < 0) {\n        throw new IllegalArgumentException(\"capacity: \" + reqCapacity + \" (expected: 0+)\");\n    }\n    if (reqCapacity >= chunkSize) {\n        return reqCapacity;\n    }\n\n    if ((reqCapacity & 0xFFFFFE00) != 0) { // >= 512\n        // Doubled\n\n        int normalizedCapacity = reqCapacity;\n        normalizedCapacity |= normalizedCapacity >>>  1;\n        normalizedCapacity |= normalizedCapacity >>>  2;\n        normalizedCapacity |= normalizedCapacity >>>  4;\n        normalizedCapacity |= normalizedCapacity >>>  8;\n        normalizedCapacity |= normalizedCapacity >>> 16;\n        normalizedCapacity ++;\n\n        if (normalizedCapacity < 0) {\n            normalizedCapacity >>>= 1;\n        }\n\n        return normalizedCapacity;\n    }\n\n    // Quantum-spaced\n    if ((reqCapacity & 15) == 0) {\n        return reqCapacity;\n    }\n\n    return (reqCapacity & ~15) + 16;\n}\n```\n\n说到内存的分配，则需要对页的管理有一定的了解。\n\n### 内存页的管理模型\n\nNetty4使用了二叉树来管理每一个内存页。假设一个Chunk是由连续的N块内存页组成，\n则Netty4使用一个长度为`2N`的整型数组来记录和管理每一个内存页的使用情况。\n\n``` java\nint[] memoryMap = new int[N << 1]\n```\n\n假设N=4，则下图，基于`memoryMap`的二叉树的结构。每个结点的序号为数组的索引值。其中4、5、6、7是这四个叶子节点，\n分别用来记录4个内存页的使用状态。而2、3是用来表示其管辖的内存页的使用状态。节点1则管理整个Chunk的状态。\n\n![基于一维数组的二叉树](http://farm3.staticflickr.com/2805/12403894375_2ee7cf93a4_o.png)\n\n内存页的状态有四种：\n\n``` java\nprivate static final int ST_UNUSED = 0;  // 初始状态，未使用\n\nprivate static final int ST_BRANCH = 1;  // 只对非叶子节点有效，表明该节点下某一部分叶子节点被使用\n\n// 被使用，如果是叶子节点，则表明对应的内存页已经分配出去了\n// 如果是非叶子节点，则表明该节点所管辖的内存页已经全部分配出去了\nprivate static final int ST_ALLOCATED = 2; \n\n// 只对叶子节点有效，表示内存页里面的一部分被分配出去了。这种情况属于Tiny类型的内存请求。\nprivate static final int ST_ALLOCATED_SUBPAGE = ST_ALLOCATED | 1;\n```\n\n### 内存页的分配\n\n内存页的分配有两种情况，有多页分配和页内分配。这里我们先说多页（1个内存页以上）的分配。\n当请求的内存大小大于一个内存页时，`PooledByteBufAllocator`会通过遍历`memoryMap`来，来找出合适内存页。\n\n1. 首先，它要判断根节点1是否已经被分配，如果是，则表示当前的个Chunk已经没有可用的空间，它需要去其的Chunk找了。\n2. 接着，随机选择当前节点的某一个子节点（2或者3），判断是否有可用空间\n3. 重复步骤2，直到找到可用的内存页\n\n> 先写到这里，以下剩余内容的目录。另外，对`memoryMap`中的值，也需要进一步的说明,\n> 因为关系具体的内存位置。\n> \n> 写博客果然比较费事！\n\n### 页内分配\n\n# 内存的释放\n\n## 内存页的释放\n\n## 页内释放\n\n# 其它\n\n## ByteBuf实例缓存","slug":"Netty-Jemalloc","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszc002g3iq23ojidxuk","content":"<p><a href=\"http://wangkaisino.blog.163.com/blog/static/1870444202011431112323846\" target=\"_blank\" rel=\"external\">http://wangkaisino.blog.163.com/blog/static/1870444202011431112323846</a></p>\n<p>转载:</p>\n<p>在Netty4中引入了新的内存管理机制极大地提升其性能，本文将对该内在管理机制进行剖析。</p>\n<p>这里<a href=\"http://www.infoq.com/news/2013/11/netty4-twitter\" target=\"_blank\" rel=\"external\">有篇文章</a>讲述了在推特(Twitter)内部<br>使用Netty的状况以及Netty4所带来的性能收益。</p>\n<a id=\"more\"></a>\n<p>在分析Netty4的<code>PooledByteBufAllocator</code>之前，我们最好先认识一下<a href=\"http://www.canonware.com/jemalloc/\" target=\"_blank\" rel=\"external\">jemalloc</a>。<br>Netty在4.0之前的版本已经尝试过通过优化内存管理的方式来提高性能（如果我没有记错的话），但4.0中的改进则特别<br>显著。在这个版本中，其内存管理实现主要是参考了<code>jemalloc</code>。</p>\n<h1 id=\"jemalloc\"><a href=\"#jemalloc\" class=\"headerlink\" title=\"jemalloc\"></a>jemalloc</h1><p><strong>jemalloc</strong> 是由Jason Evans在FreeBSD项目中引入的，其主旨是为了提升在并发环境下内存的分配效率。说白了就是替代<br><code>malloc</code>。malloc之所以没有照顾到并发环境，那是由于在那个时代并发还只在理论，未曾普及。而现在则是多核的天下，连<br>手机都动则2、4核，甚至于8核了。与jemalloc齐名的还有Google的<a href=\"https://code.google.com/p/gperftools/\" target=\"_blank\" rel=\"external\">tcmalloc</a>，其<br>实现与jemalloc多少也有点相似，这里不做介绍。</p>\n<h2 id=\"jemalloc的理念\"><a href=\"#jemalloc的理念\" class=\"headerlink\" title=\"jemalloc的理念\"></a>jemalloc的理念</h2><p>我们以买火车票为例，来简单地说明一下jemalloc与malloc的区别。原来的malloc，相当于只有一个售票窗口的售票大厅，<br>而jemalloc则在同一个售票大厅里面适量地增加的窗口。当然，火车票的总量(即内存大小)是不变的，买票的人相当于线程了。<br>说起来这也是很自然的事情的。</p>\n<blockquote>\n<p>在这里，一个售票窗口就是相当于一个<strong>Arena</strong>。</p>\n</blockquote>\n<p>Arena则按页(Page)来的管理内存，也就是说，一张车票就相当于一页。（后面就不太适合用火车票的例子了）。</p>\n<p>同时，jemalloc还根据所请求的内存大小，对其进行分类。如下图：</p>\n<p><img src=\"http://farm4.staticflickr.com/3749/12402575993_30e006725c_o.png\" alt=\"jemalloc allocation size category\"></p>\n<p>默认情况下，Page的大小为4KB。如图，有三类，small、large和huge。small类的内存请求都属于一个内存页之内<br>（没有半张车票出售:(）。另外，在small类里面，又分了三个子类，分别是Tiny、Quantum-Spaced和Sub-page。<br>这几个概念都在Netty中得到应用。</p>\n<p>每个线程都与某个Arena绑定在一起，线程采用round-robin算法来绑定到某个Arena。</p>\n<blockquote>\n<p>这里有个问题，就是与某个Arena相关的一批线程使用内存资源过快，导致该Arena的内存资源全部消耗殆尽，<br>而其它的Arena又有盈余，这时怎么处理？能否借用。</p>\n<p>目前还没有对jemalloc本身的实现做过多的研究。</p>\n</blockquote>\n<p>通过对jemalloc有个简单的了解后，我们再来看看，Netty4是如何借鉴jemalloc的经验的。需要注意的是，<br>jemalloc的实现，要远比Netty4复杂，一个是系统层的，一个则是应用层的。但两者的思想是相通的。</p>\n<h1 id=\"Netty4中的内存管理\"><a href=\"#Netty4中的内存管理\" class=\"headerlink\" title=\"Netty4中的内存管理\"></a>Netty4中的内存管理</h1><p>以下内容所参考的代码是<code>netty-4.0.15.Final</code>。</p>\n<p>Netty4中，内存池管理的入口点是<code>PooledByteBufAllocator</code>。在该实现中，除了Arena和Page之外，<br>还一个Chunk的概念。一个Arena由多个Chunk组成，而Chunk则由N个Page组成。</p>\n<p>默认配置中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 默认页面大小为8KB</span></div><div class=\"line\"><span class=\"keyword\">int</span> defaultPageSize = SystemPropertyUtil.getInt(<span class=\"string\">\"io.netty.allocator.pageSize\"</span>, <span class=\"number\">8192</span>); </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 默认的Chunk大小为16MB，即由2048个页面组成</span></div><div class=\"line\"><span class=\"keyword\">int</span> defaultMaxOrder = SystemPropertyUtil.getInt(<span class=\"string\">\"io.netty.allocator.maxOrder\"</span>, <span class=\"number\">11</span>);</div><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> defaultChunkSize = DEFAULT_PAGE_SIZE &lt;&lt; DEFAULT_MAX_ORDER;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 默认情况下，一个Arena由3个Chunk组成，且所有Arena（就同一类而言）所占用的内存总数，</span></div><div class=\"line\"><span class=\"comment\">// 不能超过可用内存的一半(50%)。</span></div><div class=\"line\"></div><div class=\"line\">DEFAULT_NUM_HEAP_ARENA = Math.max(<span class=\"number\">0</span>,</div><div class=\"line\">        SystemPropertyUtil.getInt(</div><div class=\"line\">                <span class=\"string\">\"io.netty.allocator.numHeapArenas\"</span>,</div><div class=\"line\">                (<span class=\"keyword\">int</span>) Math.min(</div><div class=\"line\">                        runtime.availableProcessors(),</div><div class=\"line\">                        Runtime.getRuntime().maxMemory() / defaultChunkSize / <span class=\"number\">2</span> / <span class=\"number\">3</span>)));</div><div class=\"line\">DEFAULT_NUM_DIRECT_ARENA = Math.max(<span class=\"number\">0</span>,</div><div class=\"line\">        SystemPropertyUtil.getInt(</div><div class=\"line\">                <span class=\"string\">\"io.netty.allocator.numDirectArenas\"</span>,</div><div class=\"line\">                (<span class=\"keyword\">int</span>) Math.min(</div><div class=\"line\">                        runtime.availableProcessors(),</div><div class=\"line\">                        PlatformDependent.maxDirectMemory() / defaultChunkSize / <span class=\"number\">2</span> / <span class=\"number\">3</span>)));</div></pre></td></tr></table></figure>\n<p>根据以上代码，我们发现，Arena是分为两类的，一类是基于堆；另一类则是Direct内存（直接向操作系统请求的）。<br>具体使用哪一类，默认是根据所使用的虚拟机而定，优先使用Direct类型（如果可用的话）。判断的条件是，<br>看能否访问JVM的<code>Unsafe</code>类。具体可以参考<code>PlatformDependent.hasUnsafe()</code>方法。</p>\n<blockquote>\n<p>这里提到的两类不会被同时使用的！</p>\n</blockquote>\n<p>另外，对于内存请求大小的分类，这里也有一些变动。对于所请求内存的大小N</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> N &lt; PAGE_SIZE:</div><div class=\"line\">\t<span class=\"keyword\">if</span> N &lt; <span class=\"number\">512</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> TINY;</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> SMALL;</div><div class=\"line\">elif N &gt; CHUNK_SIZE:</div><div class=\"line\">\t<span class=\"keyword\">return</span> HUGE;</div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> LARGE;</div></pre></td></tr></table></figure>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p>现在，我们来仔细地看看内存分配的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">PooledByteBufAllocator alloc = <span class=\"keyword\">new</span> PooledByteBufAllocator(PlatformDependent.directBufferPreferred());</div><div class=\"line\">ByteBuf buff = alloc.ioBuffer(N);</div></pre></td></tr></table></figure>\n<p>假设在当前的JVM环境中，Direct内存可用的。那当我们尝试去申请N字节的内存时，其实现流程如下：</p>\n<ol>\n<li>获取一个ByteBuf对象，但是该对象未与任何可用内存空间关联。</li>\n<li>检查N的大小，并对N进行修正。。</li>\n<li>分配内存。</li>\n</ol>\n<p>对N的修正：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">normalizeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> reqCapacity)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (reqCapacity &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"capacity: \"</span> + reqCapacity + <span class=\"string\">\" (expected: 0+)\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (reqCapacity &gt;= chunkSize) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> reqCapacity;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> ((reqCapacity &amp; <span class=\"number\">0xFFFFFE00</span>) != <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &gt;= 512</span></div><div class=\"line\">        <span class=\"comment\">// Doubled</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> normalizedCapacity = reqCapacity;</div><div class=\"line\">        normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class=\"number\">1</span>;</div><div class=\"line\">        normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class=\"number\">2</span>;</div><div class=\"line\">        normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class=\"number\">4</span>;</div><div class=\"line\">        normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class=\"number\">8</span>;</div><div class=\"line\">        normalizedCapacity |= normalizedCapacity &gt;&gt;&gt; <span class=\"number\">16</span>;</div><div class=\"line\">        normalizedCapacity ++;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (normalizedCapacity &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            normalizedCapacity &gt;&gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> normalizedCapacity;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Quantum-spaced</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((reqCapacity &amp; <span class=\"number\">15</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> reqCapacity;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> (reqCapacity &amp; ~<span class=\"number\">15</span>) + <span class=\"number\">16</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>说到内存的分配，则需要对页的管理有一定的了解。</p>\n<h3 id=\"内存页的管理模型\"><a href=\"#内存页的管理模型\" class=\"headerlink\" title=\"内存页的管理模型\"></a>内存页的管理模型</h3><p>Netty4使用了二叉树来管理每一个内存页。假设一个Chunk是由连续的N块内存页组成，<br>则Netty4使用一个长度为<code>2N</code>的整型数组来记录和管理每一个内存页的使用情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span>[] memoryMap = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N &lt;&lt; <span class=\"number\">1</span>]</div></pre></td></tr></table></figure>\n<p>假设N=4，则下图，基于<code>memoryMap</code>的二叉树的结构。每个结点的序号为数组的索引值。其中4、5、6、7是这四个叶子节点，<br>分别用来记录4个内存页的使用状态。而2、3是用来表示其管辖的内存页的使用状态。节点1则管理整个Chunk的状态。</p>\n<p><img src=\"http://farm3.staticflickr.com/2805/12403894375_2ee7cf93a4_o.png\" alt=\"基于一维数组的二叉树\"></p>\n<p>内存页的状态有四种：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_UNUSED = <span class=\"number\">0</span>;  <span class=\"comment\">// 初始状态，未使用</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_BRANCH = <span class=\"number\">1</span>;  <span class=\"comment\">// 只对非叶子节点有效，表明该节点下某一部分叶子节点被使用</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 被使用，如果是叶子节点，则表明对应的内存页已经分配出去了</span></div><div class=\"line\"><span class=\"comment\">// 如果是非叶子节点，则表明该节点所管辖的内存页已经全部分配出去了</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_ALLOCATED = <span class=\"number\">2</span>; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 只对叶子节点有效，表示内存页里面的一部分被分配出去了。这种情况属于Tiny类型的内存请求。</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_ALLOCATED_SUBPAGE = ST_ALLOCATED | <span class=\"number\">1</span>;</div></pre></td></tr></table></figure>\n<h3 id=\"内存页的分配\"><a href=\"#内存页的分配\" class=\"headerlink\" title=\"内存页的分配\"></a>内存页的分配</h3><p>内存页的分配有两种情况，有多页分配和页内分配。这里我们先说多页（1个内存页以上）的分配。<br>当请求的内存大小大于一个内存页时，<code>PooledByteBufAllocator</code>会通过遍历<code>memoryMap</code>来，来找出合适内存页。</p>\n<ol>\n<li>首先，它要判断根节点1是否已经被分配，如果是，则表示当前的个Chunk已经没有可用的空间，它需要去其的Chunk找了。</li>\n<li>接着，随机选择当前节点的某一个子节点（2或者3），判断是否有可用空间</li>\n<li>重复步骤2，直到找到可用的内存页</li>\n</ol>\n<blockquote>\n<p>先写到这里，以下剩余内容的目录。另外，对<code>memoryMap</code>中的值，也需要进一步的说明,<br>因为关系具体的内存位置。</p>\n<p>写博客果然比较费事！</p>\n</blockquote>\n<h3 id=\"页内分配\"><a href=\"#页内分配\" class=\"headerlink\" title=\"页内分配\"></a>页内分配</h3><h1 id=\"内存的释放\"><a href=\"#内存的释放\" class=\"headerlink\" title=\"内存的释放\"></a>内存的释放</h1><h2 id=\"内存页的释放\"><a href=\"#内存页的释放\" class=\"headerlink\" title=\"内存页的释放\"></a>内存页的释放</h2><h2 id=\"页内释放\"><a href=\"#页内释放\" class=\"headerlink\" title=\"页内释放\"></a>页内释放</h2><h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><h2 id=\"ByteBuf实例缓存\"><a href=\"#ByteBuf实例缓存\" class=\"headerlink\" title=\"ByteBuf实例缓存\"></a>ByteBuf实例缓存</h2>","site":{"data":{}},"excerpt":"<p><a href=\"http://wangkaisino.blog.163.com/blog/static/1870444202011431112323846\" target=\"_blank\" rel=\"external\">http://wangkaisino.blog.163.com/blog/static/1870444202011431112323846</a></p>\n<p>转载:</p>\n<p>在Netty4中引入了新的内存管理机制极大地提升其性能，本文将对该内在管理机制进行剖析。</p>\n<p>这里<a href=\"http://www.infoq.com/news/2013/11/netty4-twitter\" target=\"_blank\" rel=\"external\">有篇文章</a>讲述了在推特(Twitter)内部<br>使用Netty的状况以及Netty4所带来的性能收益。</p>","more":"<p>在分析Netty4的<code>PooledByteBufAllocator</code>之前，我们最好先认识一下<a href=\"http://www.canonware.com/jemalloc/\" target=\"_blank\" rel=\"external\">jemalloc</a>。<br>Netty在4.0之前的版本已经尝试过通过优化内存管理的方式来提高性能（如果我没有记错的话），但4.0中的改进则特别<br>显著。在这个版本中，其内存管理实现主要是参考了<code>jemalloc</code>。</p>\n<h1 id=\"jemalloc\"><a href=\"#jemalloc\" class=\"headerlink\" title=\"jemalloc\"></a>jemalloc</h1><p><strong>jemalloc</strong> 是由Jason Evans在FreeBSD项目中引入的，其主旨是为了提升在并发环境下内存的分配效率。说白了就是替代<br><code>malloc</code>。malloc之所以没有照顾到并发环境，那是由于在那个时代并发还只在理论，未曾普及。而现在则是多核的天下，连<br>手机都动则2、4核，甚至于8核了。与jemalloc齐名的还有Google的<a href=\"https://code.google.com/p/gperftools/\" target=\"_blank\" rel=\"external\">tcmalloc</a>，其<br>实现与jemalloc多少也有点相似，这里不做介绍。</p>\n<h2 id=\"jemalloc的理念\"><a href=\"#jemalloc的理念\" class=\"headerlink\" title=\"jemalloc的理念\"></a>jemalloc的理念</h2><p>我们以买火车票为例，来简单地说明一下jemalloc与malloc的区别。原来的malloc，相当于只有一个售票窗口的售票大厅，<br>而jemalloc则在同一个售票大厅里面适量地增加的窗口。当然，火车票的总量(即内存大小)是不变的，买票的人相当于线程了。<br>说起来这也是很自然的事情的。</p>\n<blockquote>\n<p>在这里，一个售票窗口就是相当于一个<strong>Arena</strong>。</p>\n</blockquote>\n<p>Arena则按页(Page)来的管理内存，也就是说，一张车票就相当于一页。（后面就不太适合用火车票的例子了）。</p>\n<p>同时，jemalloc还根据所请求的内存大小，对其进行分类。如下图：</p>\n<p><img src=\"http://farm4.staticflickr.com/3749/12402575993_30e006725c_o.png\" alt=\"jemalloc allocation size category\"></p>\n<p>默认情况下，Page的大小为4KB。如图，有三类，small、large和huge。small类的内存请求都属于一个内存页之内<br>（没有半张车票出售:(）。另外，在small类里面，又分了三个子类，分别是Tiny、Quantum-Spaced和Sub-page。<br>这几个概念都在Netty中得到应用。</p>\n<p>每个线程都与某个Arena绑定在一起，线程采用round-robin算法来绑定到某个Arena。</p>\n<blockquote>\n<p>这里有个问题，就是与某个Arena相关的一批线程使用内存资源过快，导致该Arena的内存资源全部消耗殆尽，<br>而其它的Arena又有盈余，这时怎么处理？能否借用。</p>\n<p>目前还没有对jemalloc本身的实现做过多的研究。</p>\n</blockquote>\n<p>通过对jemalloc有个简单的了解后，我们再来看看，Netty4是如何借鉴jemalloc的经验的。需要注意的是，<br>jemalloc的实现，要远比Netty4复杂，一个是系统层的，一个则是应用层的。但两者的思想是相通的。</p>\n<h1 id=\"Netty4中的内存管理\"><a href=\"#Netty4中的内存管理\" class=\"headerlink\" title=\"Netty4中的内存管理\"></a>Netty4中的内存管理</h1><p>以下内容所参考的代码是<code>netty-4.0.15.Final</code>。</p>\n<p>Netty4中，内存池管理的入口点是<code>PooledByteBufAllocator</code>。在该实现中，除了Arena和Page之外，<br>还一个Chunk的概念。一个Arena由多个Chunk组成，而Chunk则由N个Page组成。</p>\n<p>默认配置中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 默认页面大小为8KB</span></div><div class=\"line\"><span class=\"keyword\">int</span> defaultPageSize = SystemPropertyUtil.getInt(<span class=\"string\">\"io.netty.allocator.pageSize\"</span>, <span class=\"number\">8192</span>); </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 默认的Chunk大小为16MB，即由2048个页面组成</span></div><div class=\"line\"><span class=\"keyword\">int</span> defaultMaxOrder = SystemPropertyUtil.getInt(<span class=\"string\">\"io.netty.allocator.maxOrder\"</span>, <span class=\"number\">11</span>);</div><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> defaultChunkSize = DEFAULT_PAGE_SIZE &lt;&lt; DEFAULT_MAX_ORDER;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 默认情况下，一个Arena由3个Chunk组成，且所有Arena（就同一类而言）所占用的内存总数，</span></div><div class=\"line\"><span class=\"comment\">// 不能超过可用内存的一半(50%)。</span></div><div class=\"line\"></div><div class=\"line\">DEFAULT_NUM_HEAP_ARENA = Math.max(<span class=\"number\">0</span>,</div><div class=\"line\">        SystemPropertyUtil.getInt(</div><div class=\"line\">                <span class=\"string\">\"io.netty.allocator.numHeapArenas\"</span>,</div><div class=\"line\">                (<span class=\"keyword\">int</span>) Math.min(</div><div class=\"line\">                        runtime.availableProcessors(),</div><div class=\"line\">                        Runtime.getRuntime().maxMemory() / defaultChunkSize / <span class=\"number\">2</span> / <span class=\"number\">3</span>)));</div><div class=\"line\">DEFAULT_NUM_DIRECT_ARENA = Math.max(<span class=\"number\">0</span>,</div><div class=\"line\">        SystemPropertyUtil.getInt(</div><div class=\"line\">                <span class=\"string\">\"io.netty.allocator.numDirectArenas\"</span>,</div><div class=\"line\">                (<span class=\"keyword\">int</span>) Math.min(</div><div class=\"line\">                        runtime.availableProcessors(),</div><div class=\"line\">                        PlatformDependent.maxDirectMemory() / defaultChunkSize / <span class=\"number\">2</span> / <span class=\"number\">3</span>)));</div></pre></td></tr></table></figure>\n<p>根据以上代码，我们发现，Arena是分为两类的，一类是基于堆；另一类则是Direct内存（直接向操作系统请求的）。<br>具体使用哪一类，默认是根据所使用的虚拟机而定，优先使用Direct类型（如果可用的话）。判断的条件是，<br>看能否访问JVM的<code>Unsafe</code>类。具体可以参考<code>PlatformDependent.hasUnsafe()</code>方法。</p>\n<blockquote>\n<p>这里提到的两类不会被同时使用的！</p>\n</blockquote>\n<p>另外，对于内存请求大小的分类，这里也有一些变动。对于所请求内存的大小N</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> N &lt; PAGE_SIZE:</div><div class=\"line\">\t<span class=\"keyword\">if</span> N &lt; <span class=\"number\">512</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> TINY;</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> SMALL;</div><div class=\"line\">elif N &gt; CHUNK_SIZE:</div><div class=\"line\">\t<span class=\"keyword\">return</span> HUGE;</div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> LARGE;</div></pre></td></tr></table></figure>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p>现在，我们来仔细地看看内存分配的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">PooledByteBufAllocator alloc = <span class=\"keyword\">new</span> PooledByteBufAllocator(PlatformDependent.directBufferPreferred());</div><div class=\"line\">ByteBuf buff = alloc.ioBuffer(N);</div></pre></td></tr></table></figure>\n<p>假设在当前的JVM环境中，Direct内存可用的。那当我们尝试去申请N字节的内存时，其实现流程如下：</p>\n<ol>\n<li>获取一个ByteBuf对象，但是该对象未与任何可用内存空间关联。</li>\n<li>检查N的大小，并对N进行修正。。</li>\n<li>分配内存。</li>\n</ol>\n<p>对N的修正：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">normalizeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> reqCapacity)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (reqCapacity &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"capacity: \"</span> + reqCapacity + <span class=\"string\">\" (expected: 0+)\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (reqCapacity &gt;= chunkSize) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> reqCapacity;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> ((reqCapacity &amp; <span class=\"number\">0xFFFFFE00</span>) != <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &gt;= 512</span></div><div class=\"line\">        <span class=\"comment\">// Doubled</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> normalizedCapacity = reqCapacity;</div><div class=\"line\">        normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class=\"number\">1</span>;</div><div class=\"line\">        normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class=\"number\">2</span>;</div><div class=\"line\">        normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class=\"number\">4</span>;</div><div class=\"line\">        normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class=\"number\">8</span>;</div><div class=\"line\">        normalizedCapacity |= normalizedCapacity &gt;&gt;&gt; <span class=\"number\">16</span>;</div><div class=\"line\">        normalizedCapacity ++;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (normalizedCapacity &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            normalizedCapacity &gt;&gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> normalizedCapacity;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Quantum-spaced</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((reqCapacity &amp; <span class=\"number\">15</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> reqCapacity;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> (reqCapacity &amp; ~<span class=\"number\">15</span>) + <span class=\"number\">16</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>说到内存的分配，则需要对页的管理有一定的了解。</p>\n<h3 id=\"内存页的管理模型\"><a href=\"#内存页的管理模型\" class=\"headerlink\" title=\"内存页的管理模型\"></a>内存页的管理模型</h3><p>Netty4使用了二叉树来管理每一个内存页。假设一个Chunk是由连续的N块内存页组成，<br>则Netty4使用一个长度为<code>2N</code>的整型数组来记录和管理每一个内存页的使用情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span>[] memoryMap = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N &lt;&lt; <span class=\"number\">1</span>]</div></pre></td></tr></table></figure>\n<p>假设N=4，则下图，基于<code>memoryMap</code>的二叉树的结构。每个结点的序号为数组的索引值。其中4、5、6、7是这四个叶子节点，<br>分别用来记录4个内存页的使用状态。而2、3是用来表示其管辖的内存页的使用状态。节点1则管理整个Chunk的状态。</p>\n<p><img src=\"http://farm3.staticflickr.com/2805/12403894375_2ee7cf93a4_o.png\" alt=\"基于一维数组的二叉树\"></p>\n<p>内存页的状态有四种：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_UNUSED = <span class=\"number\">0</span>;  <span class=\"comment\">// 初始状态，未使用</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_BRANCH = <span class=\"number\">1</span>;  <span class=\"comment\">// 只对非叶子节点有效，表明该节点下某一部分叶子节点被使用</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 被使用，如果是叶子节点，则表明对应的内存页已经分配出去了</span></div><div class=\"line\"><span class=\"comment\">// 如果是非叶子节点，则表明该节点所管辖的内存页已经全部分配出去了</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_ALLOCATED = <span class=\"number\">2</span>; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 只对叶子节点有效，表示内存页里面的一部分被分配出去了。这种情况属于Tiny类型的内存请求。</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_ALLOCATED_SUBPAGE = ST_ALLOCATED | <span class=\"number\">1</span>;</div></pre></td></tr></table></figure>\n<h3 id=\"内存页的分配\"><a href=\"#内存页的分配\" class=\"headerlink\" title=\"内存页的分配\"></a>内存页的分配</h3><p>内存页的分配有两种情况，有多页分配和页内分配。这里我们先说多页（1个内存页以上）的分配。<br>当请求的内存大小大于一个内存页时，<code>PooledByteBufAllocator</code>会通过遍历<code>memoryMap</code>来，来找出合适内存页。</p>\n<ol>\n<li>首先，它要判断根节点1是否已经被分配，如果是，则表示当前的个Chunk已经没有可用的空间，它需要去其的Chunk找了。</li>\n<li>接着，随机选择当前节点的某一个子节点（2或者3），判断是否有可用空间</li>\n<li>重复步骤2，直到找到可用的内存页</li>\n</ol>\n<blockquote>\n<p>先写到这里，以下剩余内容的目录。另外，对<code>memoryMap</code>中的值，也需要进一步的说明,<br>因为关系具体的内存位置。</p>\n<p>写博客果然比较费事！</p>\n</blockquote>\n<h3 id=\"页内分配\"><a href=\"#页内分配\" class=\"headerlink\" title=\"页内分配\"></a>页内分配</h3><h1 id=\"内存的释放\"><a href=\"#内存的释放\" class=\"headerlink\" title=\"内存的释放\"></a>内存的释放</h1><h2 id=\"内存页的释放\"><a href=\"#内存页的释放\" class=\"headerlink\" title=\"内存页的释放\"></a>内存页的释放</h2><h2 id=\"页内释放\"><a href=\"#页内释放\" class=\"headerlink\" title=\"页内释放\"></a>页内释放</h2><h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><h2 id=\"ByteBuf实例缓存\"><a href=\"#ByteBuf实例缓存\" class=\"headerlink\" title=\"ByteBuf实例缓存\"></a>ByteBuf实例缓存</h2>"},{"title":"Redis-SourceCode-Analysis","date":"2017-12-15T10:20:10.000Z","_content":"\n\nhttp://ningg.top/redis-lesson-2-source-code-review-in-xcode/\n\n\n\nhttps://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&mid=211169817&idx=1&sn=d5d0f6b10961bae54e58c7593105e8dd&3rd=MzA3MDU4NTYzMw==&scene=6#rd","source":"_posts/Redis-SourceCode-Analysis.md","raw":"---\ntitle: Redis-SourceCode-Analysis\ndate: 2017-12-15 18:20:10\ntags:\n---\n\n\nhttp://ningg.top/redis-lesson-2-source-code-review-in-xcode/\n\n\n\nhttps://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&mid=211169817&idx=1&sn=d5d0f6b10961bae54e58c7593105e8dd&3rd=MzA3MDU4NTYzMw==&scene=6#rd","slug":"Redis-SourceCode-Analysis","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszd002i3iq2pi7rwg9a","content":"<p><a href=\"http://ningg.top/redis-lesson-2-source-code-review-in-xcode/\" target=\"_blank\" rel=\"external\">http://ningg.top/redis-lesson-2-source-code-review-in-xcode/</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;mid=211169817&amp;idx=1&amp;sn=d5d0f6b10961bae54e58c7593105e8dd&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd\" target=\"_blank\" rel=\"external\">https://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;mid=211169817&amp;idx=1&amp;sn=d5d0f6b10961bae54e58c7593105e8dd&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://ningg.top/redis-lesson-2-source-code-review-in-xcode/\" target=\"_blank\" rel=\"external\">http://ningg.top/redis-lesson-2-source-code-review-in-xcode/</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;mid=211169817&amp;idx=1&amp;sn=d5d0f6b10961bae54e58c7593105e8dd&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd\" target=\"_blank\" rel=\"external\">https://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;mid=211169817&amp;idx=1&amp;sn=d5d0f6b10961bae54e58c7593105e8dd&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd</a></p>\n"},{"title":"RocketMQ——Consumer Rebalance 原理分析","date":"2017-09-25T08:58:43.000Z","_content":"","source":"_posts/RocketMQ-Consumer-rebalance.md","raw":"---\ntitle: RocketMQ——Consumer Rebalance 原理分析\ndate: 2017-09-25 16:58:43\ntags: RocketMQ\n---\n","slug":"RocketMQ-Consumer-rebalance","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcsze002k3iq2vee6r50k","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"RocketMQ在Intellij中的终极调试技巧（一）","date":"2017-08-20T05:28:52.000Z","_content":"\n### 调试难点\n\n如果虚拟机够多\n可以规划将MQ的各个部分部署在不同机器上，并且在所有子系统启动时加上远程调试。然后Intellij创建几个Remote debug窗口。\n\n如果没有虚拟机，只有一台Mac，接下去的内容将对RocketMQ的调试有非常大的帮助。\n\n### 调试界面\n\n![image.png](http://upload-images.jianshu.io/upload_images/716353-1c36c4f4f54283e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### Name Server\n\n### Broker\nBroker的调试最为麻烦，\n如果在学习RocketMQ的初期，建议单启动一个Broker，减少复杂度，关注主要流程代码。\n如果要深入学习和调试，要启动Master和Slave，开启主从同步功能，也是会发生端口和文件目录冲突的地方。\n\nstore的目录都为`System.getProperty(\"user.home\") + File.separator + \"store\"`，\n所以我们需要对Master和Slave进行分离，方法很多种，这里介绍一种，在启动参数中配置不同的`user.home`。\n\nPort的分离可以放在不同的配置文件中：broker-a.properties，broker-a-s.properties\n\n#### Master Broker\n\n```\nVM options:-Drocketmq.home.dir=/Users/eric/Code/middleware/incubator-rocketmq -Drocketmq.namesrv.addr=mac:9876 -Duser.home=/Users/eric/store/master\nProgram arguments:-c /Users/eric/Code/middleware/incubator-rocketmq/conf/2m-2s-sync/broker-a.properties\n\nbroker-a.properties:\nbrokerClusterName=DefaultCluster\nbrokerName=broker-a\nbrokerId=0\ndeleteWhen=04\nfileReservedTime=48\nbrokerRole=SYNC_MASTER\nflushDiskType=ASYNC_FLUSH\nlistenPort=11111\n```\n\n![image.png](http://upload-images.jianshu.io/upload_images/716353-269519f3558de100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### Slave Broker\n```\nVM options:-Drocketmq.home.dir=/Users/eric/Code/middleware/incubator-rocketmq -Drocketmq.namesrv.addr=mac:9876 -Duser.home=/Users/eric/store/slave\nProgram arguments:-c /Users/eric/Code/middleware/incubator-rocketmq/conf/2m-2s-sync/broker-a-s.properties\n\nbroker-a-s.properties:\nbrokerClusterName=DefaultCluster\nbrokerName=broker-a\nbrokerId=1\ndeleteWhen=04\nfileReservedTime=48\nbrokerRole=SLAVE\nflushDiskType=ASYNC_FLUSH\nlistenPort=22222\n```\n\n![image.png](http://upload-images.jianshu.io/upload_images/716353-473218e8e6936674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n配置完后依次启动 Name Server, Master Broker, Slave Broker， Producer\n\n完整的Store目录结构截图\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1fkedpuigp8j317e1a80zy.jpg)\n\n技巧\n\n1. 充分利用作者写好的单元测试，对原理的掌握会有帮助\n2. RocketMQ有太多的事情是用 （短时间）定时+唤醒 的方式异步执行的，想要更好得了解原理，最好把定时的时间改得大一点，这样多线程的调试会好做很多。","source":"_posts/RocketMQ-Debug-with-intellij.md","raw":"---\ntitle: RocketMQ在Intellij中的终极调试技巧（一）\ndate: 2017-08-20 13:28:52\ntags: RocketMQ\n---\n\n### 调试难点\n\n如果虚拟机够多\n可以规划将MQ的各个部分部署在不同机器上，并且在所有子系统启动时加上远程调试。然后Intellij创建几个Remote debug窗口。\n\n如果没有虚拟机，只有一台Mac，接下去的内容将对RocketMQ的调试有非常大的帮助。\n\n### 调试界面\n\n![image.png](http://upload-images.jianshu.io/upload_images/716353-1c36c4f4f54283e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### Name Server\n\n### Broker\nBroker的调试最为麻烦，\n如果在学习RocketMQ的初期，建议单启动一个Broker，减少复杂度，关注主要流程代码。\n如果要深入学习和调试，要启动Master和Slave，开启主从同步功能，也是会发生端口和文件目录冲突的地方。\n\nstore的目录都为`System.getProperty(\"user.home\") + File.separator + \"store\"`，\n所以我们需要对Master和Slave进行分离，方法很多种，这里介绍一种，在启动参数中配置不同的`user.home`。\n\nPort的分离可以放在不同的配置文件中：broker-a.properties，broker-a-s.properties\n\n#### Master Broker\n\n```\nVM options:-Drocketmq.home.dir=/Users/eric/Code/middleware/incubator-rocketmq -Drocketmq.namesrv.addr=mac:9876 -Duser.home=/Users/eric/store/master\nProgram arguments:-c /Users/eric/Code/middleware/incubator-rocketmq/conf/2m-2s-sync/broker-a.properties\n\nbroker-a.properties:\nbrokerClusterName=DefaultCluster\nbrokerName=broker-a\nbrokerId=0\ndeleteWhen=04\nfileReservedTime=48\nbrokerRole=SYNC_MASTER\nflushDiskType=ASYNC_FLUSH\nlistenPort=11111\n```\n\n![image.png](http://upload-images.jianshu.io/upload_images/716353-269519f3558de100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### Slave Broker\n```\nVM options:-Drocketmq.home.dir=/Users/eric/Code/middleware/incubator-rocketmq -Drocketmq.namesrv.addr=mac:9876 -Duser.home=/Users/eric/store/slave\nProgram arguments:-c /Users/eric/Code/middleware/incubator-rocketmq/conf/2m-2s-sync/broker-a-s.properties\n\nbroker-a-s.properties:\nbrokerClusterName=DefaultCluster\nbrokerName=broker-a\nbrokerId=1\ndeleteWhen=04\nfileReservedTime=48\nbrokerRole=SLAVE\nflushDiskType=ASYNC_FLUSH\nlistenPort=22222\n```\n\n![image.png](http://upload-images.jianshu.io/upload_images/716353-473218e8e6936674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n配置完后依次启动 Name Server, Master Broker, Slave Broker， Producer\n\n完整的Store目录结构截图\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1fkedpuigp8j317e1a80zy.jpg)\n\n技巧\n\n1. 充分利用作者写好的单元测试，对原理的掌握会有帮助\n2. RocketMQ有太多的事情是用 （短时间）定时+唤醒 的方式异步执行的，想要更好得了解原理，最好把定时的时间改得大一点，这样多线程的调试会好做很多。","slug":"RocketMQ-Debug-with-intellij","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszf002m3iq2kg8i6lo9","content":"<h3 id=\"调试难点\"><a href=\"#调试难点\" class=\"headerlink\" title=\"调试难点\"></a>调试难点</h3><p>如果虚拟机够多<br>可以规划将MQ的各个部分部署在不同机器上，并且在所有子系统启动时加上远程调试。然后Intellij创建几个Remote debug窗口。</p>\n<p>如果没有虚拟机，只有一台Mac，接下去的内容将对RocketMQ的调试有非常大的帮助。</p>\n<h3 id=\"调试界面\"><a href=\"#调试界面\" class=\"headerlink\" title=\"调试界面\"></a>调试界面</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/716353-1c36c4f4f54283e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h3 id=\"Name-Server\"><a href=\"#Name-Server\" class=\"headerlink\" title=\"Name Server\"></a>Name Server</h3><h3 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h3><p>Broker的调试最为麻烦，<br>如果在学习RocketMQ的初期，建议单启动一个Broker，减少复杂度，关注主要流程代码。<br>如果要深入学习和调试，要启动Master和Slave，开启主从同步功能，也是会发生端口和文件目录冲突的地方。</p>\n<p>store的目录都为<code>System.getProperty(&quot;user.home&quot;) + File.separator + &quot;store&quot;</code>，<br>所以我们需要对Master和Slave进行分离，方法很多种，这里介绍一种，在启动参数中配置不同的<code>user.home</code>。</p>\n<p>Port的分离可以放在不同的配置文件中：broker-a.properties，broker-a-s.properties</p>\n<h4 id=\"Master-Broker\"><a href=\"#Master-Broker\" class=\"headerlink\" title=\"Master Broker\"></a>Master Broker</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">VM options:-Drocketmq.home.dir=/Users/eric/Code/middleware/incubator-rocketmq -Drocketmq.namesrv.addr=mac:9876 -Duser.home=/Users/eric/store/master</div><div class=\"line\">Program arguments:-c /Users/eric/Code/middleware/incubator-rocketmq/conf/2m-2s-sync/broker-a.properties</div><div class=\"line\"></div><div class=\"line\">broker-a.properties:</div><div class=\"line\">brokerClusterName=DefaultCluster</div><div class=\"line\">brokerName=broker-a</div><div class=\"line\">brokerId=0</div><div class=\"line\">deleteWhen=04</div><div class=\"line\">fileReservedTime=48</div><div class=\"line\">brokerRole=SYNC_MASTER</div><div class=\"line\">flushDiskType=ASYNC_FLUSH</div><div class=\"line\">listenPort=11111</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/716353-269519f3558de100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"Slave-Broker\"><a href=\"#Slave-Broker\" class=\"headerlink\" title=\"Slave Broker\"></a>Slave Broker</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">VM options:-Drocketmq.home.dir=/Users/eric/Code/middleware/incubator-rocketmq -Drocketmq.namesrv.addr=mac:9876 -Duser.home=/Users/eric/store/slave</div><div class=\"line\">Program arguments:-c /Users/eric/Code/middleware/incubator-rocketmq/conf/2m-2s-sync/broker-a-s.properties</div><div class=\"line\"></div><div class=\"line\">broker-a-s.properties:</div><div class=\"line\">brokerClusterName=DefaultCluster</div><div class=\"line\">brokerName=broker-a</div><div class=\"line\">brokerId=1</div><div class=\"line\">deleteWhen=04</div><div class=\"line\">fileReservedTime=48</div><div class=\"line\">brokerRole=SLAVE</div><div class=\"line\">flushDiskType=ASYNC_FLUSH</div><div class=\"line\">listenPort=22222</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/716353-473218e8e6936674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>配置完后依次启动 Name Server, Master Broker, Slave Broker， Producer</p>\n<p>完整的Store目录结构截图</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fkedpuigp8j317e1a80zy.jpg\" alt=\"\"></p>\n<p>技巧</p>\n<ol>\n<li>充分利用作者写好的单元测试，对原理的掌握会有帮助</li>\n<li>RocketMQ有太多的事情是用 （短时间）定时+唤醒 的方式异步执行的，想要更好得了解原理，最好把定时的时间改得大一点，这样多线程的调试会好做很多。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"调试难点\"><a href=\"#调试难点\" class=\"headerlink\" title=\"调试难点\"></a>调试难点</h3><p>如果虚拟机够多<br>可以规划将MQ的各个部分部署在不同机器上，并且在所有子系统启动时加上远程调试。然后Intellij创建几个Remote debug窗口。</p>\n<p>如果没有虚拟机，只有一台Mac，接下去的内容将对RocketMQ的调试有非常大的帮助。</p>\n<h3 id=\"调试界面\"><a href=\"#调试界面\" class=\"headerlink\" title=\"调试界面\"></a>调试界面</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/716353-1c36c4f4f54283e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h3 id=\"Name-Server\"><a href=\"#Name-Server\" class=\"headerlink\" title=\"Name Server\"></a>Name Server</h3><h3 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h3><p>Broker的调试最为麻烦，<br>如果在学习RocketMQ的初期，建议单启动一个Broker，减少复杂度，关注主要流程代码。<br>如果要深入学习和调试，要启动Master和Slave，开启主从同步功能，也是会发生端口和文件目录冲突的地方。</p>\n<p>store的目录都为<code>System.getProperty(&quot;user.home&quot;) + File.separator + &quot;store&quot;</code>，<br>所以我们需要对Master和Slave进行分离，方法很多种，这里介绍一种，在启动参数中配置不同的<code>user.home</code>。</p>\n<p>Port的分离可以放在不同的配置文件中：broker-a.properties，broker-a-s.properties</p>\n<h4 id=\"Master-Broker\"><a href=\"#Master-Broker\" class=\"headerlink\" title=\"Master Broker\"></a>Master Broker</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">VM options:-Drocketmq.home.dir=/Users/eric/Code/middleware/incubator-rocketmq -Drocketmq.namesrv.addr=mac:9876 -Duser.home=/Users/eric/store/master</div><div class=\"line\">Program arguments:-c /Users/eric/Code/middleware/incubator-rocketmq/conf/2m-2s-sync/broker-a.properties</div><div class=\"line\"></div><div class=\"line\">broker-a.properties:</div><div class=\"line\">brokerClusterName=DefaultCluster</div><div class=\"line\">brokerName=broker-a</div><div class=\"line\">brokerId=0</div><div class=\"line\">deleteWhen=04</div><div class=\"line\">fileReservedTime=48</div><div class=\"line\">brokerRole=SYNC_MASTER</div><div class=\"line\">flushDiskType=ASYNC_FLUSH</div><div class=\"line\">listenPort=11111</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/716353-269519f3558de100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"Slave-Broker\"><a href=\"#Slave-Broker\" class=\"headerlink\" title=\"Slave Broker\"></a>Slave Broker</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">VM options:-Drocketmq.home.dir=/Users/eric/Code/middleware/incubator-rocketmq -Drocketmq.namesrv.addr=mac:9876 -Duser.home=/Users/eric/store/slave</div><div class=\"line\">Program arguments:-c /Users/eric/Code/middleware/incubator-rocketmq/conf/2m-2s-sync/broker-a-s.properties</div><div class=\"line\"></div><div class=\"line\">broker-a-s.properties:</div><div class=\"line\">brokerClusterName=DefaultCluster</div><div class=\"line\">brokerName=broker-a</div><div class=\"line\">brokerId=1</div><div class=\"line\">deleteWhen=04</div><div class=\"line\">fileReservedTime=48</div><div class=\"line\">brokerRole=SLAVE</div><div class=\"line\">flushDiskType=ASYNC_FLUSH</div><div class=\"line\">listenPort=22222</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/716353-473218e8e6936674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>配置完后依次启动 Name Server, Master Broker, Slave Broker， Producer</p>\n<p>完整的Store目录结构截图</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fkedpuigp8j317e1a80zy.jpg\" alt=\"\"></p>\n<p>技巧</p>\n<ol>\n<li>充分利用作者写好的单元测试，对原理的掌握会有帮助</li>\n<li>RocketMQ有太多的事情是用 （短时间）定时+唤醒 的方式异步执行的，想要更好得了解原理，最好把定时的时间改得大一点，这样多线程的调试会好做很多。</li>\n</ol>\n"},{"title":"RocketMQ——延时消息投递原理分析","date":"2017-10-13T02:38:19.000Z","_content":"\n### 被动延时消费\n\n``` java\nconsumer.registerMessageListener(new MessageListenerConcurrently() {\n    @Override\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n        ConsumeConcurrentlyContext context) {\n        // 可能抛出异常\n        boolean success = doConsume(msgs);\n        \n        if (success) {\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        } else {\n            return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n        }\n    }\n});\n```\n\n### 主动延时消费\n\n``` java\n\n```\n\n### 分布式事务之 Best Effort Delivery","source":"_posts/RocketMQ-Delay-message-delivery.md","raw":"---\ntitle: RocketMQ——延时消息投递原理分析\ndate: 2017-10-13 10:38:19\ntags: RocketMQ\n---\n\n### 被动延时消费\n\n``` java\nconsumer.registerMessageListener(new MessageListenerConcurrently() {\n    @Override\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n        ConsumeConcurrentlyContext context) {\n        // 可能抛出异常\n        boolean success = doConsume(msgs);\n        \n        if (success) {\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        } else {\n            return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n        }\n    }\n});\n```\n\n### 主动延时消费\n\n``` java\n\n```\n\n### 分布式事务之 Best Effort Delivery","slug":"RocketMQ-Delay-message-delivery","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszg002o3iq2fon5c2qo","content":"<h3 id=\"被动延时消费\"><a href=\"#被动延时消费\" class=\"headerlink\" title=\"被动延时消费\"></a>被动延时消费</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">        ConsumeConcurrentlyContext context)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 可能抛出异常</span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> success = doConsume(msgs);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> (success) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"主动延时消费\"><a href=\"#主动延时消费\" class=\"headerlink\" title=\"主动延时消费\"></a>主动延时消费</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n<h3 id=\"分布式事务之-Best-Effort-Delivery\"><a href=\"#分布式事务之-Best-Effort-Delivery\" class=\"headerlink\" title=\"分布式事务之 Best Effort Delivery\"></a>分布式事务之 Best Effort Delivery</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"被动延时消费\"><a href=\"#被动延时消费\" class=\"headerlink\" title=\"被动延时消费\"></a>被动延时消费</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">        ConsumeConcurrentlyContext context)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 可能抛出异常</span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> success = doConsume(msgs);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> (success) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"主动延时消费\"><a href=\"#主动延时消费\" class=\"headerlink\" title=\"主动延时消费\"></a>主动延时消费</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n<h3 id=\"分布式事务之-Best-Effort-Delivery\"><a href=\"#分布式事务之-Best-Effort-Delivery\" class=\"headerlink\" title=\"分布式事务之 Best Effort Delivery\"></a>分布式事务之 Best Effort Delivery</h3>"},{"title":"RocketMQ——IndexService 原理分析","date":"2017-10-12T11:29:40.000Z","_content":"\n\n#### RocmetMQ的IndexService设计原理\n\n![你想输入的替代文字](RocketMQ-Index-service/index-file.gif)\n\n在RocketMQ中，IndexService底层是通过文件来存储的，所以，即使MQ的进程在中途重启过，索引的功能是不受影响的。\n索引文件的路径是 `System.getProperty(\"user.home\") + File.separator + \"store\"`，文件名是文件创建的时间，可以有多个，但，\n在一个文件没有满的情况下，所有的topic的所有的列队的消息，全部都是顺序得存放在一个文件中的，这很重要，下面会详解。\n![image.png](http://upload-images.jianshu.io/upload_images/716353-2ed415df19a3040b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在MQ源码中，用IndexFile这个类代表索引文件，对于每一个index file，大小都是固定的，即，都是设计好的。\nindex file在逻辑上被拆分成了3个部分，IndexHead + HashSlotPart + MsgIndexPart，\nIndexHead\n索引的开头，和索引的结构没有关系\nHashSlotPart\nhash的槽位，是索引的目录，用于定位消息索引在该文件的「MsgIndexPart」的位置，\n可能有点绕，往下就会觉得很简单，每个槽位是等长的，占4 Byte，一个文件总的槽位数量也是定的，不可改变，槽位数越大，索引的消息越多。\nMsgIndexPart\n真实的消息索引，即，每个msgIndex段代表改消息在CommitLog上的PhyicOffset。每个msgIndex段也是等长的，占20 Byte（int + long + int + int）。\n等长的MsgIndexPart可以理解成功一个有capacity的数组，为了使数组的空间不浪费，那消息就要从前往后一个一个append进去。\n\n\n所以，在默认配置下，\n每个索引文件的大小为 \n`int fileTotalSize = IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);`\n\nCommitLogDispatcherBuildIndex调用dispatch\n``` java\npublic void dispatch(DispatchRequest request) {\n    if (DefaultMessageStore.this.messageStoreConfig.isMessageIndexEnable()) {\n        DefaultMessageStore.this.indexService.buildIndex(request);\n    }\n}\n```\nbuildIndex时会构建好几个索引，topic#msgId=>msgIndex, topic#key1=>msgIndex, topic#key2=>msgIndex\n``` java\npublic void buildIndex(DispatchRequest req) {\n    IndexFile indexFile = retryGetAndCreateIndexFile();\n    if (indexFile != null) {\n        long endPhyOffset = indexFile.getEndPhyOffset();\n        DispatchRequest msg = req;\n        String topic = msg.getTopic();\n        String keys = msg.getKeys();\n\n        ...\n        if (req.getUniqKey() != null) {\n            // 构建UniqKey，也就是msgId的索引\n            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));\n            ...\n        }\n\n        if (keys != null && keys.length() > 0) {\n            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);\n            for (int i = 0; i < keyset.length; i++) {\n                String key = keyset[i];\n                if (key.length() > 0) {\n                    // 构建业务Key的索引\n                    indexFile = putKey(indexFile, msg, buildKey(topic, key));\n                    ...\n                }\n            }\n        }\n    } else {\n        log.error(\"build index error, stop building index\");\n    }\n}\n```","source":"_posts/RocketMQ-Index-service.md","raw":"---\ntitle: RocketMQ——IndexService 原理分析\ndate: 2017-10-12 19:29:40\ntags: RocketMQ\n---\n\n\n#### RocmetMQ的IndexService设计原理\n\n![你想输入的替代文字](RocketMQ-Index-service/index-file.gif)\n\n在RocketMQ中，IndexService底层是通过文件来存储的，所以，即使MQ的进程在中途重启过，索引的功能是不受影响的。\n索引文件的路径是 `System.getProperty(\"user.home\") + File.separator + \"store\"`，文件名是文件创建的时间，可以有多个，但，\n在一个文件没有满的情况下，所有的topic的所有的列队的消息，全部都是顺序得存放在一个文件中的，这很重要，下面会详解。\n![image.png](http://upload-images.jianshu.io/upload_images/716353-2ed415df19a3040b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在MQ源码中，用IndexFile这个类代表索引文件，对于每一个index file，大小都是固定的，即，都是设计好的。\nindex file在逻辑上被拆分成了3个部分，IndexHead + HashSlotPart + MsgIndexPart，\nIndexHead\n索引的开头，和索引的结构没有关系\nHashSlotPart\nhash的槽位，是索引的目录，用于定位消息索引在该文件的「MsgIndexPart」的位置，\n可能有点绕，往下就会觉得很简单，每个槽位是等长的，占4 Byte，一个文件总的槽位数量也是定的，不可改变，槽位数越大，索引的消息越多。\nMsgIndexPart\n真实的消息索引，即，每个msgIndex段代表改消息在CommitLog上的PhyicOffset。每个msgIndex段也是等长的，占20 Byte（int + long + int + int）。\n等长的MsgIndexPart可以理解成功一个有capacity的数组，为了使数组的空间不浪费，那消息就要从前往后一个一个append进去。\n\n\n所以，在默认配置下，\n每个索引文件的大小为 \n`int fileTotalSize = IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);`\n\nCommitLogDispatcherBuildIndex调用dispatch\n``` java\npublic void dispatch(DispatchRequest request) {\n    if (DefaultMessageStore.this.messageStoreConfig.isMessageIndexEnable()) {\n        DefaultMessageStore.this.indexService.buildIndex(request);\n    }\n}\n```\nbuildIndex时会构建好几个索引，topic#msgId=>msgIndex, topic#key1=>msgIndex, topic#key2=>msgIndex\n``` java\npublic void buildIndex(DispatchRequest req) {\n    IndexFile indexFile = retryGetAndCreateIndexFile();\n    if (indexFile != null) {\n        long endPhyOffset = indexFile.getEndPhyOffset();\n        DispatchRequest msg = req;\n        String topic = msg.getTopic();\n        String keys = msg.getKeys();\n\n        ...\n        if (req.getUniqKey() != null) {\n            // 构建UniqKey，也就是msgId的索引\n            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));\n            ...\n        }\n\n        if (keys != null && keys.length() > 0) {\n            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);\n            for (int i = 0; i < keyset.length; i++) {\n                String key = keyset[i];\n                if (key.length() > 0) {\n                    // 构建业务Key的索引\n                    indexFile = putKey(indexFile, msg, buildKey(topic, key));\n                    ...\n                }\n            }\n        }\n    } else {\n        log.error(\"build index error, stop building index\");\n    }\n}\n```","slug":"RocketMQ-Index-service","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszh002q3iq23tzaootq","content":"<h4 id=\"RocmetMQ的IndexService设计原理\"><a href=\"#RocmetMQ的IndexService设计原理\" class=\"headerlink\" title=\"RocmetMQ的IndexService设计原理\"></a>RocmetMQ的IndexService设计原理</h4><p><img src=\"/2017/10/12/RocketMQ-Index-service/index-file.gif\" alt=\"你想输入的替代文字\"></p>\n<p>在RocketMQ中，IndexService底层是通过文件来存储的，所以，即使MQ的进程在中途重启过，索引的功能是不受影响的。<br>索引文件的路径是 <code>System.getProperty(&quot;user.home&quot;) + File.separator + &quot;store&quot;</code>，文件名是文件创建的时间，可以有多个，但，<br>在一个文件没有满的情况下，所有的topic的所有的列队的消息，全部都是顺序得存放在一个文件中的，这很重要，下面会详解。<br><img src=\"http://upload-images.jianshu.io/upload_images/716353-2ed415df19a3040b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>在MQ源码中，用IndexFile这个类代表索引文件，对于每一个index file，大小都是固定的，即，都是设计好的。<br>index file在逻辑上被拆分成了3个部分，IndexHead + HashSlotPart + MsgIndexPart，<br>IndexHead<br>索引的开头，和索引的结构没有关系<br>HashSlotPart<br>hash的槽位，是索引的目录，用于定位消息索引在该文件的「MsgIndexPart」的位置，<br>可能有点绕，往下就会觉得很简单，每个槽位是等长的，占4 Byte，一个文件总的槽位数量也是定的，不可改变，槽位数越大，索引的消息越多。<br>MsgIndexPart<br>真实的消息索引，即，每个msgIndex段代表改消息在CommitLog上的PhyicOffset。每个msgIndex段也是等长的，占20 Byte（int + long + int + int）。<br>等长的MsgIndexPart可以理解成功一个有capacity的数组，为了使数组的空间不浪费，那消息就要从前往后一个一个append进去。</p>\n<p>所以，在默认配置下，<br>每个索引文件的大小为<br><code>int fileTotalSize = IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);</code></p>\n<p>CommitLogDispatcherBuildIndex调用dispatch<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(DispatchRequest request)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (DefaultMessageStore.<span class=\"keyword\">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</div><div class=\"line\">        DefaultMessageStore.<span class=\"keyword\">this</span>.indexService.buildIndex(request);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>buildIndex时会构建好几个索引，topic#msgId=&gt;msgIndex, topic#key1=&gt;msgIndex, topic#key2=&gt;msgIndex<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildIndex</span><span class=\"params\">(DispatchRequest req)</span> </span>&#123;</div><div class=\"line\">    IndexFile indexFile = retryGetAndCreateIndexFile();</div><div class=\"line\">    <span class=\"keyword\">if</span> (indexFile != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> endPhyOffset = indexFile.getEndPhyOffset();</div><div class=\"line\">        DispatchRequest msg = req;</div><div class=\"line\">        String topic = msg.getTopic();</div><div class=\"line\">        String keys = msg.getKeys();</div><div class=\"line\"></div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">if</span> (req.getUniqKey() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 构建UniqKey，也就是msgId的索引</span></div><div class=\"line\">            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (keys != <span class=\"keyword\">null</span> &amp;&amp; keys.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; keyset.length; i++) &#123;</div><div class=\"line\">                String key = keyset[i];</div><div class=\"line\">                <span class=\"keyword\">if</span> (key.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"comment\">// 构建业务Key的索引</span></div><div class=\"line\">                    indexFile = putKey(indexFile, msg, buildKey(topic, key));</div><div class=\"line\">                    ...</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        log.error(<span class=\"string\">\"build index error, stop building index\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"RocmetMQ的IndexService设计原理\"><a href=\"#RocmetMQ的IndexService设计原理\" class=\"headerlink\" title=\"RocmetMQ的IndexService设计原理\"></a>RocmetMQ的IndexService设计原理</h4><p><img src=\"/2017/10/12/RocketMQ-Index-service/index-file.gif\" alt=\"你想输入的替代文字\"></p>\n<p>在RocketMQ中，IndexService底层是通过文件来存储的，所以，即使MQ的进程在中途重启过，索引的功能是不受影响的。<br>索引文件的路径是 <code>System.getProperty(&quot;user.home&quot;) + File.separator + &quot;store&quot;</code>，文件名是文件创建的时间，可以有多个，但，<br>在一个文件没有满的情况下，所有的topic的所有的列队的消息，全部都是顺序得存放在一个文件中的，这很重要，下面会详解。<br><img src=\"http://upload-images.jianshu.io/upload_images/716353-2ed415df19a3040b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>在MQ源码中，用IndexFile这个类代表索引文件，对于每一个index file，大小都是固定的，即，都是设计好的。<br>index file在逻辑上被拆分成了3个部分，IndexHead + HashSlotPart + MsgIndexPart，<br>IndexHead<br>索引的开头，和索引的结构没有关系<br>HashSlotPart<br>hash的槽位，是索引的目录，用于定位消息索引在该文件的「MsgIndexPart」的位置，<br>可能有点绕，往下就会觉得很简单，每个槽位是等长的，占4 Byte，一个文件总的槽位数量也是定的，不可改变，槽位数越大，索引的消息越多。<br>MsgIndexPart<br>真实的消息索引，即，每个msgIndex段代表改消息在CommitLog上的PhyicOffset。每个msgIndex段也是等长的，占20 Byte（int + long + int + int）。<br>等长的MsgIndexPart可以理解成功一个有capacity的数组，为了使数组的空间不浪费，那消息就要从前往后一个一个append进去。</p>\n<p>所以，在默认配置下，<br>每个索引文件的大小为<br><code>int fileTotalSize = IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);</code></p>\n<p>CommitLogDispatcherBuildIndex调用dispatch<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(DispatchRequest request)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (DefaultMessageStore.<span class=\"keyword\">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</div><div class=\"line\">        DefaultMessageStore.<span class=\"keyword\">this</span>.indexService.buildIndex(request);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>buildIndex时会构建好几个索引，topic#msgId=&gt;msgIndex, topic#key1=&gt;msgIndex, topic#key2=&gt;msgIndex<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildIndex</span><span class=\"params\">(DispatchRequest req)</span> </span>&#123;</div><div class=\"line\">    IndexFile indexFile = retryGetAndCreateIndexFile();</div><div class=\"line\">    <span class=\"keyword\">if</span> (indexFile != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> endPhyOffset = indexFile.getEndPhyOffset();</div><div class=\"line\">        DispatchRequest msg = req;</div><div class=\"line\">        String topic = msg.getTopic();</div><div class=\"line\">        String keys = msg.getKeys();</div><div class=\"line\"></div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">if</span> (req.getUniqKey() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 构建UniqKey，也就是msgId的索引</span></div><div class=\"line\">            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (keys != <span class=\"keyword\">null</span> &amp;&amp; keys.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; keyset.length; i++) &#123;</div><div class=\"line\">                String key = keyset[i];</div><div class=\"line\">                <span class=\"keyword\">if</span> (key.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"comment\">// 构建业务Key的索引</span></div><div class=\"line\">                    indexFile = putKey(indexFile, msg, buildKey(topic, key));</div><div class=\"line\">                    ...</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        log.error(<span class=\"string\">\"build index error, stop building index\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"面向问题的RocketMQ原理整理","date":"2017-08-09T06:42:53.000Z","_content":"\n工作和学习中使用RocketMQ产生的困惑和总结，属于临时半成品文章，整理完了会单独成文。\n\n### 为什么RocketMQ性能很高？\n\n主要还是得益于存储模型，利用磁盘顺序读写性能远高于随机读写的特性。\n\n### MQ为什么内部要使用好多队列？\n\n1. send性能\n理论上队列入口要加锁（要么是程序的锁，要么是文件的锁）来保证同步，如果队列非常多，虽然不能把锁去掉，但可以减小并发线程对锁的竞争。这个是以前的结论，但实际情况是，consume queue只有一个线程来做。首先，commit log文件只有一个，假如要执行sendMessage，一定要用sync或者自旋锁（之后的版本为了考虑性能），消息都是顺序写进commit log的。对于一个topic的某一个consumer group，consumerQueue文件就有很多个，写consumerQueue文件由一个ReputMessageService的线程近实时空转而触发，也是单个线程。从写consumerQueue文件（send message）的角度来分析，多个队列是没有好处的。\n2. consume性能\n如果从读consumerQueue文件（pull message）的角度来分析，那确实是可以提高并行度。\n\n### MQ的NameServer集群节点中间有没有同步数据？与Zookeeper集群的区别是什么？\n\n### MQ的topic有序性怎么保证\n\nMessageQueueSelector中的List<MessageQueue> mqs指的是所有的broker加起来的队列。\n\n### 怎么让两个Broker中都有某个topic的信息，如果只有一个有，就没法做send的双broker负载均衡\n\nClient发送一个新的topic，在name server上是取不到信息的，所以先用在本地放上Map来缓存，那问题是Broker什么时候给name server发送创建Topic route info的请求？在checkMsg方法中，this.brokerController.registerBrokerAll(false, true);\nMQ的消费者端如果是用push的方式回调，执行listener会开启新的线程用来接收和返回（确认）ack，但一般我们会再开我们的新线程去做消费的事情，这个时候如果由于外界原因进程死亡，那么这些消息就丢失了。\n\n### 哪些情况会引起rebalance?    \n\nmq数量，客户端数量\n\n### 怎么设计Netty的同步调用与异步调用？\n\n掌握CountDownLatch和（限流）\n\n### 万一NameServer都被重启过，那producer或者consumer调用getTopicRouteInfo，信息从何而来？\n\n1. UpdateRouteInfo应该会上传一个新的Topic的信息。\n\n### RocketMQ落盘是异步+定时的，还是就异步的？\n\n异步+定时，时间默认为500ms。\n\nClient向broker pull message 都是以一个一个queue为单位的。processQueueTable代表，这里面的queue正在源源不断向broker请求数据中。而broker的queue的数量是可能发生变化的，所以，要时常对processQueueTable进行必要的整理。\n\n一个Subscription对应一次rebalance调用，一般的情况是n个topic+1个Retry topic。每一次rebalance调用，都会对当前的topic分配broker中的MQ队列，如果分到n个，那个生成n个PullRequest。\n\nRebalanceServer生成 PullRequest 会调用PullMessageService 放入 PullRequest的pullRequestQueue中，PullMessageService从pullRequestQueue队列中take出PullRequest，异步调用Netty。当网络将数据传输回来时，调用PullCallback中的ConsumeMessageService，遍历所有原始消费，对每个消息，生成一个ConsumeRequest，开启多线程进行消费。消费时，返回值怎么处理？比如 Re-consume-later, success。客户端开启一个线程定时去更新Broker的consumerOffset。\n\n### 为什么一旦有producer发送了消息，consumer会几乎无延迟得立刻收到消息？\n\n1. consumer长轮询，在没有消息时hold在server端。\n2. commit log的max offset增大，触发空轮询ReputMessageService，构建完consume queue之后，调用messageArrivingListener通知消息到了，从而重新processRequest来pull消息。\n\n未解决问题：\n\n### Broker里面的protectBroker是用来做什么的？\n\n### CommitLog和ConsumerQueue这两个文件的读写是顺序的么？效率怎么样？\n\n### RocketMQ在哪几种情况下，可能会出现消息重复的问题？\n\n1. 一个consume_group一开始订阅了*tag，之后加了具体的，会发生什么。\n\n### afka的发送消息性能非常高，常用于日志缓冲，是不是用「Oneway」的方式？不然producer发送请求，broker处理请求，producer接受响应，这三段的时间是无论如何都无法缩减的。\n\n### RocketMQ的事务消息是什么？\n看到一段描述很有趣，当发送了分布式事务消息时，如果Producer因为意外宕机，Broker会回调Producer Group的另一一台Producer来确认事务状态。\n2. Commit Log 中存储了所有的元信息，包含消息体，类似于 Mysql、Oracle 的 redolog，所以只要有 Commit\n   Log 在，Consume Queue 即使数据丢失，仍然可以恢复出来。怎么理解？\n3. 在Broker的SendMessageProcessor中，主干线程中只做了一件事，那就是把最新的消息Append到CommitLog中，并且通知Flush线程去force() mmap。所以，构建ConsumeQueue，构建索引这些事情都是异步的，那好像也没有看到通知这些线程，究竟是在哪里通知的呢？ Dispatcher（调度器）ReputMessageService。\n\n### Debug形式启动Producer，Producer发送消息，断点停止后，Producer发送消息会超时失败3次，但此时如果松开断点，让他执行完，那消息是在CommitLog中呢，还是不在？\n\n### MQ在关闭的时候，CommitLog的内容和ConsumeQueue的内容需要能对上号的，但万一异常关闭导致没有对上号，应该怎么处理？CheckPoint机制有没有用？\n\n### 一个消息已经消费过了，能在控制台上选择进行重复投递么？\n\n可以。\n\n### Page Cache到底是个什么东西？\n\n### 对于不可读的Consume Queue，Consumer rebalance时会不会考虑到？\n\n如果没有考虑到，那不可读的队列也分给了Consumer，造成Consumer的浪费。看过源码了，没有问题。\n\n### topic中有readQ, writeQ, 那topic本身的权限是用来做什么的？\n\n### 多个namesrv不一致问题\n\n### 如果某个topic的consume queue上有数据，那设置可读可写队列为0后，数据是不是读不到了。（我知道不会丢失）\n\n### 写Consume queue完全是一个单线程DefaultMessageStore.ReputMessageService中，那就没有锁竞争了，一个Topic到底放多少个队列效率达到最高，是越少越好，还是越多越好？\n\n### namesrv是无状态的，可以随意部署，但Broker启动后怎么是怎么知道新增加的namesrv的？\n\n### 如果发送了某个topic的某个tag的消息，那订阅了该topic的consumer是有可能过滤掉该tag的信息的。那怎么样才能知道该消息是“订阅了，被过滤了”的状态呢？\n\n首先，根据queueId和consume offset可以判断出当前消息是不是已经被\n\n### ConsumerQueue文件删除了，能够复原么？原理\n\n可以\n\n### index file删除了，能够复原么？原理\n\n可以\n\n### ReputMessageService中空转监听是Commitog的offset，当有新的消息时，先是构建consume queue，然后通知PullMessageHoldService，那整个过程在哪里对消息进行过滤，过滤用的是tag，consume queue中也有tag的hash，是不是只需要对比这两个值就好？\n5. 如果一个4G的文件用mmap映射到Java的MappedByteBuffer中，是绝对不可能整体加载进内存的。一个ByteBuffer就是一个有限的byte数组，但是，我们理论上可以在这个数组的任何位置（position）对数组进行读和写，然后映射进文件。如果OS能预感到我们的文件是顺序读写的，那么内存到文件的速度会非常快，如果是随机的，OS没法预测下次的读写位置，这样速度会变慢（这部分去查询下）\n6. PullConsumer：用consumer.pull(MessageQueue mq, String subExpression, long offset, int maxNums)方法去获取Broker的消息，如果第一次offset传了0，获取到了数据，第二次还是传0，还是能获取到数据，是什么原因？Broker的consumerOffset.json为什么不起作用？Pull和Push消费到的点什么时候会被persist到config/consumerOffset.json?详见MQClientInstance.persistAllConsumerOffset会把offsetTable定时发到Broker。\n\n### 程序中处理MappedByteBuffer要特别注意些什么？\n\nA MemoryMappedBuffer has a fixed size, but the file it’s mapped to is elastic.所以一旦当前的程序（或者说当前的线程）对文件的内容失去了独占权，比如文件的内容被其它的线程改了，那原先的线程访问MappedByteBuffer对应位置的缓存就会抛出异常，所以，当我们要用MappedByteBuffer时，一定要确保在多线程下是互斥的。\n\n### RocketMQ发送，接受消息的性能与队列数量的关系。\n\n可以查看kafka相关的信息。\n\n### 如果让你设计一个消息中间件？你会怎么设计？\n\n### 如果一个消息没有消费成功，会隔1s,5s,ns重新消费，这个是怎么实现的？\n\n### 构建IndexService是否可以做成异步？\n\n因为它如果卡住，会影响长轮询，从而影响消息接收的实时性。\n\n### Netty线程问题\nnetty在触发channelRead0的时候，所用的线程是不是workEventLoopGroup所指定的线程\nnettyClientWorkerThread\n\n### netty eventLoopGroup 是什么？\n\n### 网络端口映射\nServer:8080\ncurl 'localhost:8080'\nlsof -i:8080\n\n### 待解决问题\n```\norg.apache.rocketmq.client.exception.MQClientException: No route info of this topic, binlog-msg\nSee http://rocketmq.apache.org/docs/faq/ for further details.\n\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:537)\n\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1038)\n\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:996)\n\tat org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:212)\n\tat org.apache.rock\n```\n\n### 问题\n2017-10-11 07:21:38 WARN SendMessageThread_1 - Offset for /root/store/commitlog/00000000002147483648 not matched. Request offset: 4051326754958557513, index: -521875234, mappedFileSize: 1073741824, mappedFiles count: 1\n2017-10-11 07:21:38 WARN SendMessageThread_1 - findMappedFileByOffset failure. \njava.lang.ArrayIndexOutOfBoundsException: -521875234\n\n请教：rocketmq的这个异常应该如何解决呢？\n\n\n### RocketMQ水位线设置\n\n非常重要\n\n### RocketMQ 业务KEY相同导致哈希冲突\n\n### RocketMQ协议\n\nRocketMQ LengthBasedField\n\n### MQ系统限流和Flow Control\n\n### RocketMQ的NameServer是不是支持分布式一致性\n\n### 现在这个版本，当Master挂掉时，Slave可以升级成新的Master么\n\n\n### RocketMQ怎么样使用性能会非常差？\n\n刷盘的策略，linux 配置的脏页的数量。脏页的比例，和脏页的大小\n\n在公司遇到一种情况，就是不断消费失败\n\n### RocketMQ到底用的是poll,epoll,还是其它的东西？？？？？？\nhttp://www.jianshu.com/p/7835726dc78b?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation\n\nhttp://www.jianshu.com/p/5ab57182af89?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation\n\n\n\n","source":"_posts/RocketMQ-FAQ.md","raw":"---\ntitle: 面向问题的RocketMQ原理整理\ndate: 2017-08-09 14:42:53\ntags: RocketMQ\n---\n\n工作和学习中使用RocketMQ产生的困惑和总结，属于临时半成品文章，整理完了会单独成文。\n\n### 为什么RocketMQ性能很高？\n\n主要还是得益于存储模型，利用磁盘顺序读写性能远高于随机读写的特性。\n\n### MQ为什么内部要使用好多队列？\n\n1. send性能\n理论上队列入口要加锁（要么是程序的锁，要么是文件的锁）来保证同步，如果队列非常多，虽然不能把锁去掉，但可以减小并发线程对锁的竞争。这个是以前的结论，但实际情况是，consume queue只有一个线程来做。首先，commit log文件只有一个，假如要执行sendMessage，一定要用sync或者自旋锁（之后的版本为了考虑性能），消息都是顺序写进commit log的。对于一个topic的某一个consumer group，consumerQueue文件就有很多个，写consumerQueue文件由一个ReputMessageService的线程近实时空转而触发，也是单个线程。从写consumerQueue文件（send message）的角度来分析，多个队列是没有好处的。\n2. consume性能\n如果从读consumerQueue文件（pull message）的角度来分析，那确实是可以提高并行度。\n\n### MQ的NameServer集群节点中间有没有同步数据？与Zookeeper集群的区别是什么？\n\n### MQ的topic有序性怎么保证\n\nMessageQueueSelector中的List<MessageQueue> mqs指的是所有的broker加起来的队列。\n\n### 怎么让两个Broker中都有某个topic的信息，如果只有一个有，就没法做send的双broker负载均衡\n\nClient发送一个新的topic，在name server上是取不到信息的，所以先用在本地放上Map来缓存，那问题是Broker什么时候给name server发送创建Topic route info的请求？在checkMsg方法中，this.brokerController.registerBrokerAll(false, true);\nMQ的消费者端如果是用push的方式回调，执行listener会开启新的线程用来接收和返回（确认）ack，但一般我们会再开我们的新线程去做消费的事情，这个时候如果由于外界原因进程死亡，那么这些消息就丢失了。\n\n### 哪些情况会引起rebalance?    \n\nmq数量，客户端数量\n\n### 怎么设计Netty的同步调用与异步调用？\n\n掌握CountDownLatch和（限流）\n\n### 万一NameServer都被重启过，那producer或者consumer调用getTopicRouteInfo，信息从何而来？\n\n1. UpdateRouteInfo应该会上传一个新的Topic的信息。\n\n### RocketMQ落盘是异步+定时的，还是就异步的？\n\n异步+定时，时间默认为500ms。\n\nClient向broker pull message 都是以一个一个queue为单位的。processQueueTable代表，这里面的queue正在源源不断向broker请求数据中。而broker的queue的数量是可能发生变化的，所以，要时常对processQueueTable进行必要的整理。\n\n一个Subscription对应一次rebalance调用，一般的情况是n个topic+1个Retry topic。每一次rebalance调用，都会对当前的topic分配broker中的MQ队列，如果分到n个，那个生成n个PullRequest。\n\nRebalanceServer生成 PullRequest 会调用PullMessageService 放入 PullRequest的pullRequestQueue中，PullMessageService从pullRequestQueue队列中take出PullRequest，异步调用Netty。当网络将数据传输回来时，调用PullCallback中的ConsumeMessageService，遍历所有原始消费，对每个消息，生成一个ConsumeRequest，开启多线程进行消费。消费时，返回值怎么处理？比如 Re-consume-later, success。客户端开启一个线程定时去更新Broker的consumerOffset。\n\n### 为什么一旦有producer发送了消息，consumer会几乎无延迟得立刻收到消息？\n\n1. consumer长轮询，在没有消息时hold在server端。\n2. commit log的max offset增大，触发空轮询ReputMessageService，构建完consume queue之后，调用messageArrivingListener通知消息到了，从而重新processRequest来pull消息。\n\n未解决问题：\n\n### Broker里面的protectBroker是用来做什么的？\n\n### CommitLog和ConsumerQueue这两个文件的读写是顺序的么？效率怎么样？\n\n### RocketMQ在哪几种情况下，可能会出现消息重复的问题？\n\n1. 一个consume_group一开始订阅了*tag，之后加了具体的，会发生什么。\n\n### afka的发送消息性能非常高，常用于日志缓冲，是不是用「Oneway」的方式？不然producer发送请求，broker处理请求，producer接受响应，这三段的时间是无论如何都无法缩减的。\n\n### RocketMQ的事务消息是什么？\n看到一段描述很有趣，当发送了分布式事务消息时，如果Producer因为意外宕机，Broker会回调Producer Group的另一一台Producer来确认事务状态。\n2. Commit Log 中存储了所有的元信息，包含消息体，类似于 Mysql、Oracle 的 redolog，所以只要有 Commit\n   Log 在，Consume Queue 即使数据丢失，仍然可以恢复出来。怎么理解？\n3. 在Broker的SendMessageProcessor中，主干线程中只做了一件事，那就是把最新的消息Append到CommitLog中，并且通知Flush线程去force() mmap。所以，构建ConsumeQueue，构建索引这些事情都是异步的，那好像也没有看到通知这些线程，究竟是在哪里通知的呢？ Dispatcher（调度器）ReputMessageService。\n\n### Debug形式启动Producer，Producer发送消息，断点停止后，Producer发送消息会超时失败3次，但此时如果松开断点，让他执行完，那消息是在CommitLog中呢，还是不在？\n\n### MQ在关闭的时候，CommitLog的内容和ConsumeQueue的内容需要能对上号的，但万一异常关闭导致没有对上号，应该怎么处理？CheckPoint机制有没有用？\n\n### 一个消息已经消费过了，能在控制台上选择进行重复投递么？\n\n可以。\n\n### Page Cache到底是个什么东西？\n\n### 对于不可读的Consume Queue，Consumer rebalance时会不会考虑到？\n\n如果没有考虑到，那不可读的队列也分给了Consumer，造成Consumer的浪费。看过源码了，没有问题。\n\n### topic中有readQ, writeQ, 那topic本身的权限是用来做什么的？\n\n### 多个namesrv不一致问题\n\n### 如果某个topic的consume queue上有数据，那设置可读可写队列为0后，数据是不是读不到了。（我知道不会丢失）\n\n### 写Consume queue完全是一个单线程DefaultMessageStore.ReputMessageService中，那就没有锁竞争了，一个Topic到底放多少个队列效率达到最高，是越少越好，还是越多越好？\n\n### namesrv是无状态的，可以随意部署，但Broker启动后怎么是怎么知道新增加的namesrv的？\n\n### 如果发送了某个topic的某个tag的消息，那订阅了该topic的consumer是有可能过滤掉该tag的信息的。那怎么样才能知道该消息是“订阅了，被过滤了”的状态呢？\n\n首先，根据queueId和consume offset可以判断出当前消息是不是已经被\n\n### ConsumerQueue文件删除了，能够复原么？原理\n\n可以\n\n### index file删除了，能够复原么？原理\n\n可以\n\n### ReputMessageService中空转监听是Commitog的offset，当有新的消息时，先是构建consume queue，然后通知PullMessageHoldService，那整个过程在哪里对消息进行过滤，过滤用的是tag，consume queue中也有tag的hash，是不是只需要对比这两个值就好？\n5. 如果一个4G的文件用mmap映射到Java的MappedByteBuffer中，是绝对不可能整体加载进内存的。一个ByteBuffer就是一个有限的byte数组，但是，我们理论上可以在这个数组的任何位置（position）对数组进行读和写，然后映射进文件。如果OS能预感到我们的文件是顺序读写的，那么内存到文件的速度会非常快，如果是随机的，OS没法预测下次的读写位置，这样速度会变慢（这部分去查询下）\n6. PullConsumer：用consumer.pull(MessageQueue mq, String subExpression, long offset, int maxNums)方法去获取Broker的消息，如果第一次offset传了0，获取到了数据，第二次还是传0，还是能获取到数据，是什么原因？Broker的consumerOffset.json为什么不起作用？Pull和Push消费到的点什么时候会被persist到config/consumerOffset.json?详见MQClientInstance.persistAllConsumerOffset会把offsetTable定时发到Broker。\n\n### 程序中处理MappedByteBuffer要特别注意些什么？\n\nA MemoryMappedBuffer has a fixed size, but the file it’s mapped to is elastic.所以一旦当前的程序（或者说当前的线程）对文件的内容失去了独占权，比如文件的内容被其它的线程改了，那原先的线程访问MappedByteBuffer对应位置的缓存就会抛出异常，所以，当我们要用MappedByteBuffer时，一定要确保在多线程下是互斥的。\n\n### RocketMQ发送，接受消息的性能与队列数量的关系。\n\n可以查看kafka相关的信息。\n\n### 如果让你设计一个消息中间件？你会怎么设计？\n\n### 如果一个消息没有消费成功，会隔1s,5s,ns重新消费，这个是怎么实现的？\n\n### 构建IndexService是否可以做成异步？\n\n因为它如果卡住，会影响长轮询，从而影响消息接收的实时性。\n\n### Netty线程问题\nnetty在触发channelRead0的时候，所用的线程是不是workEventLoopGroup所指定的线程\nnettyClientWorkerThread\n\n### netty eventLoopGroup 是什么？\n\n### 网络端口映射\nServer:8080\ncurl 'localhost:8080'\nlsof -i:8080\n\n### 待解决问题\n```\norg.apache.rocketmq.client.exception.MQClientException: No route info of this topic, binlog-msg\nSee http://rocketmq.apache.org/docs/faq/ for further details.\n\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:537)\n\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1038)\n\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:996)\n\tat org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:212)\n\tat org.apache.rock\n```\n\n### 问题\n2017-10-11 07:21:38 WARN SendMessageThread_1 - Offset for /root/store/commitlog/00000000002147483648 not matched. Request offset: 4051326754958557513, index: -521875234, mappedFileSize: 1073741824, mappedFiles count: 1\n2017-10-11 07:21:38 WARN SendMessageThread_1 - findMappedFileByOffset failure. \njava.lang.ArrayIndexOutOfBoundsException: -521875234\n\n请教：rocketmq的这个异常应该如何解决呢？\n\n\n### RocketMQ水位线设置\n\n非常重要\n\n### RocketMQ 业务KEY相同导致哈希冲突\n\n### RocketMQ协议\n\nRocketMQ LengthBasedField\n\n### MQ系统限流和Flow Control\n\n### RocketMQ的NameServer是不是支持分布式一致性\n\n### 现在这个版本，当Master挂掉时，Slave可以升级成新的Master么\n\n\n### RocketMQ怎么样使用性能会非常差？\n\n刷盘的策略，linux 配置的脏页的数量。脏页的比例，和脏页的大小\n\n在公司遇到一种情况，就是不断消费失败\n\n### RocketMQ到底用的是poll,epoll,还是其它的东西？？？？？？\nhttp://www.jianshu.com/p/7835726dc78b?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation\n\nhttp://www.jianshu.com/p/5ab57182af89?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation\n\n\n\n","slug":"RocketMQ-FAQ","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszi002r3iq29xlel3d5","content":"<p>工作和学习中使用RocketMQ产生的困惑和总结，属于临时半成品文章，整理完了会单独成文。</p>\n<h3 id=\"为什么RocketMQ性能很高？\"><a href=\"#为什么RocketMQ性能很高？\" class=\"headerlink\" title=\"为什么RocketMQ性能很高？\"></a>为什么RocketMQ性能很高？</h3><p>主要还是得益于存储模型，利用磁盘顺序读写性能远高于随机读写的特性。</p>\n<h3 id=\"MQ为什么内部要使用好多队列？\"><a href=\"#MQ为什么内部要使用好多队列？\" class=\"headerlink\" title=\"MQ为什么内部要使用好多队列？\"></a>MQ为什么内部要使用好多队列？</h3><ol>\n<li>send性能<br>理论上队列入口要加锁（要么是程序的锁，要么是文件的锁）来保证同步，如果队列非常多，虽然不能把锁去掉，但可以减小并发线程对锁的竞争。这个是以前的结论，但实际情况是，consume queue只有一个线程来做。首先，commit log文件只有一个，假如要执行sendMessage，一定要用sync或者自旋锁（之后的版本为了考虑性能），消息都是顺序写进commit log的。对于一个topic的某一个consumer group，consumerQueue文件就有很多个，写consumerQueue文件由一个ReputMessageService的线程近实时空转而触发，也是单个线程。从写consumerQueue文件（send message）的角度来分析，多个队列是没有好处的。</li>\n<li>consume性能<br>如果从读consumerQueue文件（pull message）的角度来分析，那确实是可以提高并行度。</li>\n</ol>\n<h3 id=\"MQ的NameServer集群节点中间有没有同步数据？与Zookeeper集群的区别是什么？\"><a href=\"#MQ的NameServer集群节点中间有没有同步数据？与Zookeeper集群的区别是什么？\" class=\"headerlink\" title=\"MQ的NameServer集群节点中间有没有同步数据？与Zookeeper集群的区别是什么？\"></a>MQ的NameServer集群节点中间有没有同步数据？与Zookeeper集群的区别是什么？</h3><h3 id=\"MQ的topic有序性怎么保证\"><a href=\"#MQ的topic有序性怎么保证\" class=\"headerlink\" title=\"MQ的topic有序性怎么保证\"></a>MQ的topic有序性怎么保证</h3><p>MessageQueueSelector中的List<messagequeue> mqs指的是所有的broker加起来的队列。</messagequeue></p>\n<h3 id=\"怎么让两个Broker中都有某个topic的信息，如果只有一个有，就没法做send的双broker负载均衡\"><a href=\"#怎么让两个Broker中都有某个topic的信息，如果只有一个有，就没法做send的双broker负载均衡\" class=\"headerlink\" title=\"怎么让两个Broker中都有某个topic的信息，如果只有一个有，就没法做send的双broker负载均衡\"></a>怎么让两个Broker中都有某个topic的信息，如果只有一个有，就没法做send的双broker负载均衡</h3><p>Client发送一个新的topic，在name server上是取不到信息的，所以先用在本地放上Map来缓存，那问题是Broker什么时候给name server发送创建Topic route info的请求？在checkMsg方法中，this.brokerController.registerBrokerAll(false, true);<br>MQ的消费者端如果是用push的方式回调，执行listener会开启新的线程用来接收和返回（确认）ack，但一般我们会再开我们的新线程去做消费的事情，这个时候如果由于外界原因进程死亡，那么这些消息就丢失了。</p>\n<h3 id=\"哪些情况会引起rebalance\"><a href=\"#哪些情况会引起rebalance\" class=\"headerlink\" title=\"哪些情况会引起rebalance?\"></a>哪些情况会引起rebalance?</h3><p>mq数量，客户端数量</p>\n<h3 id=\"怎么设计Netty的同步调用与异步调用？\"><a href=\"#怎么设计Netty的同步调用与异步调用？\" class=\"headerlink\" title=\"怎么设计Netty的同步调用与异步调用？\"></a>怎么设计Netty的同步调用与异步调用？</h3><p>掌握CountDownLatch和（限流）</p>\n<h3 id=\"万一NameServer都被重启过，那producer或者consumer调用getTopicRouteInfo，信息从何而来？\"><a href=\"#万一NameServer都被重启过，那producer或者consumer调用getTopicRouteInfo，信息从何而来？\" class=\"headerlink\" title=\"万一NameServer都被重启过，那producer或者consumer调用getTopicRouteInfo，信息从何而来？\"></a>万一NameServer都被重启过，那producer或者consumer调用getTopicRouteInfo，信息从何而来？</h3><ol>\n<li>UpdateRouteInfo应该会上传一个新的Topic的信息。</li>\n</ol>\n<h3 id=\"RocketMQ落盘是异步-定时的，还是就异步的？\"><a href=\"#RocketMQ落盘是异步-定时的，还是就异步的？\" class=\"headerlink\" title=\"RocketMQ落盘是异步+定时的，还是就异步的？\"></a>RocketMQ落盘是异步+定时的，还是就异步的？</h3><p>异步+定时，时间默认为500ms。</p>\n<p>Client向broker pull message 都是以一个一个queue为单位的。processQueueTable代表，这里面的queue正在源源不断向broker请求数据中。而broker的queue的数量是可能发生变化的，所以，要时常对processQueueTable进行必要的整理。</p>\n<p>一个Subscription对应一次rebalance调用，一般的情况是n个topic+1个Retry topic。每一次rebalance调用，都会对当前的topic分配broker中的MQ队列，如果分到n个，那个生成n个PullRequest。</p>\n<p>RebalanceServer生成 PullRequest 会调用PullMessageService 放入 PullRequest的pullRequestQueue中，PullMessageService从pullRequestQueue队列中take出PullRequest，异步调用Netty。当网络将数据传输回来时，调用PullCallback中的ConsumeMessageService，遍历所有原始消费，对每个消息，生成一个ConsumeRequest，开启多线程进行消费。消费时，返回值怎么处理？比如 Re-consume-later, success。客户端开启一个线程定时去更新Broker的consumerOffset。</p>\n<h3 id=\"为什么一旦有producer发送了消息，consumer会几乎无延迟得立刻收到消息？\"><a href=\"#为什么一旦有producer发送了消息，consumer会几乎无延迟得立刻收到消息？\" class=\"headerlink\" title=\"为什么一旦有producer发送了消息，consumer会几乎无延迟得立刻收到消息？\"></a>为什么一旦有producer发送了消息，consumer会几乎无延迟得立刻收到消息？</h3><ol>\n<li>consumer长轮询，在没有消息时hold在server端。</li>\n<li>commit log的max offset增大，触发空轮询ReputMessageService，构建完consume queue之后，调用messageArrivingListener通知消息到了，从而重新processRequest来pull消息。</li>\n</ol>\n<p>未解决问题：</p>\n<h3 id=\"Broker里面的protectBroker是用来做什么的？\"><a href=\"#Broker里面的protectBroker是用来做什么的？\" class=\"headerlink\" title=\"Broker里面的protectBroker是用来做什么的？\"></a>Broker里面的protectBroker是用来做什么的？</h3><h3 id=\"CommitLog和ConsumerQueue这两个文件的读写是顺序的么？效率怎么样？\"><a href=\"#CommitLog和ConsumerQueue这两个文件的读写是顺序的么？效率怎么样？\" class=\"headerlink\" title=\"CommitLog和ConsumerQueue这两个文件的读写是顺序的么？效率怎么样？\"></a>CommitLog和ConsumerQueue这两个文件的读写是顺序的么？效率怎么样？</h3><h3 id=\"RocketMQ在哪几种情况下，可能会出现消息重复的问题？\"><a href=\"#RocketMQ在哪几种情况下，可能会出现消息重复的问题？\" class=\"headerlink\" title=\"RocketMQ在哪几种情况下，可能会出现消息重复的问题？\"></a>RocketMQ在哪几种情况下，可能会出现消息重复的问题？</h3><ol>\n<li>一个consume_group一开始订阅了*tag，之后加了具体的，会发生什么。</li>\n</ol>\n<h3 id=\"afka的发送消息性能非常高，常用于日志缓冲，是不是用「Oneway」的方式？不然producer发送请求，broker处理请求，producer接受响应，这三段的时间是无论如何都无法缩减的。\"><a href=\"#afka的发送消息性能非常高，常用于日志缓冲，是不是用「Oneway」的方式？不然producer发送请求，broker处理请求，producer接受响应，这三段的时间是无论如何都无法缩减的。\" class=\"headerlink\" title=\"afka的发送消息性能非常高，常用于日志缓冲，是不是用「Oneway」的方式？不然producer发送请求，broker处理请求，producer接受响应，这三段的时间是无论如何都无法缩减的。\"></a>afka的发送消息性能非常高，常用于日志缓冲，是不是用「Oneway」的方式？不然producer发送请求，broker处理请求，producer接受响应，这三段的时间是无论如何都无法缩减的。</h3><h3 id=\"RocketMQ的事务消息是什么？\"><a href=\"#RocketMQ的事务消息是什么？\" class=\"headerlink\" title=\"RocketMQ的事务消息是什么？\"></a>RocketMQ的事务消息是什么？</h3><p>看到一段描述很有趣，当发送了分布式事务消息时，如果Producer因为意外宕机，Broker会回调Producer Group的另一一台Producer来确认事务状态。</p>\n<ol>\n<li>Commit Log 中存储了所有的元信息，包含消息体，类似于 Mysql、Oracle 的 redolog，所以只要有 Commit<br>Log 在，Consume Queue 即使数据丢失，仍然可以恢复出来。怎么理解？</li>\n<li>在Broker的SendMessageProcessor中，主干线程中只做了一件事，那就是把最新的消息Append到CommitLog中，并且通知Flush线程去force() mmap。所以，构建ConsumeQueue，构建索引这些事情都是异步的，那好像也没有看到通知这些线程，究竟是在哪里通知的呢？ Dispatcher（调度器）ReputMessageService。</li>\n</ol>\n<h3 id=\"Debug形式启动Producer，Producer发送消息，断点停止后，Producer发送消息会超时失败3次，但此时如果松开断点，让他执行完，那消息是在CommitLog中呢，还是不在？\"><a href=\"#Debug形式启动Producer，Producer发送消息，断点停止后，Producer发送消息会超时失败3次，但此时如果松开断点，让他执行完，那消息是在CommitLog中呢，还是不在？\" class=\"headerlink\" title=\"Debug形式启动Producer，Producer发送消息，断点停止后，Producer发送消息会超时失败3次，但此时如果松开断点，让他执行完，那消息是在CommitLog中呢，还是不在？\"></a>Debug形式启动Producer，Producer发送消息，断点停止后，Producer发送消息会超时失败3次，但此时如果松开断点，让他执行完，那消息是在CommitLog中呢，还是不在？</h3><h3 id=\"MQ在关闭的时候，CommitLog的内容和ConsumeQueue的内容需要能对上号的，但万一异常关闭导致没有对上号，应该怎么处理？CheckPoint机制有没有用？\"><a href=\"#MQ在关闭的时候，CommitLog的内容和ConsumeQueue的内容需要能对上号的，但万一异常关闭导致没有对上号，应该怎么处理？CheckPoint机制有没有用？\" class=\"headerlink\" title=\"MQ在关闭的时候，CommitLog的内容和ConsumeQueue的内容需要能对上号的，但万一异常关闭导致没有对上号，应该怎么处理？CheckPoint机制有没有用？\"></a>MQ在关闭的时候，CommitLog的内容和ConsumeQueue的内容需要能对上号的，但万一异常关闭导致没有对上号，应该怎么处理？CheckPoint机制有没有用？</h3><h3 id=\"一个消息已经消费过了，能在控制台上选择进行重复投递么？\"><a href=\"#一个消息已经消费过了，能在控制台上选择进行重复投递么？\" class=\"headerlink\" title=\"一个消息已经消费过了，能在控制台上选择进行重复投递么？\"></a>一个消息已经消费过了，能在控制台上选择进行重复投递么？</h3><p>可以。</p>\n<h3 id=\"Page-Cache到底是个什么东西？\"><a href=\"#Page-Cache到底是个什么东西？\" class=\"headerlink\" title=\"Page Cache到底是个什么东西？\"></a>Page Cache到底是个什么东西？</h3><h3 id=\"对于不可读的Consume-Queue，Consumer-rebalance时会不会考虑到？\"><a href=\"#对于不可读的Consume-Queue，Consumer-rebalance时会不会考虑到？\" class=\"headerlink\" title=\"对于不可读的Consume Queue，Consumer rebalance时会不会考虑到？\"></a>对于不可读的Consume Queue，Consumer rebalance时会不会考虑到？</h3><p>如果没有考虑到，那不可读的队列也分给了Consumer，造成Consumer的浪费。看过源码了，没有问题。</p>\n<h3 id=\"topic中有readQ-writeQ-那topic本身的权限是用来做什么的？\"><a href=\"#topic中有readQ-writeQ-那topic本身的权限是用来做什么的？\" class=\"headerlink\" title=\"topic中有readQ, writeQ, 那topic本身的权限是用来做什么的？\"></a>topic中有readQ, writeQ, 那topic本身的权限是用来做什么的？</h3><h3 id=\"多个namesrv不一致问题\"><a href=\"#多个namesrv不一致问题\" class=\"headerlink\" title=\"多个namesrv不一致问题\"></a>多个namesrv不一致问题</h3><h3 id=\"如果某个topic的consume-queue上有数据，那设置可读可写队列为0后，数据是不是读不到了。（我知道不会丢失）\"><a href=\"#如果某个topic的consume-queue上有数据，那设置可读可写队列为0后，数据是不是读不到了。（我知道不会丢失）\" class=\"headerlink\" title=\"如果某个topic的consume queue上有数据，那设置可读可写队列为0后，数据是不是读不到了。（我知道不会丢失）\"></a>如果某个topic的consume queue上有数据，那设置可读可写队列为0后，数据是不是读不到了。（我知道不会丢失）</h3><h3 id=\"写Consume-queue完全是一个单线程DefaultMessageStore-ReputMessageService中，那就没有锁竞争了，一个Topic到底放多少个队列效率达到最高，是越少越好，还是越多越好？\"><a href=\"#写Consume-queue完全是一个单线程DefaultMessageStore-ReputMessageService中，那就没有锁竞争了，一个Topic到底放多少个队列效率达到最高，是越少越好，还是越多越好？\" class=\"headerlink\" title=\"写Consume queue完全是一个单线程DefaultMessageStore.ReputMessageService中，那就没有锁竞争了，一个Topic到底放多少个队列效率达到最高，是越少越好，还是越多越好？\"></a>写Consume queue完全是一个单线程DefaultMessageStore.ReputMessageService中，那就没有锁竞争了，一个Topic到底放多少个队列效率达到最高，是越少越好，还是越多越好？</h3><h3 id=\"namesrv是无状态的，可以随意部署，但Broker启动后怎么是怎么知道新增加的namesrv的？\"><a href=\"#namesrv是无状态的，可以随意部署，但Broker启动后怎么是怎么知道新增加的namesrv的？\" class=\"headerlink\" title=\"namesrv是无状态的，可以随意部署，但Broker启动后怎么是怎么知道新增加的namesrv的？\"></a>namesrv是无状态的，可以随意部署，但Broker启动后怎么是怎么知道新增加的namesrv的？</h3><h3 id=\"如果发送了某个topic的某个tag的消息，那订阅了该topic的consumer是有可能过滤掉该tag的信息的。那怎么样才能知道该消息是“订阅了，被过滤了”的状态呢？\"><a href=\"#如果发送了某个topic的某个tag的消息，那订阅了该topic的consumer是有可能过滤掉该tag的信息的。那怎么样才能知道该消息是“订阅了，被过滤了”的状态呢？\" class=\"headerlink\" title=\"如果发送了某个topic的某个tag的消息，那订阅了该topic的consumer是有可能过滤掉该tag的信息的。那怎么样才能知道该消息是“订阅了，被过滤了”的状态呢？\"></a>如果发送了某个topic的某个tag的消息，那订阅了该topic的consumer是有可能过滤掉该tag的信息的。那怎么样才能知道该消息是“订阅了，被过滤了”的状态呢？</h3><p>首先，根据queueId和consume offset可以判断出当前消息是不是已经被</p>\n<h3 id=\"ConsumerQueue文件删除了，能够复原么？原理\"><a href=\"#ConsumerQueue文件删除了，能够复原么？原理\" class=\"headerlink\" title=\"ConsumerQueue文件删除了，能够复原么？原理\"></a>ConsumerQueue文件删除了，能够复原么？原理</h3><p>可以</p>\n<h3 id=\"index-file删除了，能够复原么？原理\"><a href=\"#index-file删除了，能够复原么？原理\" class=\"headerlink\" title=\"index file删除了，能够复原么？原理\"></a>index file删除了，能够复原么？原理</h3><p>可以</p>\n<h3 id=\"ReputMessageService中空转监听是Commitog的offset，当有新的消息时，先是构建consume-queue，然后通知PullMessageHoldService，那整个过程在哪里对消息进行过滤，过滤用的是tag，consume-queue中也有tag的hash，是不是只需要对比这两个值就好？\"><a href=\"#ReputMessageService中空转监听是Commitog的offset，当有新的消息时，先是构建consume-queue，然后通知PullMessageHoldService，那整个过程在哪里对消息进行过滤，过滤用的是tag，consume-queue中也有tag的hash，是不是只需要对比这两个值就好？\" class=\"headerlink\" title=\"ReputMessageService中空转监听是Commitog的offset，当有新的消息时，先是构建consume queue，然后通知PullMessageHoldService，那整个过程在哪里对消息进行过滤，过滤用的是tag，consume queue中也有tag的hash，是不是只需要对比这两个值就好？\"></a>ReputMessageService中空转监听是Commitog的offset，当有新的消息时，先是构建consume queue，然后通知PullMessageHoldService，那整个过程在哪里对消息进行过滤，过滤用的是tag，consume queue中也有tag的hash，是不是只需要对比这两个值就好？</h3><ol>\n<li>如果一个4G的文件用mmap映射到Java的MappedByteBuffer中，是绝对不可能整体加载进内存的。一个ByteBuffer就是一个有限的byte数组，但是，我们理论上可以在这个数组的任何位置（position）对数组进行读和写，然后映射进文件。如果OS能预感到我们的文件是顺序读写的，那么内存到文件的速度会非常快，如果是随机的，OS没法预测下次的读写位置，这样速度会变慢（这部分去查询下）</li>\n<li>PullConsumer：用consumer.pull(MessageQueue mq, String subExpression, long offset, int maxNums)方法去获取Broker的消息，如果第一次offset传了0，获取到了数据，第二次还是传0，还是能获取到数据，是什么原因？Broker的consumerOffset.json为什么不起作用？Pull和Push消费到的点什么时候会被persist到config/consumerOffset.json?详见MQClientInstance.persistAllConsumerOffset会把offsetTable定时发到Broker。</li>\n</ol>\n<h3 id=\"程序中处理MappedByteBuffer要特别注意些什么？\"><a href=\"#程序中处理MappedByteBuffer要特别注意些什么？\" class=\"headerlink\" title=\"程序中处理MappedByteBuffer要特别注意些什么？\"></a>程序中处理MappedByteBuffer要特别注意些什么？</h3><p>A MemoryMappedBuffer has a fixed size, but the file it’s mapped to is elastic.所以一旦当前的程序（或者说当前的线程）对文件的内容失去了独占权，比如文件的内容被其它的线程改了，那原先的线程访问MappedByteBuffer对应位置的缓存就会抛出异常，所以，当我们要用MappedByteBuffer时，一定要确保在多线程下是互斥的。</p>\n<h3 id=\"RocketMQ发送，接受消息的性能与队列数量的关系。\"><a href=\"#RocketMQ发送，接受消息的性能与队列数量的关系。\" class=\"headerlink\" title=\"RocketMQ发送，接受消息的性能与队列数量的关系。\"></a>RocketMQ发送，接受消息的性能与队列数量的关系。</h3><p>可以查看kafka相关的信息。</p>\n<h3 id=\"如果让你设计一个消息中间件？你会怎么设计？\"><a href=\"#如果让你设计一个消息中间件？你会怎么设计？\" class=\"headerlink\" title=\"如果让你设计一个消息中间件？你会怎么设计？\"></a>如果让你设计一个消息中间件？你会怎么设计？</h3><h3 id=\"如果一个消息没有消费成功，会隔1s-5s-ns重新消费，这个是怎么实现的？\"><a href=\"#如果一个消息没有消费成功，会隔1s-5s-ns重新消费，这个是怎么实现的？\" class=\"headerlink\" title=\"如果一个消息没有消费成功，会隔1s,5s,ns重新消费，这个是怎么实现的？\"></a>如果一个消息没有消费成功，会隔1s,5s,ns重新消费，这个是怎么实现的？</h3><h3 id=\"构建IndexService是否可以做成异步？\"><a href=\"#构建IndexService是否可以做成异步？\" class=\"headerlink\" title=\"构建IndexService是否可以做成异步？\"></a>构建IndexService是否可以做成异步？</h3><p>因为它如果卡住，会影响长轮询，从而影响消息接收的实时性。</p>\n<h3 id=\"Netty线程问题\"><a href=\"#Netty线程问题\" class=\"headerlink\" title=\"Netty线程问题\"></a>Netty线程问题</h3><p>netty在触发channelRead0的时候，所用的线程是不是workEventLoopGroup所指定的线程<br>nettyClientWorkerThread</p>\n<h3 id=\"netty-eventLoopGroup-是什么？\"><a href=\"#netty-eventLoopGroup-是什么？\" class=\"headerlink\" title=\"netty eventLoopGroup 是什么？\"></a>netty eventLoopGroup 是什么？</h3><h3 id=\"网络端口映射\"><a href=\"#网络端口映射\" class=\"headerlink\" title=\"网络端口映射\"></a>网络端口映射</h3><p>Server:8080<br>curl ‘localhost:8080’<br>lsof -i:8080</p>\n<h3 id=\"待解决问题\"><a href=\"#待解决问题\" class=\"headerlink\" title=\"待解决问题\"></a>待解决问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">org.apache.rocketmq.client.exception.MQClientException: No route info of this topic, binlog-msg</div><div class=\"line\">See http://rocketmq.apache.org/docs/faq/ for further details.</div><div class=\"line\">\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:537)</div><div class=\"line\">\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1038)</div><div class=\"line\">\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:996)</div><div class=\"line\">\tat org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:212)</div><div class=\"line\">\tat org.apache.rock</div></pre></td></tr></table></figure>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>2017-10-11 07:21:38 WARN SendMessageThread_1 - Offset for /root/store/commitlog/00000000002147483648 not matched. Request offset: 4051326754958557513, index: -521875234, mappedFileSize: 1073741824, mappedFiles count: 1<br>2017-10-11 07:21:38 WARN SendMessageThread_1 - findMappedFileByOffset failure.<br>java.lang.ArrayIndexOutOfBoundsException: -521875234</p>\n<p>请教：rocketmq的这个异常应该如何解决呢？</p>\n<h3 id=\"RocketMQ水位线设置\"><a href=\"#RocketMQ水位线设置\" class=\"headerlink\" title=\"RocketMQ水位线设置\"></a>RocketMQ水位线设置</h3><p>非常重要</p>\n<h3 id=\"RocketMQ-业务KEY相同导致哈希冲突\"><a href=\"#RocketMQ-业务KEY相同导致哈希冲突\" class=\"headerlink\" title=\"RocketMQ 业务KEY相同导致哈希冲突\"></a>RocketMQ 业务KEY相同导致哈希冲突</h3><h3 id=\"RocketMQ协议\"><a href=\"#RocketMQ协议\" class=\"headerlink\" title=\"RocketMQ协议\"></a>RocketMQ协议</h3><p>RocketMQ LengthBasedField</p>\n<h3 id=\"MQ系统限流和Flow-Control\"><a href=\"#MQ系统限流和Flow-Control\" class=\"headerlink\" title=\"MQ系统限流和Flow Control\"></a>MQ系统限流和Flow Control</h3><h3 id=\"RocketMQ的NameServer是不是支持分布式一致性\"><a href=\"#RocketMQ的NameServer是不是支持分布式一致性\" class=\"headerlink\" title=\"RocketMQ的NameServer是不是支持分布式一致性\"></a>RocketMQ的NameServer是不是支持分布式一致性</h3><h3 id=\"现在这个版本，当Master挂掉时，Slave可以升级成新的Master么\"><a href=\"#现在这个版本，当Master挂掉时，Slave可以升级成新的Master么\" class=\"headerlink\" title=\"现在这个版本，当Master挂掉时，Slave可以升级成新的Master么\"></a>现在这个版本，当Master挂掉时，Slave可以升级成新的Master么</h3><h3 id=\"RocketMQ怎么样使用性能会非常差？\"><a href=\"#RocketMQ怎么样使用性能会非常差？\" class=\"headerlink\" title=\"RocketMQ怎么样使用性能会非常差？\"></a>RocketMQ怎么样使用性能会非常差？</h3><p>刷盘的策略，linux 配置的脏页的数量。脏页的比例，和脏页的大小</p>\n<p>在公司遇到一种情况，就是不断消费失败</p>\n<h3 id=\"RocketMQ到底用的是poll-epoll-还是其它的东西？？？？？？\"><a href=\"#RocketMQ到底用的是poll-epoll-还是其它的东西？？？？？？\" class=\"headerlink\" title=\"RocketMQ到底用的是poll,epoll,还是其它的东西？？？？？？\"></a>RocketMQ到底用的是poll,epoll,还是其它的东西？？？？？？</h3><p><a href=\"http://www.jianshu.com/p/7835726dc78b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/7835726dc78b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>\n<p><a href=\"http://www.jianshu.com/p/5ab57182af89?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/5ab57182af89?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>工作和学习中使用RocketMQ产生的困惑和总结，属于临时半成品文章，整理完了会单独成文。</p>\n<h3 id=\"为什么RocketMQ性能很高？\"><a href=\"#为什么RocketMQ性能很高？\" class=\"headerlink\" title=\"为什么RocketMQ性能很高？\"></a>为什么RocketMQ性能很高？</h3><p>主要还是得益于存储模型，利用磁盘顺序读写性能远高于随机读写的特性。</p>\n<h3 id=\"MQ为什么内部要使用好多队列？\"><a href=\"#MQ为什么内部要使用好多队列？\" class=\"headerlink\" title=\"MQ为什么内部要使用好多队列？\"></a>MQ为什么内部要使用好多队列？</h3><ol>\n<li>send性能<br>理论上队列入口要加锁（要么是程序的锁，要么是文件的锁）来保证同步，如果队列非常多，虽然不能把锁去掉，但可以减小并发线程对锁的竞争。这个是以前的结论，但实际情况是，consume queue只有一个线程来做。首先，commit log文件只有一个，假如要执行sendMessage，一定要用sync或者自旋锁（之后的版本为了考虑性能），消息都是顺序写进commit log的。对于一个topic的某一个consumer group，consumerQueue文件就有很多个，写consumerQueue文件由一个ReputMessageService的线程近实时空转而触发，也是单个线程。从写consumerQueue文件（send message）的角度来分析，多个队列是没有好处的。</li>\n<li>consume性能<br>如果从读consumerQueue文件（pull message）的角度来分析，那确实是可以提高并行度。</li>\n</ol>\n<h3 id=\"MQ的NameServer集群节点中间有没有同步数据？与Zookeeper集群的区别是什么？\"><a href=\"#MQ的NameServer集群节点中间有没有同步数据？与Zookeeper集群的区别是什么？\" class=\"headerlink\" title=\"MQ的NameServer集群节点中间有没有同步数据？与Zookeeper集群的区别是什么？\"></a>MQ的NameServer集群节点中间有没有同步数据？与Zookeeper集群的区别是什么？</h3><h3 id=\"MQ的topic有序性怎么保证\"><a href=\"#MQ的topic有序性怎么保证\" class=\"headerlink\" title=\"MQ的topic有序性怎么保证\"></a>MQ的topic有序性怎么保证</h3><p>MessageQueueSelector中的List<messagequeue> mqs指的是所有的broker加起来的队列。</messagequeue></p>\n<h3 id=\"怎么让两个Broker中都有某个topic的信息，如果只有一个有，就没法做send的双broker负载均衡\"><a href=\"#怎么让两个Broker中都有某个topic的信息，如果只有一个有，就没法做send的双broker负载均衡\" class=\"headerlink\" title=\"怎么让两个Broker中都有某个topic的信息，如果只有一个有，就没法做send的双broker负载均衡\"></a>怎么让两个Broker中都有某个topic的信息，如果只有一个有，就没法做send的双broker负载均衡</h3><p>Client发送一个新的topic，在name server上是取不到信息的，所以先用在本地放上Map来缓存，那问题是Broker什么时候给name server发送创建Topic route info的请求？在checkMsg方法中，this.brokerController.registerBrokerAll(false, true);<br>MQ的消费者端如果是用push的方式回调，执行listener会开启新的线程用来接收和返回（确认）ack，但一般我们会再开我们的新线程去做消费的事情，这个时候如果由于外界原因进程死亡，那么这些消息就丢失了。</p>\n<h3 id=\"哪些情况会引起rebalance\"><a href=\"#哪些情况会引起rebalance\" class=\"headerlink\" title=\"哪些情况会引起rebalance?\"></a>哪些情况会引起rebalance?</h3><p>mq数量，客户端数量</p>\n<h3 id=\"怎么设计Netty的同步调用与异步调用？\"><a href=\"#怎么设计Netty的同步调用与异步调用？\" class=\"headerlink\" title=\"怎么设计Netty的同步调用与异步调用？\"></a>怎么设计Netty的同步调用与异步调用？</h3><p>掌握CountDownLatch和（限流）</p>\n<h3 id=\"万一NameServer都被重启过，那producer或者consumer调用getTopicRouteInfo，信息从何而来？\"><a href=\"#万一NameServer都被重启过，那producer或者consumer调用getTopicRouteInfo，信息从何而来？\" class=\"headerlink\" title=\"万一NameServer都被重启过，那producer或者consumer调用getTopicRouteInfo，信息从何而来？\"></a>万一NameServer都被重启过，那producer或者consumer调用getTopicRouteInfo，信息从何而来？</h3><ol>\n<li>UpdateRouteInfo应该会上传一个新的Topic的信息。</li>\n</ol>\n<h3 id=\"RocketMQ落盘是异步-定时的，还是就异步的？\"><a href=\"#RocketMQ落盘是异步-定时的，还是就异步的？\" class=\"headerlink\" title=\"RocketMQ落盘是异步+定时的，还是就异步的？\"></a>RocketMQ落盘是异步+定时的，还是就异步的？</h3><p>异步+定时，时间默认为500ms。</p>\n<p>Client向broker pull message 都是以一个一个queue为单位的。processQueueTable代表，这里面的queue正在源源不断向broker请求数据中。而broker的queue的数量是可能发生变化的，所以，要时常对processQueueTable进行必要的整理。</p>\n<p>一个Subscription对应一次rebalance调用，一般的情况是n个topic+1个Retry topic。每一次rebalance调用，都会对当前的topic分配broker中的MQ队列，如果分到n个，那个生成n个PullRequest。</p>\n<p>RebalanceServer生成 PullRequest 会调用PullMessageService 放入 PullRequest的pullRequestQueue中，PullMessageService从pullRequestQueue队列中take出PullRequest，异步调用Netty。当网络将数据传输回来时，调用PullCallback中的ConsumeMessageService，遍历所有原始消费，对每个消息，生成一个ConsumeRequest，开启多线程进行消费。消费时，返回值怎么处理？比如 Re-consume-later, success。客户端开启一个线程定时去更新Broker的consumerOffset。</p>\n<h3 id=\"为什么一旦有producer发送了消息，consumer会几乎无延迟得立刻收到消息？\"><a href=\"#为什么一旦有producer发送了消息，consumer会几乎无延迟得立刻收到消息？\" class=\"headerlink\" title=\"为什么一旦有producer发送了消息，consumer会几乎无延迟得立刻收到消息？\"></a>为什么一旦有producer发送了消息，consumer会几乎无延迟得立刻收到消息？</h3><ol>\n<li>consumer长轮询，在没有消息时hold在server端。</li>\n<li>commit log的max offset增大，触发空轮询ReputMessageService，构建完consume queue之后，调用messageArrivingListener通知消息到了，从而重新processRequest来pull消息。</li>\n</ol>\n<p>未解决问题：</p>\n<h3 id=\"Broker里面的protectBroker是用来做什么的？\"><a href=\"#Broker里面的protectBroker是用来做什么的？\" class=\"headerlink\" title=\"Broker里面的protectBroker是用来做什么的？\"></a>Broker里面的protectBroker是用来做什么的？</h3><h3 id=\"CommitLog和ConsumerQueue这两个文件的读写是顺序的么？效率怎么样？\"><a href=\"#CommitLog和ConsumerQueue这两个文件的读写是顺序的么？效率怎么样？\" class=\"headerlink\" title=\"CommitLog和ConsumerQueue这两个文件的读写是顺序的么？效率怎么样？\"></a>CommitLog和ConsumerQueue这两个文件的读写是顺序的么？效率怎么样？</h3><h3 id=\"RocketMQ在哪几种情况下，可能会出现消息重复的问题？\"><a href=\"#RocketMQ在哪几种情况下，可能会出现消息重复的问题？\" class=\"headerlink\" title=\"RocketMQ在哪几种情况下，可能会出现消息重复的问题？\"></a>RocketMQ在哪几种情况下，可能会出现消息重复的问题？</h3><ol>\n<li>一个consume_group一开始订阅了*tag，之后加了具体的，会发生什么。</li>\n</ol>\n<h3 id=\"afka的发送消息性能非常高，常用于日志缓冲，是不是用「Oneway」的方式？不然producer发送请求，broker处理请求，producer接受响应，这三段的时间是无论如何都无法缩减的。\"><a href=\"#afka的发送消息性能非常高，常用于日志缓冲，是不是用「Oneway」的方式？不然producer发送请求，broker处理请求，producer接受响应，这三段的时间是无论如何都无法缩减的。\" class=\"headerlink\" title=\"afka的发送消息性能非常高，常用于日志缓冲，是不是用「Oneway」的方式？不然producer发送请求，broker处理请求，producer接受响应，这三段的时间是无论如何都无法缩减的。\"></a>afka的发送消息性能非常高，常用于日志缓冲，是不是用「Oneway」的方式？不然producer发送请求，broker处理请求，producer接受响应，这三段的时间是无论如何都无法缩减的。</h3><h3 id=\"RocketMQ的事务消息是什么？\"><a href=\"#RocketMQ的事务消息是什么？\" class=\"headerlink\" title=\"RocketMQ的事务消息是什么？\"></a>RocketMQ的事务消息是什么？</h3><p>看到一段描述很有趣，当发送了分布式事务消息时，如果Producer因为意外宕机，Broker会回调Producer Group的另一一台Producer来确认事务状态。</p>\n<ol>\n<li>Commit Log 中存储了所有的元信息，包含消息体，类似于 Mysql、Oracle 的 redolog，所以只要有 Commit<br>Log 在，Consume Queue 即使数据丢失，仍然可以恢复出来。怎么理解？</li>\n<li>在Broker的SendMessageProcessor中，主干线程中只做了一件事，那就是把最新的消息Append到CommitLog中，并且通知Flush线程去force() mmap。所以，构建ConsumeQueue，构建索引这些事情都是异步的，那好像也没有看到通知这些线程，究竟是在哪里通知的呢？ Dispatcher（调度器）ReputMessageService。</li>\n</ol>\n<h3 id=\"Debug形式启动Producer，Producer发送消息，断点停止后，Producer发送消息会超时失败3次，但此时如果松开断点，让他执行完，那消息是在CommitLog中呢，还是不在？\"><a href=\"#Debug形式启动Producer，Producer发送消息，断点停止后，Producer发送消息会超时失败3次，但此时如果松开断点，让他执行完，那消息是在CommitLog中呢，还是不在？\" class=\"headerlink\" title=\"Debug形式启动Producer，Producer发送消息，断点停止后，Producer发送消息会超时失败3次，但此时如果松开断点，让他执行完，那消息是在CommitLog中呢，还是不在？\"></a>Debug形式启动Producer，Producer发送消息，断点停止后，Producer发送消息会超时失败3次，但此时如果松开断点，让他执行完，那消息是在CommitLog中呢，还是不在？</h3><h3 id=\"MQ在关闭的时候，CommitLog的内容和ConsumeQueue的内容需要能对上号的，但万一异常关闭导致没有对上号，应该怎么处理？CheckPoint机制有没有用？\"><a href=\"#MQ在关闭的时候，CommitLog的内容和ConsumeQueue的内容需要能对上号的，但万一异常关闭导致没有对上号，应该怎么处理？CheckPoint机制有没有用？\" class=\"headerlink\" title=\"MQ在关闭的时候，CommitLog的内容和ConsumeQueue的内容需要能对上号的，但万一异常关闭导致没有对上号，应该怎么处理？CheckPoint机制有没有用？\"></a>MQ在关闭的时候，CommitLog的内容和ConsumeQueue的内容需要能对上号的，但万一异常关闭导致没有对上号，应该怎么处理？CheckPoint机制有没有用？</h3><h3 id=\"一个消息已经消费过了，能在控制台上选择进行重复投递么？\"><a href=\"#一个消息已经消费过了，能在控制台上选择进行重复投递么？\" class=\"headerlink\" title=\"一个消息已经消费过了，能在控制台上选择进行重复投递么？\"></a>一个消息已经消费过了，能在控制台上选择进行重复投递么？</h3><p>可以。</p>\n<h3 id=\"Page-Cache到底是个什么东西？\"><a href=\"#Page-Cache到底是个什么东西？\" class=\"headerlink\" title=\"Page Cache到底是个什么东西？\"></a>Page Cache到底是个什么东西？</h3><h3 id=\"对于不可读的Consume-Queue，Consumer-rebalance时会不会考虑到？\"><a href=\"#对于不可读的Consume-Queue，Consumer-rebalance时会不会考虑到？\" class=\"headerlink\" title=\"对于不可读的Consume Queue，Consumer rebalance时会不会考虑到？\"></a>对于不可读的Consume Queue，Consumer rebalance时会不会考虑到？</h3><p>如果没有考虑到，那不可读的队列也分给了Consumer，造成Consumer的浪费。看过源码了，没有问题。</p>\n<h3 id=\"topic中有readQ-writeQ-那topic本身的权限是用来做什么的？\"><a href=\"#topic中有readQ-writeQ-那topic本身的权限是用来做什么的？\" class=\"headerlink\" title=\"topic中有readQ, writeQ, 那topic本身的权限是用来做什么的？\"></a>topic中有readQ, writeQ, 那topic本身的权限是用来做什么的？</h3><h3 id=\"多个namesrv不一致问题\"><a href=\"#多个namesrv不一致问题\" class=\"headerlink\" title=\"多个namesrv不一致问题\"></a>多个namesrv不一致问题</h3><h3 id=\"如果某个topic的consume-queue上有数据，那设置可读可写队列为0后，数据是不是读不到了。（我知道不会丢失）\"><a href=\"#如果某个topic的consume-queue上有数据，那设置可读可写队列为0后，数据是不是读不到了。（我知道不会丢失）\" class=\"headerlink\" title=\"如果某个topic的consume queue上有数据，那设置可读可写队列为0后，数据是不是读不到了。（我知道不会丢失）\"></a>如果某个topic的consume queue上有数据，那设置可读可写队列为0后，数据是不是读不到了。（我知道不会丢失）</h3><h3 id=\"写Consume-queue完全是一个单线程DefaultMessageStore-ReputMessageService中，那就没有锁竞争了，一个Topic到底放多少个队列效率达到最高，是越少越好，还是越多越好？\"><a href=\"#写Consume-queue完全是一个单线程DefaultMessageStore-ReputMessageService中，那就没有锁竞争了，一个Topic到底放多少个队列效率达到最高，是越少越好，还是越多越好？\" class=\"headerlink\" title=\"写Consume queue完全是一个单线程DefaultMessageStore.ReputMessageService中，那就没有锁竞争了，一个Topic到底放多少个队列效率达到最高，是越少越好，还是越多越好？\"></a>写Consume queue完全是一个单线程DefaultMessageStore.ReputMessageService中，那就没有锁竞争了，一个Topic到底放多少个队列效率达到最高，是越少越好，还是越多越好？</h3><h3 id=\"namesrv是无状态的，可以随意部署，但Broker启动后怎么是怎么知道新增加的namesrv的？\"><a href=\"#namesrv是无状态的，可以随意部署，但Broker启动后怎么是怎么知道新增加的namesrv的？\" class=\"headerlink\" title=\"namesrv是无状态的，可以随意部署，但Broker启动后怎么是怎么知道新增加的namesrv的？\"></a>namesrv是无状态的，可以随意部署，但Broker启动后怎么是怎么知道新增加的namesrv的？</h3><h3 id=\"如果发送了某个topic的某个tag的消息，那订阅了该topic的consumer是有可能过滤掉该tag的信息的。那怎么样才能知道该消息是“订阅了，被过滤了”的状态呢？\"><a href=\"#如果发送了某个topic的某个tag的消息，那订阅了该topic的consumer是有可能过滤掉该tag的信息的。那怎么样才能知道该消息是“订阅了，被过滤了”的状态呢？\" class=\"headerlink\" title=\"如果发送了某个topic的某个tag的消息，那订阅了该topic的consumer是有可能过滤掉该tag的信息的。那怎么样才能知道该消息是“订阅了，被过滤了”的状态呢？\"></a>如果发送了某个topic的某个tag的消息，那订阅了该topic的consumer是有可能过滤掉该tag的信息的。那怎么样才能知道该消息是“订阅了，被过滤了”的状态呢？</h3><p>首先，根据queueId和consume offset可以判断出当前消息是不是已经被</p>\n<h3 id=\"ConsumerQueue文件删除了，能够复原么？原理\"><a href=\"#ConsumerQueue文件删除了，能够复原么？原理\" class=\"headerlink\" title=\"ConsumerQueue文件删除了，能够复原么？原理\"></a>ConsumerQueue文件删除了，能够复原么？原理</h3><p>可以</p>\n<h3 id=\"index-file删除了，能够复原么？原理\"><a href=\"#index-file删除了，能够复原么？原理\" class=\"headerlink\" title=\"index file删除了，能够复原么？原理\"></a>index file删除了，能够复原么？原理</h3><p>可以</p>\n<h3 id=\"ReputMessageService中空转监听是Commitog的offset，当有新的消息时，先是构建consume-queue，然后通知PullMessageHoldService，那整个过程在哪里对消息进行过滤，过滤用的是tag，consume-queue中也有tag的hash，是不是只需要对比这两个值就好？\"><a href=\"#ReputMessageService中空转监听是Commitog的offset，当有新的消息时，先是构建consume-queue，然后通知PullMessageHoldService，那整个过程在哪里对消息进行过滤，过滤用的是tag，consume-queue中也有tag的hash，是不是只需要对比这两个值就好？\" class=\"headerlink\" title=\"ReputMessageService中空转监听是Commitog的offset，当有新的消息时，先是构建consume queue，然后通知PullMessageHoldService，那整个过程在哪里对消息进行过滤，过滤用的是tag，consume queue中也有tag的hash，是不是只需要对比这两个值就好？\"></a>ReputMessageService中空转监听是Commitog的offset，当有新的消息时，先是构建consume queue，然后通知PullMessageHoldService，那整个过程在哪里对消息进行过滤，过滤用的是tag，consume queue中也有tag的hash，是不是只需要对比这两个值就好？</h3><ol>\n<li>如果一个4G的文件用mmap映射到Java的MappedByteBuffer中，是绝对不可能整体加载进内存的。一个ByteBuffer就是一个有限的byte数组，但是，我们理论上可以在这个数组的任何位置（position）对数组进行读和写，然后映射进文件。如果OS能预感到我们的文件是顺序读写的，那么内存到文件的速度会非常快，如果是随机的，OS没法预测下次的读写位置，这样速度会变慢（这部分去查询下）</li>\n<li>PullConsumer：用consumer.pull(MessageQueue mq, String subExpression, long offset, int maxNums)方法去获取Broker的消息，如果第一次offset传了0，获取到了数据，第二次还是传0，还是能获取到数据，是什么原因？Broker的consumerOffset.json为什么不起作用？Pull和Push消费到的点什么时候会被persist到config/consumerOffset.json?详见MQClientInstance.persistAllConsumerOffset会把offsetTable定时发到Broker。</li>\n</ol>\n<h3 id=\"程序中处理MappedByteBuffer要特别注意些什么？\"><a href=\"#程序中处理MappedByteBuffer要特别注意些什么？\" class=\"headerlink\" title=\"程序中处理MappedByteBuffer要特别注意些什么？\"></a>程序中处理MappedByteBuffer要特别注意些什么？</h3><p>A MemoryMappedBuffer has a fixed size, but the file it’s mapped to is elastic.所以一旦当前的程序（或者说当前的线程）对文件的内容失去了独占权，比如文件的内容被其它的线程改了，那原先的线程访问MappedByteBuffer对应位置的缓存就会抛出异常，所以，当我们要用MappedByteBuffer时，一定要确保在多线程下是互斥的。</p>\n<h3 id=\"RocketMQ发送，接受消息的性能与队列数量的关系。\"><a href=\"#RocketMQ发送，接受消息的性能与队列数量的关系。\" class=\"headerlink\" title=\"RocketMQ发送，接受消息的性能与队列数量的关系。\"></a>RocketMQ发送，接受消息的性能与队列数量的关系。</h3><p>可以查看kafka相关的信息。</p>\n<h3 id=\"如果让你设计一个消息中间件？你会怎么设计？\"><a href=\"#如果让你设计一个消息中间件？你会怎么设计？\" class=\"headerlink\" title=\"如果让你设计一个消息中间件？你会怎么设计？\"></a>如果让你设计一个消息中间件？你会怎么设计？</h3><h3 id=\"如果一个消息没有消费成功，会隔1s-5s-ns重新消费，这个是怎么实现的？\"><a href=\"#如果一个消息没有消费成功，会隔1s-5s-ns重新消费，这个是怎么实现的？\" class=\"headerlink\" title=\"如果一个消息没有消费成功，会隔1s,5s,ns重新消费，这个是怎么实现的？\"></a>如果一个消息没有消费成功，会隔1s,5s,ns重新消费，这个是怎么实现的？</h3><h3 id=\"构建IndexService是否可以做成异步？\"><a href=\"#构建IndexService是否可以做成异步？\" class=\"headerlink\" title=\"构建IndexService是否可以做成异步？\"></a>构建IndexService是否可以做成异步？</h3><p>因为它如果卡住，会影响长轮询，从而影响消息接收的实时性。</p>\n<h3 id=\"Netty线程问题\"><a href=\"#Netty线程问题\" class=\"headerlink\" title=\"Netty线程问题\"></a>Netty线程问题</h3><p>netty在触发channelRead0的时候，所用的线程是不是workEventLoopGroup所指定的线程<br>nettyClientWorkerThread</p>\n<h3 id=\"netty-eventLoopGroup-是什么？\"><a href=\"#netty-eventLoopGroup-是什么？\" class=\"headerlink\" title=\"netty eventLoopGroup 是什么？\"></a>netty eventLoopGroup 是什么？</h3><h3 id=\"网络端口映射\"><a href=\"#网络端口映射\" class=\"headerlink\" title=\"网络端口映射\"></a>网络端口映射</h3><p>Server:8080<br>curl ‘localhost:8080’<br>lsof -i:8080</p>\n<h3 id=\"待解决问题\"><a href=\"#待解决问题\" class=\"headerlink\" title=\"待解决问题\"></a>待解决问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">org.apache.rocketmq.client.exception.MQClientException: No route info of this topic, binlog-msg</div><div class=\"line\">See http://rocketmq.apache.org/docs/faq/ for further details.</div><div class=\"line\">\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:537)</div><div class=\"line\">\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1038)</div><div class=\"line\">\tat org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:996)</div><div class=\"line\">\tat org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:212)</div><div class=\"line\">\tat org.apache.rock</div></pre></td></tr></table></figure>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>2017-10-11 07:21:38 WARN SendMessageThread_1 - Offset for /root/store/commitlog/00000000002147483648 not matched. Request offset: 4051326754958557513, index: -521875234, mappedFileSize: 1073741824, mappedFiles count: 1<br>2017-10-11 07:21:38 WARN SendMessageThread_1 - findMappedFileByOffset failure.<br>java.lang.ArrayIndexOutOfBoundsException: -521875234</p>\n<p>请教：rocketmq的这个异常应该如何解决呢？</p>\n<h3 id=\"RocketMQ水位线设置\"><a href=\"#RocketMQ水位线设置\" class=\"headerlink\" title=\"RocketMQ水位线设置\"></a>RocketMQ水位线设置</h3><p>非常重要</p>\n<h3 id=\"RocketMQ-业务KEY相同导致哈希冲突\"><a href=\"#RocketMQ-业务KEY相同导致哈希冲突\" class=\"headerlink\" title=\"RocketMQ 业务KEY相同导致哈希冲突\"></a>RocketMQ 业务KEY相同导致哈希冲突</h3><h3 id=\"RocketMQ协议\"><a href=\"#RocketMQ协议\" class=\"headerlink\" title=\"RocketMQ协议\"></a>RocketMQ协议</h3><p>RocketMQ LengthBasedField</p>\n<h3 id=\"MQ系统限流和Flow-Control\"><a href=\"#MQ系统限流和Flow-Control\" class=\"headerlink\" title=\"MQ系统限流和Flow Control\"></a>MQ系统限流和Flow Control</h3><h3 id=\"RocketMQ的NameServer是不是支持分布式一致性\"><a href=\"#RocketMQ的NameServer是不是支持分布式一致性\" class=\"headerlink\" title=\"RocketMQ的NameServer是不是支持分布式一致性\"></a>RocketMQ的NameServer是不是支持分布式一致性</h3><h3 id=\"现在这个版本，当Master挂掉时，Slave可以升级成新的Master么\"><a href=\"#现在这个版本，当Master挂掉时，Slave可以升级成新的Master么\" class=\"headerlink\" title=\"现在这个版本，当Master挂掉时，Slave可以升级成新的Master么\"></a>现在这个版本，当Master挂掉时，Slave可以升级成新的Master么</h3><h3 id=\"RocketMQ怎么样使用性能会非常差？\"><a href=\"#RocketMQ怎么样使用性能会非常差？\" class=\"headerlink\" title=\"RocketMQ怎么样使用性能会非常差？\"></a>RocketMQ怎么样使用性能会非常差？</h3><p>刷盘的策略，linux 配置的脏页的数量。脏页的比例，和脏页的大小</p>\n<p>在公司遇到一种情况，就是不断消费失败</p>\n<h3 id=\"RocketMQ到底用的是poll-epoll-还是其它的东西？？？？？？\"><a href=\"#RocketMQ到底用的是poll-epoll-还是其它的东西？？？？？？\" class=\"headerlink\" title=\"RocketMQ到底用的是poll,epoll,还是其它的东西？？？？？？\"></a>RocketMQ到底用的是poll,epoll,还是其它的东西？？？？？？</h3><p><a href=\"http://www.jianshu.com/p/7835726dc78b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/7835726dc78b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>\n<p><a href=\"http://www.jianshu.com/p/5ab57182af89?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/5ab57182af89?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>\n"},{"title":"RocketMQ——Broker的主从复制原理分析（双写机制）","date":"2017-10-12T08:28:24.000Z","_content":"\n``` java\n\n```\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fkfij3xtx8j31kw1514e0.jpg)","source":"_posts/RocketMQ-Master-slave-high-availability.md","raw":"---\ntitle: RocketMQ——Broker的主从复制原理分析（双写机制）\ndate: 2017-10-12 16:28:24\ntags: RocketMQ\n---\n\n``` java\n\n```\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fkfij3xtx8j31kw1514e0.jpg)","slug":"RocketMQ-Master-slave-high-availability","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszj002u3iq2qxnyww2i","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fkfij3xtx8j31kw1514e0.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fkfij3xtx8j31kw1514e0.jpg\" alt=\"\"></p>\n"},{"title":"RocketMQ——Netty实现的远程同步与异步调用（二）","date":"2017-08-21T04:36:42.000Z","_content":"\n### Netty IO框架\nnetty是一个异步IO框架，异步API最大的特点就是基于事件，netty当然也不例外。\n\n### Remote同步调用\n![你想输入的替代文字](RocketMQ-Netty-imp-sync-and-async-invoke/invokeSync.png)\n\n### Remote异步调用\n异步调用不会使Caller线程等待，理论上可以在短时间内不限次数得调用，这将对系统造成非常大压力，所以在异步调用设计中引入了限流机制\n![你想输入的替代文字](RocketMQ-Netty-imp-sync-and-async-invoke/invokeAsync.png)\n\n###","source":"_posts/RocketMQ-Netty-imp-sync-and-async-invoke.md","raw":"---\ntitle: RocketMQ——Netty实现的远程同步与异步调用（二）\ndate: 2017-08-21 12:36:42\ntags: RocketMQ\n---\n\n### Netty IO框架\nnetty是一个异步IO框架，异步API最大的特点就是基于事件，netty当然也不例外。\n\n### Remote同步调用\n![你想输入的替代文字](RocketMQ-Netty-imp-sync-and-async-invoke/invokeSync.png)\n\n### Remote异步调用\n异步调用不会使Caller线程等待，理论上可以在短时间内不限次数得调用，这将对系统造成非常大压力，所以在异步调用设计中引入了限流机制\n![你想输入的替代文字](RocketMQ-Netty-imp-sync-and-async-invoke/invokeAsync.png)\n\n###","slug":"RocketMQ-Netty-imp-sync-and-async-invoke","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszk002v3iq20wk995eu","content":"<h3 id=\"Netty-IO框架\"><a href=\"#Netty-IO框架\" class=\"headerlink\" title=\"Netty IO框架\"></a>Netty IO框架</h3><p>netty是一个异步IO框架，异步API最大的特点就是基于事件，netty当然也不例外。</p>\n<h3 id=\"Remote同步调用\"><a href=\"#Remote同步调用\" class=\"headerlink\" title=\"Remote同步调用\"></a>Remote同步调用</h3><p><img src=\"/2017/08/21/RocketMQ-Netty-imp-sync-and-async-invoke/invokeSync.png\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"Remote异步调用\"><a href=\"#Remote异步调用\" class=\"headerlink\" title=\"Remote异步调用\"></a>Remote异步调用</h3><p>异步调用不会使Caller线程等待，理论上可以在短时间内不限次数得调用，这将对系统造成非常大压力，所以在异步调用设计中引入了限流机制<br><img src=\"/2017/08/21/RocketMQ-Netty-imp-sync-and-async-invoke/invokeAsync.png\" alt=\"你想输入的替代文字\"></p>\n<p>###</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Netty-IO框架\"><a href=\"#Netty-IO框架\" class=\"headerlink\" title=\"Netty IO框架\"></a>Netty IO框架</h3><p>netty是一个异步IO框架，异步API最大的特点就是基于事件，netty当然也不例外。</p>\n<h3 id=\"Remote同步调用\"><a href=\"#Remote同步调用\" class=\"headerlink\" title=\"Remote同步调用\"></a>Remote同步调用</h3><p><img src=\"/2017/08/21/RocketMQ-Netty-imp-sync-and-async-invoke/invokeSync.png\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"Remote异步调用\"><a href=\"#Remote异步调用\" class=\"headerlink\" title=\"Remote异步调用\"></a>Remote异步调用</h3><p>异步调用不会使Caller线程等待，理论上可以在短时间内不限次数得调用，这将对系统造成非常大压力，所以在异步调用设计中引入了限流机制<br><img src=\"/2017/08/21/RocketMQ-Netty-imp-sync-and-async-invoke/invokeAsync.png\" alt=\"你想输入的替代文字\"></p>\n<p>###</p>\n"},{"title":"RocketMQ——消息发送与落盘（三）","date":"2017-11-03T06:38:10.000Z","_content":"\n\nproducer发送消息，如果是立马被消费这种场景\n1.对于consume queue，肯定是顺序读写，所以写进pagecache后，直接就从pagecache被读出来了\n2.对于commit log，虽然不是顺序读，但也是基本有序读，最后大部分也能命中pagecache，不需要走系统IO\n\n如果是消费历史消息，很大程度上，会发现在pagecache中没有，由系统产生缺页中断，从磁盘中重新读到pagecache中（可能还会根据顺序预读很多），然后再将数据从pagecache复制到socket中传输到consumer。\n\n### 异步刷盘有两种方式\n\n``` java\n// Synchronization flush\nif (FlushDiskType.SYNC_FLUSH == this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) {\n    final GroupCommitService service = (GroupCommitService) this.flushCommitLogService;\n}\n// Asynchronous flush\nelse {\n    if (!this.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) {\n        // FlushRealTimeService\n        flushCommitLogService.wakeup();\n    } else {\n        // CommitRealTimeService\n        commitLogService.wakeup();\n    }\n}\n```\n\n``` java\npublic boolean isTransientStorePoolEnable() {\n    return transientStorePoolEnable && FlushDiskType.ASYNC_FLUSH == getFlushDiskType()\n        && BrokerRole.SLAVE != getBrokerRole();\n}\n```\n\ntransientStorePoolEnable的具体含义是什么？\nFlushRealTimeService和CommitRealTimeService刷盘的方式有什么区别，在性能有什么区别？\n\n![你想输入的替代文字](RocketMQ-Message-send-and-persistence/disc-fall.gif)\n\n### 逻辑Offset队列: ConsumerQueue\n\n\n### 物理Offset队列: CommitLog\n\n### MappedByteBuffer\n\n操纵MappedByteBuffer的线程或者进程必须对某一个文件的映射Buffer有独占权，\n在设计上，消息的顺序是由CommitLog决定，所以CommitLog在Append新的消息时，必须上锁进行互斥。\n\n*传统的synchronized叫做monitor lock，当一个线程进入了synchronized的代码块时，我们说，该线程own（拥有）了monitor lock。这种锁是一种重量级锁，用mutual exclusive（互斥）的特性来实现了同步的需求。\n*自旋锁，JDK1.6引进，我们知道，线程状态与状态的切换，是需要内核参与的，简单点来讲，这个过程是需要点时间的。线程B已经own了一个锁，这是线程A去尝试获取锁，本来线程A应该要挂起，JVM不让它挂起，让A在那里做自旋操作，JVM要赌当前持有锁的B会很快释放锁。如果线程B确实很快释放了锁，那对于A来讲是一个非常好事情，因为A可以不用切换状态，立刻持有锁。那什么时候会用到呢？http://blog.csdn.net/u013080921/article/details/42676231\n\n#### Spin Lock(自旋锁)\n\n#### ReentrantLock(重入锁)\n\n\n### 异步刷盘机制\n\nhttp://blog.csdn.net/vonzhoufz/article/details/47248777\n\n#### 磁盘顺序读写与随机读写的差异\n\nhttps://kafka.apache.org/documentation/#design_filesystem\n\nhttp://blog.csdn.net/evankaka/article/details/48464013\n\n需要好好研究：http://blog.csdn.net/javahongxi/article/details/72956619?locationNum=2&fps=1\n虽然讲的是kafka，研究价值极高：http://blog.csdn.net/tototuzuoquan/article/details/73437890\npagecache是一个现在操作系统带有的天然的缓存！！！！！\n\nhttp://blog.csdn.net/mg0832058/article/details/5890688\n内存映射文件原理探索\n\n\n如何查看内存的 PAGESIZE\n``` bash\ngetconf PAGESIZE\n```\n\n终于理解了！！！！ 首先，Kafka重度依赖底层操作系统提供的PageCache功能。当上层有写操作时，操作系统只是将数据写入PageCache，同时标记Page属性为Dirty。当读操作发生时，先从PageCache中查找，如果发生缺页才进行磁盘调度，最终返回需要的数据。实际上PageCache是把尽可能多的空闲内存都当做了磁盘缓存来使用。同时如果有其他进程申请内存，回收PageCache的代价又很小，所以现代的OS都支持PageCache。 \n\n所以说 commit(atLeastSize)的参数就是现代操作系统pagecache的大小。\n\n\nhttp://www.jianshu.com/p/6494e33c9b1f\nConsume Queue 顺序写，顺序读 几乎都是完全命中Page Cache，和内存速度几乎一样\nCommit Log 顺序写，顺序跳跃读，相比完全的随机读，性能也还好\n\nhttp://blog.csdn.net/mg0832058/article/details/5890688\n内存映射文件原理探索\n\n\nhttp://www.jianshu.com/p/6494e33c9b1f\n1).充分利用page cache降低读数据的时间开销. 读取时尽可能让其命中page cache, 减少IO读操作, 所以内存越大越好. 如果系统中堆积的消息过多, 读数据要访问磁盘会不会由于随机读导致系统性能急剧下降, 答案是否定的.\n访问page cache 时, 即使只访问1k的消息, 系统也会提前预读出更多数据, 在下次读时, 就可能命中内存.\n随机访问Commit Log磁盘数据, 系统IO调度算法设置为NOOP方式, 会在一定程度上将完全的随机读变成顺序跳跃方式, 而顺序跳跃方式读较完全的随机读性能会高5倍以上.\n另外4k的消息在完全随机访问情况下, 仍然可以达到8K次每秒以上的读性能.\n由于Consume Queue存储数据量极少, 而且是顺序读, 在PAGECACHE预读作用下, Consume Queue的读性能几乎与内存一致, 即使堆积情况下. 所以可认为Consume Queue完全不会阻碍读性能.\n2).Commit Log中存储了所有的元信息, 包含消息体, 类似于Mysql、Oracle的redolog, 所以只要有Commit Log在, Consume Queue即使数据丢失, 仍然可以恢复出来.\n\nhttps://segmentfault.com/a/1190000003985468\nkafka底层原理\n\n\n\nlinux最多可以容忍多少大小的脏页。脏页－linux内核中的概念，因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，以提高读写速度，这就叫高速缓存，linux是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的。\n\n### 问题\n\npage cache是内存的东西（物理内存还是虚拟内存），我们写文件时先写进内存page cache，然后从page cache刷到disc上\n\n现在MQ异步刷盘是有个间隔的，如果说pagecache中的数据一直没有被刷进磁盘，那所谓的脏页会越来越大，jvm crash后会丢失数据么。那什么时候是不会丢消息的\n\n对于读是好理解的，但对于写，如果文件是顺序写的，commit log和consume queue都是顺序写的，那pagecache的存在如何让速度提升了？是从java heap到pagecache的速度提升了，还是说从pagecache到disc的速度提升了？\n\nproducer发送消息，如果是立马被消费这种场景\n1.对于consume queue，肯定是顺序读写，所以写进pagecache（物理内存）后，直接就从pagecache（物理内存）被读出来了\n2.对于commit log，虽然不是顺序读，但也是基本有序读，最后大部分也能命中pagecache，不需要走系统IO\n\n如果是消费历史消息，很大程度上，会发现在pagecache（虚拟内存）中没有，由系统产生缺页中断，从磁盘中重新读到pagecache中（可能还会根据顺序预读很多），然后再将数据从pagecache复制到socket中传输到consumer。\n\nMappedByteBuffer 能不能映射大于操作系统内存的文件？\nMappedByteBuffer所占用的内存是堆外内存，那什么时候才能被回收\n\nhttp://www.iocoder.cn/RocketMQ/message-store/\nCommitRealTimeService\t异步刷盘 && 开启内存字节缓冲区\t第一\nFlushRealTimeService\t异步刷盘 && 关闭内存字节缓冲区\t第二\nGroupCommitService\t同步刷盘\t第三\n没看懂\n\nhttp://blog.csdn.net/iie_libi/article/details/54289580\n零拷贝技术\n\nConsumer 消费消息过程，使用了零拷贝技术，因为有小块数据传输的需求，效果会比 sendfile 更好，所以RocketMQ选择了mmap+write方式。\n① 优点：即使频繁调用，使用小块文件传输，效率也很高\n② 缺点：不能很好的利用 DMA 方式，会比 sendfile 多消耗CPU，内存安全性控制复杂，需要避免JVM Crash问题。\n\n文件系统\n\n建议选择ext4文件系统，删除文件的实时性强。\n调优：文件系统的io调度算法需要调整为deadline，因为deadline 算法在随机读情况下，可以合并读请求为顺序跳跃方式，从而提高读IO 吞吐量。\n\n文件读写冲突？\n\n写文件的时候，如果消费者在读怎么办？\n依赖于操作系统对文件读写操作的处理，，，永远一个一个进程在写文件，如果其他进程需要访问文件，只能是读，或者是再创建一个副本，写文件。（读写锁+写时复制） 读写锁在哪里\n\n提高pagecache？\n\nRocketMQ用的是FileChannel.map()出来的MappedByteBuffer，这种Buffer是堆外内存，MQ怎么对这部分的内存进行回收？\n``` java\npublic static void clean(final ByteBuffer buffer) {\n    if (buffer == null || !buffer.isDirect() || buffer.capacity() == 0)\n        return;\n    invoke(invoke(viewed(buffer), \"cleaner\"), \"clean\");\n}\n```\n\n``` java\nprivate static class Deallocator\n        implements Runnable {\n    private static Unsafe unsafe = Unsafe.getUnsafe();\n\n    private long address;\n    private long size;\n    private int capacity;\n\n    private Deallocator(long address, long size, int capacity) {\n        assert (address != 0);\n        this.address = address;\n        this.size = size;\n        this.capacity = capacity;\n    }\n\n    public void run() {\n        if (address == 0) {\n            // Paranoia\n            return;\n        }\n        unsafe.freeMemory(address);\n        address = 0;\n        Bits.unreserveMemory(size, capacity);\n    }\n\n}\n```\n\n堆外内存的回收需要依赖显式Full GC或者隐式Full GC，一般来说DisableExplicitGC可以开，也可以关，但是如果禁用了显式GC，当系统没有足够的Full GC时，堆外内存无法回收。\n\n  想要提高pagecache的命中率，即尽量让访问的页在物理内存中，而不是在虚拟内存中，减少IO 读操作，所以从硬件的角度，当然是内存越大越好。\n而在软件角度，rocketmq有以下策略：\n尽量顺序读\n 如果需要随机读的话：\n访问 PAGECACHE 时，即使只访问 1k 的消息，系统也会提前预读出更多数据，在下次读时，就可能命中内存。\n 随机访问 Commit Log 磁盘数据，系统 IO 调度算法设置为NOOP 方式，会在一定程度上将完全的随机读变成顺序跳跃方式，而顺序跳跃方式读较完全的随机读性能会高5 倍以上。\n \n 可能的优化策略\n \n 1．线程绑定核+线程池（取模）\n a) 将每个线程绑定核，一个函数就可以\n b) 优势：避免线程核间调度\n 2．改用互斥锁为读写锁\n a) 读读场景的线程可以并行\n 3．使用xxhash代替crc算法，性能可以提高很多\n a) 参考链接：https://cyan4973.github.io/xxHash/\n 4．使用topic划分多个逻辑队列（链表）\n a) 避免topic的多次字符串的比较\n 5．改用STL的deque来替代MESA list\n a) Deque类似于vector，可以支持随机访问\n b) 常量时间内在头部和尾部插入，删除元素\n 6．改用跳表来代替MESA list\n a) 跳表可以高并发+log（n）的随机访问\n b) 不能删除元素 \n i. 设为标志位，当内存数据达到一定阈值时，写到磁盘或者持久化到leveldb中（hbase也是这样做的）。\n \n _java.nio.channels.FileChannel_\n `public abstract void force(boolean metaData) throws java.io.IOException`\n Forces any updates to this channel's file to be written to the storage device that contains it.\n If this channel's file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash.\n If the file does not reside on a local device then no such guarantee is made.\n The metaData parameter can be used to limit the number of I/O operations that this method is required to perform. Passing false for this parameter indicates that only updates to the file's content need be written to storage; passing true indicates that updates to both the file's content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified.\n Invoking this method may cause an I/O operation to occur even if the channel was only opened for reading. Some operating systems, for example, maintain a last-access time as part of a file's metadata, and this time is updated whenever the file is read. Whether or not this is actually done is system-dependent and is therefore unspecified.\n This method is only guaranteed to force changes that were made to this channel's file via the methods defined in this class. **It may or may not force changes that were made by modifying the content of a mapped byte buffer obtained by invoking the map method. Invoking the force method of the mapped byte buffer will force changes made to the buffer's content to be written.**\n \n _java.nio.MappedByteBuffer_\n `public final MappedByteBuffer force()`\n Forces any changes made to this buffer's content to be written to the storage device containing the mapped file.\n If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.\n If the file does not reside on a local device then no such guarantee is made.\n If this buffer was not mapped in read/write mode (java.nio.channels.FileChannel.MapMode.READ_WRITE) then invoking this method has no effect.\n \n \n ### 写得超级好的一篇文章\n \n http://blog.csdn.net/a417930422/article/details/52585862\n\n包括下面的问题：\n\nwangbin00162017-08-08 17:011楼\n楼主确定 零拷贝-sendfile 对应到java中\n为FileChannel.transferTo(long position, long count, WritableByteChannel target)//？？\n\nrocketmq 文档上面写到 RocketMQ选择了第一种方式，mmap+write方式，因为有小块数据传输的需求，效果会比sendfile更好。\n\n源码里面使用的是netty的FileRegion 用的是FileChannel.transferTo\n\nFileRegion fileRegion =\nnew ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);\nchannel.writeAndFlush(fileRegion)\n            回复  2条回复\n             a417930422\n            a4179304222017-09-21 10:35\n            回复wangbin0016：另外，rocketmq主要使用的是mmap，即java的MappedByteBuffer用于快速读写。\n             a417930422\n            a4179304222017-09-21 10:32\n            回复wangbin0016：rocketmq文档中写的是Consumer 消费消息过程使用了mmap+write，即内存映射文件的方式，请参照我写的rocketmq存储相关文章：http://blog.csdn.net/a417930422/article/details/52585180.\n            你说的netty的FileRegion其实是被rocketmq重新实现的ManyMessageTransfer，而transfer过程其实是将GetMessageResult对象的数据写到netty的channel中，本质是从内核获取数据直接发送至socket，不会复制到用户空间。\n            GetMessageResult其实是mmap的一个子缓冲区而已。\n            有兴趣可以看看源码 com.alibaba.rocketmq.store.DefaultMessageStore.getMessage方法\n            \n            \n            \n            \n            \n为何要懂零拷贝原理？因为rocketmq存储核心使用的就是零拷贝原理。\n\n1. io读写的方式\n   \n   1. 中断\n   2. DMA\n2. 中断方式\n   1. 中断方式的流程图如下：\n      \n      \n      \n      1. 用户进程发起数据读取请求\n      2. 系统调度为该进程分配cpu\n      3. cpu向io控制器(ide,scsi)发送io请求\n      4. 用户进程等待io完成，让出cpu\n      5. 系统调度cpu执行其他任务\n      6. 数据写入至io控制器的缓冲寄存器\n      7. 缓冲寄存器满了向cpu发出中断信号\n      8. cpu读取数据至内存\n   2. 缺点：中断次数取决于缓冲寄存器的大小\n3. DMA ： 直接内存存取\n   1. DMA方式的流程图如下：\n      \n      \n      \n      1. 用户进程发起数据读取请求\n      2. 系统调度为该进程分配cpu\n      3. cpu向DMA发送io请求\n      4. 用户进程等待io完成，让出cpu\n      5. 系统调度cpu执行其他任务\n      6. 数据写入至io控制器的缓冲寄存器\n      7. DMA不断获取缓冲寄存器中的数据（需要cpu时钟）\n      8. 传输至内存（需要cpu时钟）\n      9. 所需的全部数据获取完毕后向cpu发出中断信号\n   2. 优点：减少cpu中断次数，不用cpu拷贝数据\n4. 数据拷贝\n   1. 下面展示了 传统方式读取数据后并通过网络发送 所发生的数据拷贝：\n      \n      \n      \n      1. 一个read系统调用后，DMA执行了一次数据拷贝，从磁盘到内核空间\n      2. read结束后，发生第二次数据拷贝，由cpu将数据从内核空间拷贝至用户空间\n      3. send系统调用，cpu发生第三次数据拷贝，由cpu将数据从用户空间拷贝至内核空间(socket缓冲区)\n      4. send系统调用结束后，DMA执行第四次数据拷贝，将数据从内核拷贝至协议引擎\n      5. 另外，这四个过程中，每个过程都发生一次上下文切换\n   2. 内存缓冲数据，主要是为了提高性能，内核可以预读部分数据，当所需数据小于内存缓冲区大小时，将极大的提高性能。\n   3. 零拷贝是为了消除这个过程中冗余的拷贝\n5. 零拷贝-sendfile 对应到java中\n   \n   为FileChannel.transferTo(long position, long count, WritableByteChannel target)//\n   将数据从文件通道传输到了给定的可写字节通道\n   1. 避免了第2，3步的数据拷贝，参考下图：\n      \n      \n      \n      1. DMA从拷贝至内核缓冲区\n      2. cpu将数据从内核缓冲区拷贝至内核空间(socket缓冲区)\n      3. DMA将数据从内核拷贝至协议引擎\n      4. 这三个过程中共发生2次上下文切换，分别为发起读取文件和发送数据\n   2. 以上过程发生了三次数据拷贝，其中有一次为cpu完成\n   3. linux内核2.4以后，socket缓冲区做了调整，DMA带收集功能，如下图：\n      \n      \n      \n      1. DMA从拷贝至内核缓冲区\n      2. 将数据的位置和长度的信息的描述符增加至内核空间(socket缓冲区)\n      3. DMA将数据从内核拷贝至协议引擎\n6. 零拷贝-mmap 对应到java中\n   \n   为MappedByteBuffer//文件内存映射\n   1. 数据不会复制到用户空间，只在内核空间，与sendfile类似，但是应用程序可以直接操作该内存。\n7. 参考资料\n   1. http://blog.chinaunix.net/uid-25314474-id-3325879.html\n   2. http://blog.chinaunix.net/uid-28874972-id-3725082.html\n   3. https://www.ibm.com/developerworks/cn/java/j-zerocopy/#fig1\n   4. http://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/\n   5. https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/\n","source":"_posts/RocketMQ-Message-send-and-persistence.md","raw":"---\ntitle: RocketMQ——消息发送与落盘（三）\ndate: 2017-11-03 14:38:10\ntags: RocketMQ\n---\n\n\nproducer发送消息，如果是立马被消费这种场景\n1.对于consume queue，肯定是顺序读写，所以写进pagecache后，直接就从pagecache被读出来了\n2.对于commit log，虽然不是顺序读，但也是基本有序读，最后大部分也能命中pagecache，不需要走系统IO\n\n如果是消费历史消息，很大程度上，会发现在pagecache中没有，由系统产生缺页中断，从磁盘中重新读到pagecache中（可能还会根据顺序预读很多），然后再将数据从pagecache复制到socket中传输到consumer。\n\n### 异步刷盘有两种方式\n\n``` java\n// Synchronization flush\nif (FlushDiskType.SYNC_FLUSH == this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) {\n    final GroupCommitService service = (GroupCommitService) this.flushCommitLogService;\n}\n// Asynchronous flush\nelse {\n    if (!this.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) {\n        // FlushRealTimeService\n        flushCommitLogService.wakeup();\n    } else {\n        // CommitRealTimeService\n        commitLogService.wakeup();\n    }\n}\n```\n\n``` java\npublic boolean isTransientStorePoolEnable() {\n    return transientStorePoolEnable && FlushDiskType.ASYNC_FLUSH == getFlushDiskType()\n        && BrokerRole.SLAVE != getBrokerRole();\n}\n```\n\ntransientStorePoolEnable的具体含义是什么？\nFlushRealTimeService和CommitRealTimeService刷盘的方式有什么区别，在性能有什么区别？\n\n![你想输入的替代文字](RocketMQ-Message-send-and-persistence/disc-fall.gif)\n\n### 逻辑Offset队列: ConsumerQueue\n\n\n### 物理Offset队列: CommitLog\n\n### MappedByteBuffer\n\n操纵MappedByteBuffer的线程或者进程必须对某一个文件的映射Buffer有独占权，\n在设计上，消息的顺序是由CommitLog决定，所以CommitLog在Append新的消息时，必须上锁进行互斥。\n\n*传统的synchronized叫做monitor lock，当一个线程进入了synchronized的代码块时，我们说，该线程own（拥有）了monitor lock。这种锁是一种重量级锁，用mutual exclusive（互斥）的特性来实现了同步的需求。\n*自旋锁，JDK1.6引进，我们知道，线程状态与状态的切换，是需要内核参与的，简单点来讲，这个过程是需要点时间的。线程B已经own了一个锁，这是线程A去尝试获取锁，本来线程A应该要挂起，JVM不让它挂起，让A在那里做自旋操作，JVM要赌当前持有锁的B会很快释放锁。如果线程B确实很快释放了锁，那对于A来讲是一个非常好事情，因为A可以不用切换状态，立刻持有锁。那什么时候会用到呢？http://blog.csdn.net/u013080921/article/details/42676231\n\n#### Spin Lock(自旋锁)\n\n#### ReentrantLock(重入锁)\n\n\n### 异步刷盘机制\n\nhttp://blog.csdn.net/vonzhoufz/article/details/47248777\n\n#### 磁盘顺序读写与随机读写的差异\n\nhttps://kafka.apache.org/documentation/#design_filesystem\n\nhttp://blog.csdn.net/evankaka/article/details/48464013\n\n需要好好研究：http://blog.csdn.net/javahongxi/article/details/72956619?locationNum=2&fps=1\n虽然讲的是kafka，研究价值极高：http://blog.csdn.net/tototuzuoquan/article/details/73437890\npagecache是一个现在操作系统带有的天然的缓存！！！！！\n\nhttp://blog.csdn.net/mg0832058/article/details/5890688\n内存映射文件原理探索\n\n\n如何查看内存的 PAGESIZE\n``` bash\ngetconf PAGESIZE\n```\n\n终于理解了！！！！ 首先，Kafka重度依赖底层操作系统提供的PageCache功能。当上层有写操作时，操作系统只是将数据写入PageCache，同时标记Page属性为Dirty。当读操作发生时，先从PageCache中查找，如果发生缺页才进行磁盘调度，最终返回需要的数据。实际上PageCache是把尽可能多的空闲内存都当做了磁盘缓存来使用。同时如果有其他进程申请内存，回收PageCache的代价又很小，所以现代的OS都支持PageCache。 \n\n所以说 commit(atLeastSize)的参数就是现代操作系统pagecache的大小。\n\n\nhttp://www.jianshu.com/p/6494e33c9b1f\nConsume Queue 顺序写，顺序读 几乎都是完全命中Page Cache，和内存速度几乎一样\nCommit Log 顺序写，顺序跳跃读，相比完全的随机读，性能也还好\n\nhttp://blog.csdn.net/mg0832058/article/details/5890688\n内存映射文件原理探索\n\n\nhttp://www.jianshu.com/p/6494e33c9b1f\n1).充分利用page cache降低读数据的时间开销. 读取时尽可能让其命中page cache, 减少IO读操作, 所以内存越大越好. 如果系统中堆积的消息过多, 读数据要访问磁盘会不会由于随机读导致系统性能急剧下降, 答案是否定的.\n访问page cache 时, 即使只访问1k的消息, 系统也会提前预读出更多数据, 在下次读时, 就可能命中内存.\n随机访问Commit Log磁盘数据, 系统IO调度算法设置为NOOP方式, 会在一定程度上将完全的随机读变成顺序跳跃方式, 而顺序跳跃方式读较完全的随机读性能会高5倍以上.\n另外4k的消息在完全随机访问情况下, 仍然可以达到8K次每秒以上的读性能.\n由于Consume Queue存储数据量极少, 而且是顺序读, 在PAGECACHE预读作用下, Consume Queue的读性能几乎与内存一致, 即使堆积情况下. 所以可认为Consume Queue完全不会阻碍读性能.\n2).Commit Log中存储了所有的元信息, 包含消息体, 类似于Mysql、Oracle的redolog, 所以只要有Commit Log在, Consume Queue即使数据丢失, 仍然可以恢复出来.\n\nhttps://segmentfault.com/a/1190000003985468\nkafka底层原理\n\n\n\nlinux最多可以容忍多少大小的脏页。脏页－linux内核中的概念，因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，以提高读写速度，这就叫高速缓存，linux是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的。\n\n### 问题\n\npage cache是内存的东西（物理内存还是虚拟内存），我们写文件时先写进内存page cache，然后从page cache刷到disc上\n\n现在MQ异步刷盘是有个间隔的，如果说pagecache中的数据一直没有被刷进磁盘，那所谓的脏页会越来越大，jvm crash后会丢失数据么。那什么时候是不会丢消息的\n\n对于读是好理解的，但对于写，如果文件是顺序写的，commit log和consume queue都是顺序写的，那pagecache的存在如何让速度提升了？是从java heap到pagecache的速度提升了，还是说从pagecache到disc的速度提升了？\n\nproducer发送消息，如果是立马被消费这种场景\n1.对于consume queue，肯定是顺序读写，所以写进pagecache（物理内存）后，直接就从pagecache（物理内存）被读出来了\n2.对于commit log，虽然不是顺序读，但也是基本有序读，最后大部分也能命中pagecache，不需要走系统IO\n\n如果是消费历史消息，很大程度上，会发现在pagecache（虚拟内存）中没有，由系统产生缺页中断，从磁盘中重新读到pagecache中（可能还会根据顺序预读很多），然后再将数据从pagecache复制到socket中传输到consumer。\n\nMappedByteBuffer 能不能映射大于操作系统内存的文件？\nMappedByteBuffer所占用的内存是堆外内存，那什么时候才能被回收\n\nhttp://www.iocoder.cn/RocketMQ/message-store/\nCommitRealTimeService\t异步刷盘 && 开启内存字节缓冲区\t第一\nFlushRealTimeService\t异步刷盘 && 关闭内存字节缓冲区\t第二\nGroupCommitService\t同步刷盘\t第三\n没看懂\n\nhttp://blog.csdn.net/iie_libi/article/details/54289580\n零拷贝技术\n\nConsumer 消费消息过程，使用了零拷贝技术，因为有小块数据传输的需求，效果会比 sendfile 更好，所以RocketMQ选择了mmap+write方式。\n① 优点：即使频繁调用，使用小块文件传输，效率也很高\n② 缺点：不能很好的利用 DMA 方式，会比 sendfile 多消耗CPU，内存安全性控制复杂，需要避免JVM Crash问题。\n\n文件系统\n\n建议选择ext4文件系统，删除文件的实时性强。\n调优：文件系统的io调度算法需要调整为deadline，因为deadline 算法在随机读情况下，可以合并读请求为顺序跳跃方式，从而提高读IO 吞吐量。\n\n文件读写冲突？\n\n写文件的时候，如果消费者在读怎么办？\n依赖于操作系统对文件读写操作的处理，，，永远一个一个进程在写文件，如果其他进程需要访问文件，只能是读，或者是再创建一个副本，写文件。（读写锁+写时复制） 读写锁在哪里\n\n提高pagecache？\n\nRocketMQ用的是FileChannel.map()出来的MappedByteBuffer，这种Buffer是堆外内存，MQ怎么对这部分的内存进行回收？\n``` java\npublic static void clean(final ByteBuffer buffer) {\n    if (buffer == null || !buffer.isDirect() || buffer.capacity() == 0)\n        return;\n    invoke(invoke(viewed(buffer), \"cleaner\"), \"clean\");\n}\n```\n\n``` java\nprivate static class Deallocator\n        implements Runnable {\n    private static Unsafe unsafe = Unsafe.getUnsafe();\n\n    private long address;\n    private long size;\n    private int capacity;\n\n    private Deallocator(long address, long size, int capacity) {\n        assert (address != 0);\n        this.address = address;\n        this.size = size;\n        this.capacity = capacity;\n    }\n\n    public void run() {\n        if (address == 0) {\n            // Paranoia\n            return;\n        }\n        unsafe.freeMemory(address);\n        address = 0;\n        Bits.unreserveMemory(size, capacity);\n    }\n\n}\n```\n\n堆外内存的回收需要依赖显式Full GC或者隐式Full GC，一般来说DisableExplicitGC可以开，也可以关，但是如果禁用了显式GC，当系统没有足够的Full GC时，堆外内存无法回收。\n\n  想要提高pagecache的命中率，即尽量让访问的页在物理内存中，而不是在虚拟内存中，减少IO 读操作，所以从硬件的角度，当然是内存越大越好。\n而在软件角度，rocketmq有以下策略：\n尽量顺序读\n 如果需要随机读的话：\n访问 PAGECACHE 时，即使只访问 1k 的消息，系统也会提前预读出更多数据，在下次读时，就可能命中内存。\n 随机访问 Commit Log 磁盘数据，系统 IO 调度算法设置为NOOP 方式，会在一定程度上将完全的随机读变成顺序跳跃方式，而顺序跳跃方式读较完全的随机读性能会高5 倍以上。\n \n 可能的优化策略\n \n 1．线程绑定核+线程池（取模）\n a) 将每个线程绑定核，一个函数就可以\n b) 优势：避免线程核间调度\n 2．改用互斥锁为读写锁\n a) 读读场景的线程可以并行\n 3．使用xxhash代替crc算法，性能可以提高很多\n a) 参考链接：https://cyan4973.github.io/xxHash/\n 4．使用topic划分多个逻辑队列（链表）\n a) 避免topic的多次字符串的比较\n 5．改用STL的deque来替代MESA list\n a) Deque类似于vector，可以支持随机访问\n b) 常量时间内在头部和尾部插入，删除元素\n 6．改用跳表来代替MESA list\n a) 跳表可以高并发+log（n）的随机访问\n b) 不能删除元素 \n i. 设为标志位，当内存数据达到一定阈值时，写到磁盘或者持久化到leveldb中（hbase也是这样做的）。\n \n _java.nio.channels.FileChannel_\n `public abstract void force(boolean metaData) throws java.io.IOException`\n Forces any updates to this channel's file to be written to the storage device that contains it.\n If this channel's file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash.\n If the file does not reside on a local device then no such guarantee is made.\n The metaData parameter can be used to limit the number of I/O operations that this method is required to perform. Passing false for this parameter indicates that only updates to the file's content need be written to storage; passing true indicates that updates to both the file's content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified.\n Invoking this method may cause an I/O operation to occur even if the channel was only opened for reading. Some operating systems, for example, maintain a last-access time as part of a file's metadata, and this time is updated whenever the file is read. Whether or not this is actually done is system-dependent and is therefore unspecified.\n This method is only guaranteed to force changes that were made to this channel's file via the methods defined in this class. **It may or may not force changes that were made by modifying the content of a mapped byte buffer obtained by invoking the map method. Invoking the force method of the mapped byte buffer will force changes made to the buffer's content to be written.**\n \n _java.nio.MappedByteBuffer_\n `public final MappedByteBuffer force()`\n Forces any changes made to this buffer's content to be written to the storage device containing the mapped file.\n If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.\n If the file does not reside on a local device then no such guarantee is made.\n If this buffer was not mapped in read/write mode (java.nio.channels.FileChannel.MapMode.READ_WRITE) then invoking this method has no effect.\n \n \n ### 写得超级好的一篇文章\n \n http://blog.csdn.net/a417930422/article/details/52585862\n\n包括下面的问题：\n\nwangbin00162017-08-08 17:011楼\n楼主确定 零拷贝-sendfile 对应到java中\n为FileChannel.transferTo(long position, long count, WritableByteChannel target)//？？\n\nrocketmq 文档上面写到 RocketMQ选择了第一种方式，mmap+write方式，因为有小块数据传输的需求，效果会比sendfile更好。\n\n源码里面使用的是netty的FileRegion 用的是FileChannel.transferTo\n\nFileRegion fileRegion =\nnew ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);\nchannel.writeAndFlush(fileRegion)\n            回复  2条回复\n             a417930422\n            a4179304222017-09-21 10:35\n            回复wangbin0016：另外，rocketmq主要使用的是mmap，即java的MappedByteBuffer用于快速读写。\n             a417930422\n            a4179304222017-09-21 10:32\n            回复wangbin0016：rocketmq文档中写的是Consumer 消费消息过程使用了mmap+write，即内存映射文件的方式，请参照我写的rocketmq存储相关文章：http://blog.csdn.net/a417930422/article/details/52585180.\n            你说的netty的FileRegion其实是被rocketmq重新实现的ManyMessageTransfer，而transfer过程其实是将GetMessageResult对象的数据写到netty的channel中，本质是从内核获取数据直接发送至socket，不会复制到用户空间。\n            GetMessageResult其实是mmap的一个子缓冲区而已。\n            有兴趣可以看看源码 com.alibaba.rocketmq.store.DefaultMessageStore.getMessage方法\n            \n            \n            \n            \n            \n为何要懂零拷贝原理？因为rocketmq存储核心使用的就是零拷贝原理。\n\n1. io读写的方式\n   \n   1. 中断\n   2. DMA\n2. 中断方式\n   1. 中断方式的流程图如下：\n      \n      \n      \n      1. 用户进程发起数据读取请求\n      2. 系统调度为该进程分配cpu\n      3. cpu向io控制器(ide,scsi)发送io请求\n      4. 用户进程等待io完成，让出cpu\n      5. 系统调度cpu执行其他任务\n      6. 数据写入至io控制器的缓冲寄存器\n      7. 缓冲寄存器满了向cpu发出中断信号\n      8. cpu读取数据至内存\n   2. 缺点：中断次数取决于缓冲寄存器的大小\n3. DMA ： 直接内存存取\n   1. DMA方式的流程图如下：\n      \n      \n      \n      1. 用户进程发起数据读取请求\n      2. 系统调度为该进程分配cpu\n      3. cpu向DMA发送io请求\n      4. 用户进程等待io完成，让出cpu\n      5. 系统调度cpu执行其他任务\n      6. 数据写入至io控制器的缓冲寄存器\n      7. DMA不断获取缓冲寄存器中的数据（需要cpu时钟）\n      8. 传输至内存（需要cpu时钟）\n      9. 所需的全部数据获取完毕后向cpu发出中断信号\n   2. 优点：减少cpu中断次数，不用cpu拷贝数据\n4. 数据拷贝\n   1. 下面展示了 传统方式读取数据后并通过网络发送 所发生的数据拷贝：\n      \n      \n      \n      1. 一个read系统调用后，DMA执行了一次数据拷贝，从磁盘到内核空间\n      2. read结束后，发生第二次数据拷贝，由cpu将数据从内核空间拷贝至用户空间\n      3. send系统调用，cpu发生第三次数据拷贝，由cpu将数据从用户空间拷贝至内核空间(socket缓冲区)\n      4. send系统调用结束后，DMA执行第四次数据拷贝，将数据从内核拷贝至协议引擎\n      5. 另外，这四个过程中，每个过程都发生一次上下文切换\n   2. 内存缓冲数据，主要是为了提高性能，内核可以预读部分数据，当所需数据小于内存缓冲区大小时，将极大的提高性能。\n   3. 零拷贝是为了消除这个过程中冗余的拷贝\n5. 零拷贝-sendfile 对应到java中\n   \n   为FileChannel.transferTo(long position, long count, WritableByteChannel target)//\n   将数据从文件通道传输到了给定的可写字节通道\n   1. 避免了第2，3步的数据拷贝，参考下图：\n      \n      \n      \n      1. DMA从拷贝至内核缓冲区\n      2. cpu将数据从内核缓冲区拷贝至内核空间(socket缓冲区)\n      3. DMA将数据从内核拷贝至协议引擎\n      4. 这三个过程中共发生2次上下文切换，分别为发起读取文件和发送数据\n   2. 以上过程发生了三次数据拷贝，其中有一次为cpu完成\n   3. linux内核2.4以后，socket缓冲区做了调整，DMA带收集功能，如下图：\n      \n      \n      \n      1. DMA从拷贝至内核缓冲区\n      2. 将数据的位置和长度的信息的描述符增加至内核空间(socket缓冲区)\n      3. DMA将数据从内核拷贝至协议引擎\n6. 零拷贝-mmap 对应到java中\n   \n   为MappedByteBuffer//文件内存映射\n   1. 数据不会复制到用户空间，只在内核空间，与sendfile类似，但是应用程序可以直接操作该内存。\n7. 参考资料\n   1. http://blog.chinaunix.net/uid-25314474-id-3325879.html\n   2. http://blog.chinaunix.net/uid-28874972-id-3725082.html\n   3. https://www.ibm.com/developerworks/cn/java/j-zerocopy/#fig1\n   4. http://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/\n   5. https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/\n","slug":"RocketMQ-Message-send-and-persistence","published":1,"updated":"2018-07-12T03:31:15.000Z","_id":"cjj3wcszl002y3iq2nubws3qo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>producer发送消息，如果是立马被消费这种场景<br>1.对于consume queue，肯定是顺序读写，所以写进pagecache后，直接就从pagecache被读出来了<br>2.对于commit log，虽然不是顺序读，但也是基本有序读，最后大部分也能命中pagecache，不需要走系统IO</p>\n<p>如果是消费历史消息，很大程度上，会发现在pagecache中没有，由系统产生缺页中断，从磁盘中重新读到pagecache中（可能还会根据顺序预读很多），然后再将数据从pagecache复制到socket中传输到consumer。</p>\n<h3 id=\"异步刷盘有两种方式\"><a href=\"#异步刷盘有两种方式\" class=\"headerlink\" title=\"异步刷盘有两种方式\"></a>异步刷盘有两种方式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Synchronization flush</span></div><div class=\"line\"><span class=\"keyword\">if</span> (FlushDiskType.SYNC_FLUSH == <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> GroupCommitService service = (GroupCommitService) <span class=\"keyword\">this</span>.flushCommitLogService;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Asynchronous flush</span></div><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</div><div class=\"line\">        <span class=\"comment\">// FlushRealTimeService</span></div><div class=\"line\">        flushCommitLogService.wakeup();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// CommitRealTimeService</span></div><div class=\"line\">        commitLogService.wakeup();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTransientStorePoolEnable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> transientStorePoolEnable &amp;&amp; FlushDiskType.ASYNC_FLUSH == getFlushDiskType()</div><div class=\"line\">        &amp;&amp; BrokerRole.SLAVE != getBrokerRole();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>transientStorePoolEnable的具体含义是什么？<br>FlushRealTimeService和CommitRealTimeService刷盘的方式有什么区别，在性能有什么区别？</p>\n<p><img src=\"/2017/11/03/RocketMQ-Message-send-and-persistence/disc-fall.gif\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"逻辑Offset队列-ConsumerQueue\"><a href=\"#逻辑Offset队列-ConsumerQueue\" class=\"headerlink\" title=\"逻辑Offset队列: ConsumerQueue\"></a>逻辑Offset队列: ConsumerQueue</h3><h3 id=\"物理Offset队列-CommitLog\"><a href=\"#物理Offset队列-CommitLog\" class=\"headerlink\" title=\"物理Offset队列: CommitLog\"></a>物理Offset队列: CommitLog</h3><h3 id=\"MappedByteBuffer\"><a href=\"#MappedByteBuffer\" class=\"headerlink\" title=\"MappedByteBuffer\"></a>MappedByteBuffer</h3><p>操纵MappedByteBuffer的线程或者进程必须对某一个文件的映射Buffer有独占权，<br>在设计上，消息的顺序是由CommitLog决定，所以CommitLog在Append新的消息时，必须上锁进行互斥。</p>\n<p><em>传统的synchronized叫做monitor lock，当一个线程进入了synchronized的代码块时，我们说，该线程own（拥有）了monitor lock。这种锁是一种重量级锁，用mutual exclusive（互斥）的特性来实现了同步的需求。\n</em>自旋锁，JDK1.6引进，我们知道，线程状态与状态的切换，是需要内核参与的，简单点来讲，这个过程是需要点时间的。线程B已经own了一个锁，这是线程A去尝试获取锁，本来线程A应该要挂起，JVM不让它挂起，让A在那里做自旋操作，JVM要赌当前持有锁的B会很快释放锁。如果线程B确实很快释放了锁，那对于A来讲是一个非常好事情，因为A可以不用切换状态，立刻持有锁。那什么时候会用到呢？<a href=\"http://blog.csdn.net/u013080921/article/details/42676231\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u013080921/article/details/42676231</a></p>\n<h4 id=\"Spin-Lock-自旋锁\"><a href=\"#Spin-Lock-自旋锁\" class=\"headerlink\" title=\"Spin Lock(自旋锁)\"></a>Spin Lock(自旋锁)</h4><h4 id=\"ReentrantLock-重入锁\"><a href=\"#ReentrantLock-重入锁\" class=\"headerlink\" title=\"ReentrantLock(重入锁)\"></a>ReentrantLock(重入锁)</h4><h3 id=\"异步刷盘机制\"><a href=\"#异步刷盘机制\" class=\"headerlink\" title=\"异步刷盘机制\"></a>异步刷盘机制</h3><p><a href=\"http://blog.csdn.net/vonzhoufz/article/details/47248777\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/vonzhoufz/article/details/47248777</a></p>\n<h4 id=\"磁盘顺序读写与随机读写的差异\"><a href=\"#磁盘顺序读写与随机读写的差异\" class=\"headerlink\" title=\"磁盘顺序读写与随机读写的差异\"></a>磁盘顺序读写与随机读写的差异</h4><p><a href=\"https://kafka.apache.org/documentation/#design_filesystem\" target=\"_blank\" rel=\"external\">https://kafka.apache.org/documentation/#design_filesystem</a></p>\n<p><a href=\"http://blog.csdn.net/evankaka/article/details/48464013\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/evankaka/article/details/48464013</a></p>\n<p>需要好好研究：<a href=\"http://blog.csdn.net/javahongxi/article/details/72956619?locationNum=2&amp;fps=1\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/javahongxi/article/details/72956619?locationNum=2&amp;fps=1</a><br>虽然讲的是kafka，研究价值极高：<a href=\"http://blog.csdn.net/tototuzuoquan/article/details/73437890\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/tototuzuoquan/article/details/73437890</a><br>pagecache是一个现在操作系统带有的天然的缓存！！！！！</p>\n<p><a href=\"http://blog.csdn.net/mg0832058/article/details/5890688\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/mg0832058/article/details/5890688</a><br>内存映射文件原理探索</p>\n<p>如何查看内存的 PAGESIZE<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">getconf PAGESIZE</div></pre></td></tr></table></figure></p>\n<p>终于理解了！！！！ 首先，Kafka重度依赖底层操作系统提供的PageCache功能。当上层有写操作时，操作系统只是将数据写入PageCache，同时标记Page属性为Dirty。当读操作发生时，先从PageCache中查找，如果发生缺页才进行磁盘调度，最终返回需要的数据。实际上PageCache是把尽可能多的空闲内存都当做了磁盘缓存来使用。同时如果有其他进程申请内存，回收PageCache的代价又很小，所以现代的OS都支持PageCache。 </p>\n<p>所以说 commit(atLeastSize)的参数就是现代操作系统pagecache的大小。</p>\n<p><a href=\"http://www.jianshu.com/p/6494e33c9b1f\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/6494e33c9b1f</a><br>Consume Queue 顺序写，顺序读 几乎都是完全命中Page Cache，和内存速度几乎一样<br>Commit Log 顺序写，顺序跳跃读，相比完全的随机读，性能也还好</p>\n<p><a href=\"http://blog.csdn.net/mg0832058/article/details/5890688\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/mg0832058/article/details/5890688</a><br>内存映射文件原理探索</p>\n<p><a href=\"http://www.jianshu.com/p/6494e33c9b1f\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/6494e33c9b1f</a><br>1).充分利用page cache降低读数据的时间开销. 读取时尽可能让其命中page cache, 减少IO读操作, 所以内存越大越好. 如果系统中堆积的消息过多, 读数据要访问磁盘会不会由于随机读导致系统性能急剧下降, 答案是否定的.<br>访问page cache 时, 即使只访问1k的消息, 系统也会提前预读出更多数据, 在下次读时, 就可能命中内存.<br>随机访问Commit Log磁盘数据, 系统IO调度算法设置为NOOP方式, 会在一定程度上将完全的随机读变成顺序跳跃方式, 而顺序跳跃方式读较完全的随机读性能会高5倍以上.<br>另外4k的消息在完全随机访问情况下, 仍然可以达到8K次每秒以上的读性能.<br>由于Consume Queue存储数据量极少, 而且是顺序读, 在PAGECACHE预读作用下, Consume Queue的读性能几乎与内存一致, 即使堆积情况下. 所以可认为Consume Queue完全不会阻碍读性能.<br>2).Commit Log中存储了所有的元信息, 包含消息体, 类似于Mysql、Oracle的redolog, 所以只要有Commit Log在, Consume Queue即使数据丢失, 仍然可以恢复出来.</p>\n<p><a href=\"https://segmentfault.com/a/1190000003985468\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000003985468</a><br>kafka底层原理</p>\n<p>linux最多可以容忍多少大小的脏页。脏页－linux内核中的概念，因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，以提高读写速度，这就叫高速缓存，linux是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>page cache是内存的东西（物理内存还是虚拟内存），我们写文件时先写进内存page cache，然后从page cache刷到disc上</p>\n<p>现在MQ异步刷盘是有个间隔的，如果说pagecache中的数据一直没有被刷进磁盘，那所谓的脏页会越来越大，jvm crash后会丢失数据么。那什么时候是不会丢消息的</p>\n<p>对于读是好理解的，但对于写，如果文件是顺序写的，commit log和consume queue都是顺序写的，那pagecache的存在如何让速度提升了？是从java heap到pagecache的速度提升了，还是说从pagecache到disc的速度提升了？</p>\n<p>producer发送消息，如果是立马被消费这种场景<br>1.对于consume queue，肯定是顺序读写，所以写进pagecache（物理内存）后，直接就从pagecache（物理内存）被读出来了<br>2.对于commit log，虽然不是顺序读，但也是基本有序读，最后大部分也能命中pagecache，不需要走系统IO</p>\n<p>如果是消费历史消息，很大程度上，会发现在pagecache（虚拟内存）中没有，由系统产生缺页中断，从磁盘中重新读到pagecache中（可能还会根据顺序预读很多），然后再将数据从pagecache复制到socket中传输到consumer。</p>\n<p>MappedByteBuffer 能不能映射大于操作系统内存的文件？<br>MappedByteBuffer所占用的内存是堆外内存，那什么时候才能被回收</p>\n<p><a href=\"http://www.iocoder.cn/RocketMQ/message-store/\" target=\"_blank\" rel=\"external\">http://www.iocoder.cn/RocketMQ/message-store/</a><br>CommitRealTimeService    异步刷盘 &amp;&amp; 开启内存字节缓冲区    第一<br>FlushRealTimeService    异步刷盘 &amp;&amp; 关闭内存字节缓冲区    第二<br>GroupCommitService    同步刷盘    第三<br>没看懂</p>\n<p><a href=\"http://blog.csdn.net/iie_libi/article/details/54289580\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/iie_libi/article/details/54289580</a><br>零拷贝技术</p>\n<p>Consumer 消费消息过程，使用了零拷贝技术，因为有小块数据传输的需求，效果会比 sendfile 更好，所以RocketMQ选择了mmap+write方式。<br>① 优点：即使频繁调用，使用小块文件传输，效率也很高<br>② 缺点：不能很好的利用 DMA 方式，会比 sendfile 多消耗CPU，内存安全性控制复杂，需要避免JVM Crash问题。</p>\n<p>文件系统</p>\n<p>建议选择ext4文件系统，删除文件的实时性强。<br>调优：文件系统的io调度算法需要调整为deadline，因为deadline 算法在随机读情况下，可以合并读请求为顺序跳跃方式，从而提高读IO 吞吐量。</p>\n<p>文件读写冲突？</p>\n<p>写文件的时候，如果消费者在读怎么办？<br>依赖于操作系统对文件读写操作的处理，，，永远一个一个进程在写文件，如果其他进程需要访问文件，只能是读，或者是再创建一个副本，写文件。（读写锁+写时复制） 读写锁在哪里</p>\n<p>提高pagecache？</p>\n<p>RocketMQ用的是FileChannel.map()出来的MappedByteBuffer，这种Buffer是堆外内存，MQ怎么对这部分的内存进行回收？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clean</span><span class=\"params\">(<span class=\"keyword\">final</span> ByteBuffer buffer)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (buffer == <span class=\"keyword\">null</span> || !buffer.isDirect() || buffer.capacity() == <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    invoke(invoke(viewed(buffer), <span class=\"string\">\"cleaner\"</span>), <span class=\"string\">\"clean\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Deallocator</span></span></div><div class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Unsafe unsafe = Unsafe.getUnsafe();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> address;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> size;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Deallocator</span><span class=\"params\">(<span class=\"keyword\">long</span> address, <span class=\"keyword\">long</span> size, <span class=\"keyword\">int</span> capacity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">assert</span> (address != <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">this</span>.address = address;</div><div class=\"line\">        <span class=\"keyword\">this</span>.size = size;</div><div class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (address == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// Paranoia</span></div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        unsafe.freeMemory(address);</div><div class=\"line\">        address = <span class=\"number\">0</span>;</div><div class=\"line\">        Bits.unreserveMemory(size, capacity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>堆外内存的回收需要依赖显式Full GC或者隐式Full GC，一般来说DisableExplicitGC可以开，也可以关，但是如果禁用了显式GC，当系统没有足够的Full GC时，堆外内存无法回收。</p>\n<p>  想要提高pagecache的命中率，即尽量让访问的页在物理内存中，而不是在虚拟内存中，减少IO 读操作，所以从硬件的角度，当然是内存越大越好。<br>而在软件角度，rocketmq有以下策略：<br>尽量顺序读<br> 如果需要随机读的话：<br>访问 PAGECACHE 时，即使只访问 1k 的消息，系统也会提前预读出更多数据，在下次读时，就可能命中内存。<br> 随机访问 Commit Log 磁盘数据，系统 IO 调度算法设置为NOOP 方式，会在一定程度上将完全的随机读变成顺序跳跃方式，而顺序跳跃方式读较完全的随机读性能会高5 倍以上。</p>\n<p> 可能的优化策略</p>\n<p> 1．线程绑定核+线程池（取模）<br> a) 将每个线程绑定核，一个函数就可以<br> b) 优势：避免线程核间调度<br> 2．改用互斥锁为读写锁<br> a) 读读场景的线程可以并行<br> 3．使用xxhash代替crc算法，性能可以提高很多<br> a) 参考链接：<a href=\"https://cyan4973.github.io/xxHash/\" target=\"_blank\" rel=\"external\">https://cyan4973.github.io/xxHash/</a><br> 4．使用topic划分多个逻辑队列（链表）<br> a) 避免topic的多次字符串的比较<br> 5．改用STL的deque来替代MESA list<br> a) Deque类似于vector，可以支持随机访问<br> b) 常量时间内在头部和尾部插入，删除元素<br> 6．改用跳表来代替MESA list<br> a) 跳表可以高并发+log（n）的随机访问<br> b) 不能删除元素<br> i. 设为标志位，当内存数据达到一定阈值时，写到磁盘或者持久化到leveldb中（hbase也是这样做的）。</p>\n<p> <em>java.nio.channels.FileChannel</em><br> <code>public abstract void force(boolean metaData) throws java.io.IOException</code><br> Forces any updates to this channel’s file to be written to the storage device that contains it.<br> If this channel’s file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash.<br> If the file does not reside on a local device then no such guarantee is made.<br> The metaData parameter can be used to limit the number of I/O operations that this method is required to perform. Passing false for this parameter indicates that only updates to the file’s content need be written to storage; passing true indicates that updates to both the file’s content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified.<br> Invoking this method may cause an I/O operation to occur even if the channel was only opened for reading. Some operating systems, for example, maintain a last-access time as part of a file’s metadata, and this time is updated whenever the file is read. Whether or not this is actually done is system-dependent and is therefore unspecified.<br> This method is only guaranteed to force changes that were made to this channel’s file via the methods defined in this class. <strong>It may or may not force changes that were made by modifying the content of a mapped byte buffer obtained by invoking the map method. Invoking the force method of the mapped byte buffer will force changes made to the buffer’s content to be written.</strong></p>\n<p> <em>java.nio.MappedByteBuffer</em><br> <code>public final MappedByteBuffer force()</code><br> Forces any changes made to this buffer’s content to be written to the storage device containing the mapped file.<br> If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.<br> If the file does not reside on a local device then no such guarantee is made.<br> If this buffer was not mapped in read/write mode (java.nio.channels.FileChannel.MapMode.READ_WRITE) then invoking this method has no effect.</p>\n<h3 id=\"写得超级好的一篇文章\"><a href=\"#写得超级好的一篇文章\" class=\"headerlink\" title=\"写得超级好的一篇文章\"></a>写得超级好的一篇文章</h3><p> <a href=\"http://blog.csdn.net/a417930422/article/details/52585862\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/a417930422/article/details/52585862</a></p>\n<p>包括下面的问题：</p>\n<p>wangbin00162017-08-08 17:011楼<br>楼主确定 零拷贝-sendfile 对应到java中<br>为FileChannel.transferTo(long position, long count, WritableByteChannel target)//？？</p>\n<p>rocketmq 文档上面写到 RocketMQ选择了第一种方式，mmap+write方式，因为有小块数据传输的需求，效果会比sendfile更好。</p>\n<p>源码里面使用的是netty的FileRegion 用的是FileChannel.transferTo</p>\n<p>FileRegion fileRegion =<br>new ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);<br>channel.writeAndFlush(fileRegion)<br>            回复  2条回复<br>             a417930422<br>            a4179304222017-09-21 10:35<br>            回复wangbin0016：另外，rocketmq主要使用的是mmap，即java的MappedByteBuffer用于快速读写。<br>             a417930422<br>            a4179304222017-09-21 10:32<br>            回复wangbin0016：rocketmq文档中写的是Consumer 消费消息过程使用了mmap+write，即内存映射文件的方式，请参照我写的rocketmq存储相关文章：<a href=\"http://blog.csdn.net/a417930422/article/details/52585180\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/a417930422/article/details/52585180</a>.<br>            你说的netty的FileRegion其实是被rocketmq重新实现的ManyMessageTransfer，而transfer过程其实是将GetMessageResult对象的数据写到netty的channel中，本质是从内核获取数据直接发送至socket，不会复制到用户空间。<br>            GetMessageResult其实是mmap的一个子缓冲区而已。<br>            有兴趣可以看看源码 com.alibaba.rocketmq.store.DefaultMessageStore.getMessage方法</p>\n<p>为何要懂零拷贝原理？因为rocketmq存储核心使用的就是零拷贝原理。</p>\n<ol>\n<li><p>io读写的方式</p>\n<ol>\n<li>中断</li>\n<li>DMA</li>\n</ol>\n</li>\n<li>中断方式<ol>\n<li>中断方式的流程图如下：</li>\n</ol>\n</li>\n</ol>\n<pre><code>1. 用户进程发起数据读取请求\n2. 系统调度为该进程分配cpu\n3. cpu向io控制器(ide,scsi)发送io请求\n4. 用户进程等待io完成，让出cpu\n5. 系统调度cpu执行其他任务\n6. 数据写入至io控制器的缓冲寄存器\n7. 缓冲寄存器满了向cpu发出中断信号\n8. cpu读取数据至内存\n</code></pre><ol>\n<li>缺点：中断次数取决于缓冲寄存器的大小<ol>\n<li>DMA ： 直接内存存取</li>\n</ol>\n</li>\n<li>DMA方式的流程图如下：</li>\n</ol>\n<pre><code>1. 用户进程发起数据读取请求\n2. 系统调度为该进程分配cpu\n3. cpu向DMA发送io请求\n4. 用户进程等待io完成，让出cpu\n5. 系统调度cpu执行其他任务\n6. 数据写入至io控制器的缓冲寄存器\n7. DMA不断获取缓冲寄存器中的数据（需要cpu时钟）\n8. 传输至内存（需要cpu时钟）\n9. 所需的全部数据获取完毕后向cpu发出中断信号\n</code></pre><ol>\n<li>优点：减少cpu中断次数，不用cpu拷贝数据<ol>\n<li>数据拷贝</li>\n</ol>\n</li>\n<li>下面展示了 传统方式读取数据后并通过网络发送 所发生的数据拷贝：</li>\n</ol>\n<pre><code>1. 一个read系统调用后，DMA执行了一次数据拷贝，从磁盘到内核空间\n2. read结束后，发生第二次数据拷贝，由cpu将数据从内核空间拷贝至用户空间\n3. send系统调用，cpu发生第三次数据拷贝，由cpu将数据从用户空间拷贝至内核空间(socket缓冲区)\n4. send系统调用结束后，DMA执行第四次数据拷贝，将数据从内核拷贝至协议引擎\n5. 另外，这四个过程中，每个过程都发生一次上下文切换\n</code></pre><ol>\n<li>内存缓冲数据，主要是为了提高性能，内核可以预读部分数据，当所需数据小于内存缓冲区大小时，将极大的提高性能。</li>\n<li><p>零拷贝是为了消除这个过程中冗余的拷贝</p>\n<ol>\n<li>零拷贝-sendfile 对应到java中</li>\n</ol>\n<p>为FileChannel.transferTo(long position, long count, WritableByteChannel target)//<br>将数据从文件通道传输到了给定的可写字节通道</p>\n</li>\n<li>避免了第2，3步的数据拷贝，参考下图：</li>\n</ol>\n<pre><code>1. DMA从拷贝至内核缓冲区\n2. cpu将数据从内核缓冲区拷贝至内核空间(socket缓冲区)\n3. DMA将数据从内核拷贝至协议引擎\n4. 这三个过程中共发生2次上下文切换，分别为发起读取文件和发送数据\n</code></pre><ol>\n<li>以上过程发生了三次数据拷贝，其中有一次为cpu完成</li>\n<li>linux内核2.4以后，socket缓冲区做了调整，DMA带收集功能，如下图：</li>\n</ol>\n<pre><code>1. DMA从拷贝至内核缓冲区\n2. 将数据的位置和长度的信息的描述符增加至内核空间(socket缓冲区)\n3. DMA将数据从内核拷贝至协议引擎\n</code></pre><ol>\n<li><p>零拷贝-mmap 对应到java中</p>\n<p>为MappedByteBuffer//文件内存映射</p>\n<ol>\n<li>数据不会复制到用户空间，只在内核空间，与sendfile类似，但是应用程序可以直接操作该内存。</li>\n</ol>\n</li>\n<li>参考资料<ol>\n<li><a href=\"http://blog.chinaunix.net/uid-25314474-id-3325879.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-25314474-id-3325879.html</a></li>\n<li><a href=\"http://blog.chinaunix.net/uid-28874972-id-3725082.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-28874972-id-3725082.html</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-zerocopy/#fig1\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/java/j-zerocopy/#fig1</a></li>\n<li><a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/\" target=\"_blank\" rel=\"external\">http://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/</a></li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>producer发送消息，如果是立马被消费这种场景<br>1.对于consume queue，肯定是顺序读写，所以写进pagecache后，直接就从pagecache被读出来了<br>2.对于commit log，虽然不是顺序读，但也是基本有序读，最后大部分也能命中pagecache，不需要走系统IO</p>\n<p>如果是消费历史消息，很大程度上，会发现在pagecache中没有，由系统产生缺页中断，从磁盘中重新读到pagecache中（可能还会根据顺序预读很多），然后再将数据从pagecache复制到socket中传输到consumer。</p>\n<h3 id=\"异步刷盘有两种方式\"><a href=\"#异步刷盘有两种方式\" class=\"headerlink\" title=\"异步刷盘有两种方式\"></a>异步刷盘有两种方式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Synchronization flush</span></div><div class=\"line\"><span class=\"keyword\">if</span> (FlushDiskType.SYNC_FLUSH == <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> GroupCommitService service = (GroupCommitService) <span class=\"keyword\">this</span>.flushCommitLogService;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Asynchronous flush</span></div><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</div><div class=\"line\">        <span class=\"comment\">// FlushRealTimeService</span></div><div class=\"line\">        flushCommitLogService.wakeup();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// CommitRealTimeService</span></div><div class=\"line\">        commitLogService.wakeup();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTransientStorePoolEnable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> transientStorePoolEnable &amp;&amp; FlushDiskType.ASYNC_FLUSH == getFlushDiskType()</div><div class=\"line\">        &amp;&amp; BrokerRole.SLAVE != getBrokerRole();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>transientStorePoolEnable的具体含义是什么？<br>FlushRealTimeService和CommitRealTimeService刷盘的方式有什么区别，在性能有什么区别？</p>\n<p><img src=\"/2017/11/03/RocketMQ-Message-send-and-persistence/disc-fall.gif\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"逻辑Offset队列-ConsumerQueue\"><a href=\"#逻辑Offset队列-ConsumerQueue\" class=\"headerlink\" title=\"逻辑Offset队列: ConsumerQueue\"></a>逻辑Offset队列: ConsumerQueue</h3><h3 id=\"物理Offset队列-CommitLog\"><a href=\"#物理Offset队列-CommitLog\" class=\"headerlink\" title=\"物理Offset队列: CommitLog\"></a>物理Offset队列: CommitLog</h3><h3 id=\"MappedByteBuffer\"><a href=\"#MappedByteBuffer\" class=\"headerlink\" title=\"MappedByteBuffer\"></a>MappedByteBuffer</h3><p>操纵MappedByteBuffer的线程或者进程必须对某一个文件的映射Buffer有独占权，<br>在设计上，消息的顺序是由CommitLog决定，所以CommitLog在Append新的消息时，必须上锁进行互斥。</p>\n<p><em>传统的synchronized叫做monitor lock，当一个线程进入了synchronized的代码块时，我们说，该线程own（拥有）了monitor lock。这种锁是一种重量级锁，用mutual exclusive（互斥）的特性来实现了同步的需求。\n</em>自旋锁，JDK1.6引进，我们知道，线程状态与状态的切换，是需要内核参与的，简单点来讲，这个过程是需要点时间的。线程B已经own了一个锁，这是线程A去尝试获取锁，本来线程A应该要挂起，JVM不让它挂起，让A在那里做自旋操作，JVM要赌当前持有锁的B会很快释放锁。如果线程B确实很快释放了锁，那对于A来讲是一个非常好事情，因为A可以不用切换状态，立刻持有锁。那什么时候会用到呢？<a href=\"http://blog.csdn.net/u013080921/article/details/42676231\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u013080921/article/details/42676231</a></p>\n<h4 id=\"Spin-Lock-自旋锁\"><a href=\"#Spin-Lock-自旋锁\" class=\"headerlink\" title=\"Spin Lock(自旋锁)\"></a>Spin Lock(自旋锁)</h4><h4 id=\"ReentrantLock-重入锁\"><a href=\"#ReentrantLock-重入锁\" class=\"headerlink\" title=\"ReentrantLock(重入锁)\"></a>ReentrantLock(重入锁)</h4><h3 id=\"异步刷盘机制\"><a href=\"#异步刷盘机制\" class=\"headerlink\" title=\"异步刷盘机制\"></a>异步刷盘机制</h3><p><a href=\"http://blog.csdn.net/vonzhoufz/article/details/47248777\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/vonzhoufz/article/details/47248777</a></p>\n<h4 id=\"磁盘顺序读写与随机读写的差异\"><a href=\"#磁盘顺序读写与随机读写的差异\" class=\"headerlink\" title=\"磁盘顺序读写与随机读写的差异\"></a>磁盘顺序读写与随机读写的差异</h4><p><a href=\"https://kafka.apache.org/documentation/#design_filesystem\" target=\"_blank\" rel=\"external\">https://kafka.apache.org/documentation/#design_filesystem</a></p>\n<p><a href=\"http://blog.csdn.net/evankaka/article/details/48464013\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/evankaka/article/details/48464013</a></p>\n<p>需要好好研究：<a href=\"http://blog.csdn.net/javahongxi/article/details/72956619?locationNum=2&amp;fps=1\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/javahongxi/article/details/72956619?locationNum=2&amp;fps=1</a><br>虽然讲的是kafka，研究价值极高：<a href=\"http://blog.csdn.net/tototuzuoquan/article/details/73437890\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/tototuzuoquan/article/details/73437890</a><br>pagecache是一个现在操作系统带有的天然的缓存！！！！！</p>\n<p><a href=\"http://blog.csdn.net/mg0832058/article/details/5890688\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/mg0832058/article/details/5890688</a><br>内存映射文件原理探索</p>\n<p>如何查看内存的 PAGESIZE<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">getconf PAGESIZE</div></pre></td></tr></table></figure></p>\n<p>终于理解了！！！！ 首先，Kafka重度依赖底层操作系统提供的PageCache功能。当上层有写操作时，操作系统只是将数据写入PageCache，同时标记Page属性为Dirty。当读操作发生时，先从PageCache中查找，如果发生缺页才进行磁盘调度，最终返回需要的数据。实际上PageCache是把尽可能多的空闲内存都当做了磁盘缓存来使用。同时如果有其他进程申请内存，回收PageCache的代价又很小，所以现代的OS都支持PageCache。 </p>\n<p>所以说 commit(atLeastSize)的参数就是现代操作系统pagecache的大小。</p>\n<p><a href=\"http://www.jianshu.com/p/6494e33c9b1f\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/6494e33c9b1f</a><br>Consume Queue 顺序写，顺序读 几乎都是完全命中Page Cache，和内存速度几乎一样<br>Commit Log 顺序写，顺序跳跃读，相比完全的随机读，性能也还好</p>\n<p><a href=\"http://blog.csdn.net/mg0832058/article/details/5890688\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/mg0832058/article/details/5890688</a><br>内存映射文件原理探索</p>\n<p><a href=\"http://www.jianshu.com/p/6494e33c9b1f\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/6494e33c9b1f</a><br>1).充分利用page cache降低读数据的时间开销. 读取时尽可能让其命中page cache, 减少IO读操作, 所以内存越大越好. 如果系统中堆积的消息过多, 读数据要访问磁盘会不会由于随机读导致系统性能急剧下降, 答案是否定的.<br>访问page cache 时, 即使只访问1k的消息, 系统也会提前预读出更多数据, 在下次读时, 就可能命中内存.<br>随机访问Commit Log磁盘数据, 系统IO调度算法设置为NOOP方式, 会在一定程度上将完全的随机读变成顺序跳跃方式, 而顺序跳跃方式读较完全的随机读性能会高5倍以上.<br>另外4k的消息在完全随机访问情况下, 仍然可以达到8K次每秒以上的读性能.<br>由于Consume Queue存储数据量极少, 而且是顺序读, 在PAGECACHE预读作用下, Consume Queue的读性能几乎与内存一致, 即使堆积情况下. 所以可认为Consume Queue完全不会阻碍读性能.<br>2).Commit Log中存储了所有的元信息, 包含消息体, 类似于Mysql、Oracle的redolog, 所以只要有Commit Log在, Consume Queue即使数据丢失, 仍然可以恢复出来.</p>\n<p><a href=\"https://segmentfault.com/a/1190000003985468\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000003985468</a><br>kafka底层原理</p>\n<p>linux最多可以容忍多少大小的脏页。脏页－linux内核中的概念，因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，以提高读写速度，这就叫高速缓存，linux是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>page cache是内存的东西（物理内存还是虚拟内存），我们写文件时先写进内存page cache，然后从page cache刷到disc上</p>\n<p>现在MQ异步刷盘是有个间隔的，如果说pagecache中的数据一直没有被刷进磁盘，那所谓的脏页会越来越大，jvm crash后会丢失数据么。那什么时候是不会丢消息的</p>\n<p>对于读是好理解的，但对于写，如果文件是顺序写的，commit log和consume queue都是顺序写的，那pagecache的存在如何让速度提升了？是从java heap到pagecache的速度提升了，还是说从pagecache到disc的速度提升了？</p>\n<p>producer发送消息，如果是立马被消费这种场景<br>1.对于consume queue，肯定是顺序读写，所以写进pagecache（物理内存）后，直接就从pagecache（物理内存）被读出来了<br>2.对于commit log，虽然不是顺序读，但也是基本有序读，最后大部分也能命中pagecache，不需要走系统IO</p>\n<p>如果是消费历史消息，很大程度上，会发现在pagecache（虚拟内存）中没有，由系统产生缺页中断，从磁盘中重新读到pagecache中（可能还会根据顺序预读很多），然后再将数据从pagecache复制到socket中传输到consumer。</p>\n<p>MappedByteBuffer 能不能映射大于操作系统内存的文件？<br>MappedByteBuffer所占用的内存是堆外内存，那什么时候才能被回收</p>\n<p><a href=\"http://www.iocoder.cn/RocketMQ/message-store/\" target=\"_blank\" rel=\"external\">http://www.iocoder.cn/RocketMQ/message-store/</a><br>CommitRealTimeService    异步刷盘 &amp;&amp; 开启内存字节缓冲区    第一<br>FlushRealTimeService    异步刷盘 &amp;&amp; 关闭内存字节缓冲区    第二<br>GroupCommitService    同步刷盘    第三<br>没看懂</p>\n<p><a href=\"http://blog.csdn.net/iie_libi/article/details/54289580\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/iie_libi/article/details/54289580</a><br>零拷贝技术</p>\n<p>Consumer 消费消息过程，使用了零拷贝技术，因为有小块数据传输的需求，效果会比 sendfile 更好，所以RocketMQ选择了mmap+write方式。<br>① 优点：即使频繁调用，使用小块文件传输，效率也很高<br>② 缺点：不能很好的利用 DMA 方式，会比 sendfile 多消耗CPU，内存安全性控制复杂，需要避免JVM Crash问题。</p>\n<p>文件系统</p>\n<p>建议选择ext4文件系统，删除文件的实时性强。<br>调优：文件系统的io调度算法需要调整为deadline，因为deadline 算法在随机读情况下，可以合并读请求为顺序跳跃方式，从而提高读IO 吞吐量。</p>\n<p>文件读写冲突？</p>\n<p>写文件的时候，如果消费者在读怎么办？<br>依赖于操作系统对文件读写操作的处理，，，永远一个一个进程在写文件，如果其他进程需要访问文件，只能是读，或者是再创建一个副本，写文件。（读写锁+写时复制） 读写锁在哪里</p>\n<p>提高pagecache？</p>\n<p>RocketMQ用的是FileChannel.map()出来的MappedByteBuffer，这种Buffer是堆外内存，MQ怎么对这部分的内存进行回收？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clean</span><span class=\"params\">(<span class=\"keyword\">final</span> ByteBuffer buffer)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (buffer == <span class=\"keyword\">null</span> || !buffer.isDirect() || buffer.capacity() == <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    invoke(invoke(viewed(buffer), <span class=\"string\">\"cleaner\"</span>), <span class=\"string\">\"clean\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Deallocator</span></span></div><div class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Unsafe unsafe = Unsafe.getUnsafe();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> address;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> size;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Deallocator</span><span class=\"params\">(<span class=\"keyword\">long</span> address, <span class=\"keyword\">long</span> size, <span class=\"keyword\">int</span> capacity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">assert</span> (address != <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">this</span>.address = address;</div><div class=\"line\">        <span class=\"keyword\">this</span>.size = size;</div><div class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (address == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// Paranoia</span></div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        unsafe.freeMemory(address);</div><div class=\"line\">        address = <span class=\"number\">0</span>;</div><div class=\"line\">        Bits.unreserveMemory(size, capacity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>堆外内存的回收需要依赖显式Full GC或者隐式Full GC，一般来说DisableExplicitGC可以开，也可以关，但是如果禁用了显式GC，当系统没有足够的Full GC时，堆外内存无法回收。</p>\n<p>  想要提高pagecache的命中率，即尽量让访问的页在物理内存中，而不是在虚拟内存中，减少IO 读操作，所以从硬件的角度，当然是内存越大越好。<br>而在软件角度，rocketmq有以下策略：<br>尽量顺序读<br> 如果需要随机读的话：<br>访问 PAGECACHE 时，即使只访问 1k 的消息，系统也会提前预读出更多数据，在下次读时，就可能命中内存。<br> 随机访问 Commit Log 磁盘数据，系统 IO 调度算法设置为NOOP 方式，会在一定程度上将完全的随机读变成顺序跳跃方式，而顺序跳跃方式读较完全的随机读性能会高5 倍以上。</p>\n<p> 可能的优化策略</p>\n<p> 1．线程绑定核+线程池（取模）<br> a) 将每个线程绑定核，一个函数就可以<br> b) 优势：避免线程核间调度<br> 2．改用互斥锁为读写锁<br> a) 读读场景的线程可以并行<br> 3．使用xxhash代替crc算法，性能可以提高很多<br> a) 参考链接：<a href=\"https://cyan4973.github.io/xxHash/\" target=\"_blank\" rel=\"external\">https://cyan4973.github.io/xxHash/</a><br> 4．使用topic划分多个逻辑队列（链表）<br> a) 避免topic的多次字符串的比较<br> 5．改用STL的deque来替代MESA list<br> a) Deque类似于vector，可以支持随机访问<br> b) 常量时间内在头部和尾部插入，删除元素<br> 6．改用跳表来代替MESA list<br> a) 跳表可以高并发+log（n）的随机访问<br> b) 不能删除元素<br> i. 设为标志位，当内存数据达到一定阈值时，写到磁盘或者持久化到leveldb中（hbase也是这样做的）。</p>\n<p> <em>java.nio.channels.FileChannel</em><br> <code>public abstract void force(boolean metaData) throws java.io.IOException</code><br> Forces any updates to this channel’s file to be written to the storage device that contains it.<br> If this channel’s file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash.<br> If the file does not reside on a local device then no such guarantee is made.<br> The metaData parameter can be used to limit the number of I/O operations that this method is required to perform. Passing false for this parameter indicates that only updates to the file’s content need be written to storage; passing true indicates that updates to both the file’s content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified.<br> Invoking this method may cause an I/O operation to occur even if the channel was only opened for reading. Some operating systems, for example, maintain a last-access time as part of a file’s metadata, and this time is updated whenever the file is read. Whether or not this is actually done is system-dependent and is therefore unspecified.<br> This method is only guaranteed to force changes that were made to this channel’s file via the methods defined in this class. <strong>It may or may not force changes that were made by modifying the content of a mapped byte buffer obtained by invoking the map method. Invoking the force method of the mapped byte buffer will force changes made to the buffer’s content to be written.</strong></p>\n<p> <em>java.nio.MappedByteBuffer</em><br> <code>public final MappedByteBuffer force()</code><br> Forces any changes made to this buffer’s content to be written to the storage device containing the mapped file.<br> If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.<br> If the file does not reside on a local device then no such guarantee is made.<br> If this buffer was not mapped in read/write mode (java.nio.channels.FileChannel.MapMode.READ_WRITE) then invoking this method has no effect.</p>\n<h3 id=\"写得超级好的一篇文章\"><a href=\"#写得超级好的一篇文章\" class=\"headerlink\" title=\"写得超级好的一篇文章\"></a>写得超级好的一篇文章</h3><p> <a href=\"http://blog.csdn.net/a417930422/article/details/52585862\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/a417930422/article/details/52585862</a></p>\n<p>包括下面的问题：</p>\n<p>wangbin00162017-08-08 17:011楼<br>楼主确定 零拷贝-sendfile 对应到java中<br>为FileChannel.transferTo(long position, long count, WritableByteChannel target)//？？</p>\n<p>rocketmq 文档上面写到 RocketMQ选择了第一种方式，mmap+write方式，因为有小块数据传输的需求，效果会比sendfile更好。</p>\n<p>源码里面使用的是netty的FileRegion 用的是FileChannel.transferTo</p>\n<p>FileRegion fileRegion =<br>new ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);<br>channel.writeAndFlush(fileRegion)<br>            回复  2条回复<br>             a417930422<br>            a4179304222017-09-21 10:35<br>            回复wangbin0016：另外，rocketmq主要使用的是mmap，即java的MappedByteBuffer用于快速读写。<br>             a417930422<br>            a4179304222017-09-21 10:32<br>            回复wangbin0016：rocketmq文档中写的是Consumer 消费消息过程使用了mmap+write，即内存映射文件的方式，请参照我写的rocketmq存储相关文章：<a href=\"http://blog.csdn.net/a417930422/article/details/52585180\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/a417930422/article/details/52585180</a>.<br>            你说的netty的FileRegion其实是被rocketmq重新实现的ManyMessageTransfer，而transfer过程其实是将GetMessageResult对象的数据写到netty的channel中，本质是从内核获取数据直接发送至socket，不会复制到用户空间。<br>            GetMessageResult其实是mmap的一个子缓冲区而已。<br>            有兴趣可以看看源码 com.alibaba.rocketmq.store.DefaultMessageStore.getMessage方法</p>\n<p>为何要懂零拷贝原理？因为rocketmq存储核心使用的就是零拷贝原理。</p>\n<ol>\n<li><p>io读写的方式</p>\n<ol>\n<li>中断</li>\n<li>DMA</li>\n</ol>\n</li>\n<li>中断方式<ol>\n<li>中断方式的流程图如下：</li>\n</ol>\n</li>\n</ol>\n<pre><code>1. 用户进程发起数据读取请求\n2. 系统调度为该进程分配cpu\n3. cpu向io控制器(ide,scsi)发送io请求\n4. 用户进程等待io完成，让出cpu\n5. 系统调度cpu执行其他任务\n6. 数据写入至io控制器的缓冲寄存器\n7. 缓冲寄存器满了向cpu发出中断信号\n8. cpu读取数据至内存\n</code></pre><ol>\n<li>缺点：中断次数取决于缓冲寄存器的大小<ol>\n<li>DMA ： 直接内存存取</li>\n</ol>\n</li>\n<li>DMA方式的流程图如下：</li>\n</ol>\n<pre><code>1. 用户进程发起数据读取请求\n2. 系统调度为该进程分配cpu\n3. cpu向DMA发送io请求\n4. 用户进程等待io完成，让出cpu\n5. 系统调度cpu执行其他任务\n6. 数据写入至io控制器的缓冲寄存器\n7. DMA不断获取缓冲寄存器中的数据（需要cpu时钟）\n8. 传输至内存（需要cpu时钟）\n9. 所需的全部数据获取完毕后向cpu发出中断信号\n</code></pre><ol>\n<li>优点：减少cpu中断次数，不用cpu拷贝数据<ol>\n<li>数据拷贝</li>\n</ol>\n</li>\n<li>下面展示了 传统方式读取数据后并通过网络发送 所发生的数据拷贝：</li>\n</ol>\n<pre><code>1. 一个read系统调用后，DMA执行了一次数据拷贝，从磁盘到内核空间\n2. read结束后，发生第二次数据拷贝，由cpu将数据从内核空间拷贝至用户空间\n3. send系统调用，cpu发生第三次数据拷贝，由cpu将数据从用户空间拷贝至内核空间(socket缓冲区)\n4. send系统调用结束后，DMA执行第四次数据拷贝，将数据从内核拷贝至协议引擎\n5. 另外，这四个过程中，每个过程都发生一次上下文切换\n</code></pre><ol>\n<li>内存缓冲数据，主要是为了提高性能，内核可以预读部分数据，当所需数据小于内存缓冲区大小时，将极大的提高性能。</li>\n<li><p>零拷贝是为了消除这个过程中冗余的拷贝</p>\n<ol>\n<li>零拷贝-sendfile 对应到java中</li>\n</ol>\n<p>为FileChannel.transferTo(long position, long count, WritableByteChannel target)//<br>将数据从文件通道传输到了给定的可写字节通道</p>\n</li>\n<li>避免了第2，3步的数据拷贝，参考下图：</li>\n</ol>\n<pre><code>1. DMA从拷贝至内核缓冲区\n2. cpu将数据从内核缓冲区拷贝至内核空间(socket缓冲区)\n3. DMA将数据从内核拷贝至协议引擎\n4. 这三个过程中共发生2次上下文切换，分别为发起读取文件和发送数据\n</code></pre><ol>\n<li>以上过程发生了三次数据拷贝，其中有一次为cpu完成</li>\n<li>linux内核2.4以后，socket缓冲区做了调整，DMA带收集功能，如下图：</li>\n</ol>\n<pre><code>1. DMA从拷贝至内核缓冲区\n2. 将数据的位置和长度的信息的描述符增加至内核空间(socket缓冲区)\n3. DMA将数据从内核拷贝至协议引擎\n</code></pre><ol>\n<li><p>零拷贝-mmap 对应到java中</p>\n<p>为MappedByteBuffer//文件内存映射</p>\n<ol>\n<li>数据不会复制到用户空间，只在内核空间，与sendfile类似，但是应用程序可以直接操作该内存。</li>\n</ol>\n</li>\n<li>参考资料<ol>\n<li><a href=\"http://blog.chinaunix.net/uid-25314474-id-3325879.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-25314474-id-3325879.html</a></li>\n<li><a href=\"http://blog.chinaunix.net/uid-28874972-id-3725082.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-28874972-id-3725082.html</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-zerocopy/#fig1\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/java/j-zerocopy/#fig1</a></li>\n<li><a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/\" target=\"_blank\" rel=\"external\">http://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/</a></li>\n</ol>\n</li>\n</ol>\n"},{"title":"RocketMQ——高性能PullRequest秘籍之长轮询(长轮询)原理分析","date":"2017-09-20T08:58:52.000Z","_content":"\n\n分成两部分，Client和Broker\n\n### Client: \n\n### Broker:\n首先PullMessageProcessor用相应的线程池调用processRequest，去ConsumerQueue中找消息，\n如果找到了，没有什么好说的，直接用Netty模块将数据写进相应的channel，客户端获取到了数据后进行并行消费；\n如果没有消息，那么将当前的pullRequest放入PullRequestHoldService的pullRequestTable进行suspend。\n``` java \ncase ResponseCode.PULL_NOT_FOUND:\n    if (brokerAllowSuspend && hasSuspendFlag) {\n        long pollingTimeMills = suspendTimeoutMillisLong;\n        if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) {\n            pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();\n        }\n\n        String topic = requestHeader.getTopic();\n        long offset = requestHeader.getQueueOffset();\n        int queueId = requestHeader.getQueueId();\n        PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,\n            this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);\n        this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);\n        // 此处将repsonse设置为null，remote-server将不会给对应的channel发送响应信息。那响应的信息何时发送，有两种情况：\n        // 1. PullRequestHoldService hold了足够的时间后\n        // 2. 有新的信息被发送至队列后\n        response = null;\n        break;\n    }\n```\n那么，消息刷入CommitLog后，怎么样让这个Hold住的PullRequest感知到消息的到来？\n答案是，DefaultMessageStore.ReputMessageService线程。\nReputMessageService开启时就进行了一个近实时的空循环(Busy Spin)，不释放CPU进行等待事件\n``` java\nwhile (!this.isStopped()) {\n    try {\n        Thread.sleep(1);\n        this.doReput();\n    } catch (Exception e) {\n        DefaultMessageStore.log.warn(this.getServiceName() + \" service has exception. \", e);\n    }\n}\n```\n检测CommitLog中的MaxOffset是否在变大，变大了说明有新的消息已经存进了CommitLog，紧接着构建一个dispatchRequest，再让DefaultMessageStore调用doDispatch(dispatchRequest)，\n该方法并没有开启新的线程，一个做了几件事情，\n第一，将新的消息刷入consumerQueue，最小2页，作用也非常明显，到时候要获取一个消息，consumerQueue可以用logicOffset定位到CommitLog的PhyicOffset，是一个无法或缺的索引，\n第二，将新的消息写入index file用于后续更加复杂的查询，\n第三，计算bitmap。当doDispatch顺利执行完后。\n\n重点来了，之后触发messageArrivingListener的arriving方法，让pullRequestHoldService调用notifyMessageArriving，\n开启新的线程再一次让PullMessageProcessor调用processRequest来处理原来的那个pullRequest，但此时由于consumerQueue已经构建好了，所以会正常获取到消息，正常用netty模块进行一个对client的应答。\n``` java\n// 用一个接近空轮询\nprivate void doReput() {\n    for (boolean doNext = true; this.isCommitLogAvailable() && doNext; ) {\n        ...\n        SelectMappedBufferResult result = DefaultMessageStore.this.commitLog.getData(reputFromOffset);\n        ...\n        this.reputFromOffset = result.getStartOffset();\n\n        for (int readSize = 0; readSize < result.getSize() && doNext; ) {\n            DispatchRequest dispatchRequest =\n                DefaultMessageStore.this.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), false, false);\n            int size = dispatchRequest.getMsgSize();\n            ...\n            if (size > 0) {\n                // dispatch到构建consumerQueue和index file的调度器中\n                DefaultMessageStore.this.doDispatch(dispatchRequest);\n                \n                if (BrokerRole.SLAVE != DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole()\n                    && DefaultMessageStore.this.brokerConfig.isLongPollingEnable()) {\n                    // 通知suspend pullRequest的PullRequestHoldService解除对pullRequest的hold\n                    DefaultMessageStore.this.messageArrivingListener.arriving(dispatchRequest.getTopic(),\n                        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + 1,\n                        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),\n                        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());\n                }\n\n            } \n            ...\n        }\n    }\n}\n```\n\n整个过程时序图\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1fkeelo8oxpj30za0g2adr.jpg)\n","source":"_posts/RocketMQ-Pull-message-with-long-polling.md","raw":"---\ntitle: RocketMQ——高性能PullRequest秘籍之长轮询(长轮询)原理分析\ndate: 2017-09-20 16:58:52\ntags: RocketMQ\n---\n\n\n分成两部分，Client和Broker\n\n### Client: \n\n### Broker:\n首先PullMessageProcessor用相应的线程池调用processRequest，去ConsumerQueue中找消息，\n如果找到了，没有什么好说的，直接用Netty模块将数据写进相应的channel，客户端获取到了数据后进行并行消费；\n如果没有消息，那么将当前的pullRequest放入PullRequestHoldService的pullRequestTable进行suspend。\n``` java \ncase ResponseCode.PULL_NOT_FOUND:\n    if (brokerAllowSuspend && hasSuspendFlag) {\n        long pollingTimeMills = suspendTimeoutMillisLong;\n        if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) {\n            pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();\n        }\n\n        String topic = requestHeader.getTopic();\n        long offset = requestHeader.getQueueOffset();\n        int queueId = requestHeader.getQueueId();\n        PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,\n            this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);\n        this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);\n        // 此处将repsonse设置为null，remote-server将不会给对应的channel发送响应信息。那响应的信息何时发送，有两种情况：\n        // 1. PullRequestHoldService hold了足够的时间后\n        // 2. 有新的信息被发送至队列后\n        response = null;\n        break;\n    }\n```\n那么，消息刷入CommitLog后，怎么样让这个Hold住的PullRequest感知到消息的到来？\n答案是，DefaultMessageStore.ReputMessageService线程。\nReputMessageService开启时就进行了一个近实时的空循环(Busy Spin)，不释放CPU进行等待事件\n``` java\nwhile (!this.isStopped()) {\n    try {\n        Thread.sleep(1);\n        this.doReput();\n    } catch (Exception e) {\n        DefaultMessageStore.log.warn(this.getServiceName() + \" service has exception. \", e);\n    }\n}\n```\n检测CommitLog中的MaxOffset是否在变大，变大了说明有新的消息已经存进了CommitLog，紧接着构建一个dispatchRequest，再让DefaultMessageStore调用doDispatch(dispatchRequest)，\n该方法并没有开启新的线程，一个做了几件事情，\n第一，将新的消息刷入consumerQueue，最小2页，作用也非常明显，到时候要获取一个消息，consumerQueue可以用logicOffset定位到CommitLog的PhyicOffset，是一个无法或缺的索引，\n第二，将新的消息写入index file用于后续更加复杂的查询，\n第三，计算bitmap。当doDispatch顺利执行完后。\n\n重点来了，之后触发messageArrivingListener的arriving方法，让pullRequestHoldService调用notifyMessageArriving，\n开启新的线程再一次让PullMessageProcessor调用processRequest来处理原来的那个pullRequest，但此时由于consumerQueue已经构建好了，所以会正常获取到消息，正常用netty模块进行一个对client的应答。\n``` java\n// 用一个接近空轮询\nprivate void doReput() {\n    for (boolean doNext = true; this.isCommitLogAvailable() && doNext; ) {\n        ...\n        SelectMappedBufferResult result = DefaultMessageStore.this.commitLog.getData(reputFromOffset);\n        ...\n        this.reputFromOffset = result.getStartOffset();\n\n        for (int readSize = 0; readSize < result.getSize() && doNext; ) {\n            DispatchRequest dispatchRequest =\n                DefaultMessageStore.this.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), false, false);\n            int size = dispatchRequest.getMsgSize();\n            ...\n            if (size > 0) {\n                // dispatch到构建consumerQueue和index file的调度器中\n                DefaultMessageStore.this.doDispatch(dispatchRequest);\n                \n                if (BrokerRole.SLAVE != DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole()\n                    && DefaultMessageStore.this.brokerConfig.isLongPollingEnable()) {\n                    // 通知suspend pullRequest的PullRequestHoldService解除对pullRequest的hold\n                    DefaultMessageStore.this.messageArrivingListener.arriving(dispatchRequest.getTopic(),\n                        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + 1,\n                        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),\n                        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());\n                }\n\n            } \n            ...\n        }\n    }\n}\n```\n\n整个过程时序图\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1fkeelo8oxpj30za0g2adr.jpg)\n","slug":"RocketMQ-Pull-message-with-long-polling","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszm002z3iq2i3szvgv4","content":"<p>分成两部分，Client和Broker</p>\n<h3 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client:\"></a>Client:</h3><h3 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker:\"></a>Broker:</h3><p>首先PullMessageProcessor用相应的线程池调用processRequest，去ConsumerQueue中找消息，<br>如果找到了，没有什么好说的，直接用Netty模块将数据写进相应的channel，客户端获取到了数据后进行并行消费；<br>如果没有消息，那么将当前的pullRequest放入PullRequestHoldService的pullRequestTable进行suspend。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">case</span> ResponseCode.PULL_NOT_FOUND:</div><div class=\"line\">    <span class=\"keyword\">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> pollingTimeMills = suspendTimeoutMillisLong;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</div><div class=\"line\">            pollingTimeMills = <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        String topic = requestHeader.getTopic();</div><div class=\"line\">        <span class=\"keyword\">long</span> offset = requestHeader.getQueueOffset();</div><div class=\"line\">        <span class=\"keyword\">int</span> queueId = requestHeader.getQueueId();</div><div class=\"line\">        PullRequest pullRequest = <span class=\"keyword\">new</span> PullRequest(request, channel, pollingTimeMills,</div><div class=\"line\">            <span class=\"keyword\">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</div><div class=\"line\">        <span class=\"keyword\">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</div><div class=\"line\">        <span class=\"comment\">// 此处将repsonse设置为null，remote-server将不会给对应的channel发送响应信息。那响应的信息何时发送，有两种情况：</span></div><div class=\"line\">        <span class=\"comment\">// 1. PullRequestHoldService hold了足够的时间后</span></div><div class=\"line\">        <span class=\"comment\">// 2. 有新的信息被发送至队列后</span></div><div class=\"line\">        response = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>那么，消息刷入CommitLog后，怎么样让这个Hold住的PullRequest感知到消息的到来？<br>答案是，DefaultMessageStore.ReputMessageService线程。<br>ReputMessageService开启时就进行了一个近实时的空循环(Busy Spin)，不释放CPU进行等待事件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        Thread.sleep(<span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"keyword\">this</span>.doReput();</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">        DefaultMessageStore.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>检测CommitLog中的MaxOffset是否在变大，变大了说明有新的消息已经存进了CommitLog，紧接着构建一个dispatchRequest，再让DefaultMessageStore调用doDispatch(dispatchRequest)，<br>该方法并没有开启新的线程，一个做了几件事情，<br>第一，将新的消息刷入consumerQueue，最小2页，作用也非常明显，到时候要获取一个消息，consumerQueue可以用logicOffset定位到CommitLog的PhyicOffset，是一个无法或缺的索引，<br>第二，将新的消息写入index file用于后续更加复杂的查询，<br>第三，计算bitmap。当doDispatch顺利执行完后。</p>\n<p>重点来了，之后触发messageArrivingListener的arriving方法，让pullRequestHoldService调用notifyMessageArriving，<br>开启新的线程再一次让PullMessageProcessor调用processRequest来处理原来的那个pullRequest，但此时由于consumerQueue已经构建好了，所以会正常获取到消息，正常用netty模块进行一个对client的应答。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 用一个接近空轮询</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReput</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">boolean</span> doNext = <span class=\"keyword\">true</span>; <span class=\"keyword\">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        SelectMappedBufferResult result = DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.getData(reputFromOffset);</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">this</span>.reputFromOffset = result.getStartOffset();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> readSize = <span class=\"number\">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</div><div class=\"line\">            DispatchRequest dispatchRequest =</div><div class=\"line\">                DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">            <span class=\"keyword\">int</span> size = dispatchRequest.getMsgSize();</div><div class=\"line\">            ...</div><div class=\"line\">            <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// dispatch到构建consumerQueue和index file的调度器中</span></div><div class=\"line\">                DefaultMessageStore.<span class=\"keyword\">this</span>.doDispatch(dispatchRequest);</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"keyword\">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getBrokerRole()</div><div class=\"line\">                    &amp;&amp; DefaultMessageStore.<span class=\"keyword\">this</span>.brokerConfig.isLongPollingEnable()) &#123;</div><div class=\"line\">                    <span class=\"comment\">// 通知suspend pullRequest的PullRequestHoldService解除对pullRequest的hold</span></div><div class=\"line\">                    DefaultMessageStore.<span class=\"keyword\">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</div><div class=\"line\">                        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class=\"number\">1</span>,</div><div class=\"line\">                        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</div><div class=\"line\">                        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125; </div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>整个过程时序图</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fkeelo8oxpj30za0g2adr.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>分成两部分，Client和Broker</p>\n<h3 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client:\"></a>Client:</h3><h3 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker:\"></a>Broker:</h3><p>首先PullMessageProcessor用相应的线程池调用processRequest，去ConsumerQueue中找消息，<br>如果找到了，没有什么好说的，直接用Netty模块将数据写进相应的channel，客户端获取到了数据后进行并行消费；<br>如果没有消息，那么将当前的pullRequest放入PullRequestHoldService的pullRequestTable进行suspend。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">case</span> ResponseCode.PULL_NOT_FOUND:</div><div class=\"line\">    <span class=\"keyword\">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> pollingTimeMills = suspendTimeoutMillisLong;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</div><div class=\"line\">            pollingTimeMills = <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        String topic = requestHeader.getTopic();</div><div class=\"line\">        <span class=\"keyword\">long</span> offset = requestHeader.getQueueOffset();</div><div class=\"line\">        <span class=\"keyword\">int</span> queueId = requestHeader.getQueueId();</div><div class=\"line\">        PullRequest pullRequest = <span class=\"keyword\">new</span> PullRequest(request, channel, pollingTimeMills,</div><div class=\"line\">            <span class=\"keyword\">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</div><div class=\"line\">        <span class=\"keyword\">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</div><div class=\"line\">        <span class=\"comment\">// 此处将repsonse设置为null，remote-server将不会给对应的channel发送响应信息。那响应的信息何时发送，有两种情况：</span></div><div class=\"line\">        <span class=\"comment\">// 1. PullRequestHoldService hold了足够的时间后</span></div><div class=\"line\">        <span class=\"comment\">// 2. 有新的信息被发送至队列后</span></div><div class=\"line\">        response = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>那么，消息刷入CommitLog后，怎么样让这个Hold住的PullRequest感知到消息的到来？<br>答案是，DefaultMessageStore.ReputMessageService线程。<br>ReputMessageService开启时就进行了一个近实时的空循环(Busy Spin)，不释放CPU进行等待事件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        Thread.sleep(<span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"keyword\">this</span>.doReput();</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">        DefaultMessageStore.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>检测CommitLog中的MaxOffset是否在变大，变大了说明有新的消息已经存进了CommitLog，紧接着构建一个dispatchRequest，再让DefaultMessageStore调用doDispatch(dispatchRequest)，<br>该方法并没有开启新的线程，一个做了几件事情，<br>第一，将新的消息刷入consumerQueue，最小2页，作用也非常明显，到时候要获取一个消息，consumerQueue可以用logicOffset定位到CommitLog的PhyicOffset，是一个无法或缺的索引，<br>第二，将新的消息写入index file用于后续更加复杂的查询，<br>第三，计算bitmap。当doDispatch顺利执行完后。</p>\n<p>重点来了，之后触发messageArrivingListener的arriving方法，让pullRequestHoldService调用notifyMessageArriving，<br>开启新的线程再一次让PullMessageProcessor调用processRequest来处理原来的那个pullRequest，但此时由于consumerQueue已经构建好了，所以会正常获取到消息，正常用netty模块进行一个对client的应答。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 用一个接近空轮询</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReput</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">boolean</span> doNext = <span class=\"keyword\">true</span>; <span class=\"keyword\">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        SelectMappedBufferResult result = DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.getData(reputFromOffset);</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">this</span>.reputFromOffset = result.getStartOffset();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> readSize = <span class=\"number\">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</div><div class=\"line\">            DispatchRequest dispatchRequest =</div><div class=\"line\">                DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">            <span class=\"keyword\">int</span> size = dispatchRequest.getMsgSize();</div><div class=\"line\">            ...</div><div class=\"line\">            <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// dispatch到构建consumerQueue和index file的调度器中</span></div><div class=\"line\">                DefaultMessageStore.<span class=\"keyword\">this</span>.doDispatch(dispatchRequest);</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"keyword\">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getBrokerRole()</div><div class=\"line\">                    &amp;&amp; DefaultMessageStore.<span class=\"keyword\">this</span>.brokerConfig.isLongPollingEnable()) &#123;</div><div class=\"line\">                    <span class=\"comment\">// 通知suspend pullRequest的PullRequestHoldService解除对pullRequest的hold</span></div><div class=\"line\">                    DefaultMessageStore.<span class=\"keyword\">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</div><div class=\"line\">                        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class=\"number\">1</span>,</div><div class=\"line\">                        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</div><div class=\"line\">                        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125; </div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>整个过程时序图</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fkeelo8oxpj30za0g2adr.jpg\" alt=\"\"></p>\n"},{"title":"RocketMQ——远程通讯协议及其序列化","date":"2017-11-10T10:41:47.000Z","_content":"\n\n### 通信协议\n\nLengthFieldBasedFrameDecoder\n\n### 通信Request, Response序列化\n\njson，好像新版可以支持Protobuf\n\n\nhttps://zhuanlan.zhihu.com/rocketmq","source":"_posts/RocketMQ-Remote-communication-protocol-and-serialization.md","raw":"---\ntitle: RocketMQ——远程通讯协议及其序列化\ndate: 2017-11-10 18:41:47\ntags: RocketMQ\n---\n\n\n### 通信协议\n\nLengthFieldBasedFrameDecoder\n\n### 通信Request, Response序列化\n\njson，好像新版可以支持Protobuf\n\n\nhttps://zhuanlan.zhihu.com/rocketmq","slug":"RocketMQ-Remote-communication-protocol-and-serialization","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszo00323iq2s7omtwei","content":"<h3 id=\"通信协议\"><a href=\"#通信协议\" class=\"headerlink\" title=\"通信协议\"></a>通信协议</h3><p>LengthFieldBasedFrameDecoder</p>\n<h3 id=\"通信Request-Response序列化\"><a href=\"#通信Request-Response序列化\" class=\"headerlink\" title=\"通信Request, Response序列化\"></a>通信Request, Response序列化</h3><p>json，好像新版可以支持Protobuf</p>\n<p><a href=\"https://zhuanlan.zhihu.com/rocketmq\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/rocketmq</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"通信协议\"><a href=\"#通信协议\" class=\"headerlink\" title=\"通信协议\"></a>通信协议</h3><p>LengthFieldBasedFrameDecoder</p>\n<h3 id=\"通信Request-Response序列化\"><a href=\"#通信Request-Response序列化\" class=\"headerlink\" title=\"通信Request, Response序列化\"></a>通信Request, Response序列化</h3><p>json，好像新版可以支持Protobuf</p>\n<p><a href=\"https://zhuanlan.zhihu.com/rocketmq\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/rocketmq</a></p>\n"},{"title":"Serialization-Hessian","date":"2017-12-05T02:35:33.000Z","_content":"\nhttp://www.jianshu.com/p/e800d8af4e22\n\nhttp://hessian.caucho.com/doc/hessian-serialization.html","source":"_posts/Serialization-Hessian.md","raw":"---\ntitle: Serialization-Hessian\ndate: 2017-12-05 10:35:33\ntags: 序列化\n---\n\nhttp://www.jianshu.com/p/e800d8af4e22\n\nhttp://hessian.caucho.com/doc/hessian-serialization.html","slug":"Serialization-Hessian","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszp00333iq2rvy6nca8","content":"<p><a href=\"http://www.jianshu.com/p/e800d8af4e22\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/e800d8af4e22</a></p>\n<p><a href=\"http://hessian.caucho.com/doc/hessian-serialization.html\" target=\"_blank\" rel=\"external\">http://hessian.caucho.com/doc/hessian-serialization.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.jianshu.com/p/e800d8af4e22\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/e800d8af4e22</a></p>\n<p><a href=\"http://hessian.caucho.com/doc/hessian-serialization.html\" target=\"_blank\" rel=\"external\">http://hessian.caucho.com/doc/hessian-serialization.html</a></p>\n"},{"title":"RocketMQ——事务消息原理分析","date":"2017-10-11T08:27:43.000Z","_content":"\n\nhttps://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7\n\n![你想输入的替代文字](RocketMQ-Transactional-message/transaction_rocketmq.gif)\n\n### 问题\n\nproducer发送half msg时，broker如果当它是一条普通的消息，那consumer会立刻在long pooling中收到，但实现是不会收到的，是在哪一个环节设置的。\n事务消息，提交（COMMIT）后才生成 ConsumeQueue\n``` java\nclass CommitLogDispatcherBuildConsumeQueue implements CommitLogDispatcher {\n\n    @Override\n    public void dispatch(DispatchRequest request) {\n        final int tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());\n        switch (tranType) {\n            case MessageSysFlag.TRANSACTION_NOT_TYPE:\n            // 虽然所有的状态都会存储到commit log中，只有 TRANSACTION_COMMIT_TYPE 状态才会构建consume queue\n            // 也就是说让consumer进行消费\n            case MessageSysFlag.TRANSACTION_COMMIT_TYPE:\n                DefaultMessageStore.this.putMessagePositionInfo(request);\n                break;\n            case MessageSysFlag.TRANSACTION_PREPARED_TYPE:\n            case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:\n                break;\n        }\n    }\n}\n```","source":"_posts/RocketMQ-Transactional-message.md","raw":"---\ntitle: RocketMQ——事务消息原理分析\ndate: 2017-10-11 16:27:43\ntags: RocketMQ\n---\n\n\nhttps://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7\n\n![你想输入的替代文字](RocketMQ-Transactional-message/transaction_rocketmq.gif)\n\n### 问题\n\nproducer发送half msg时，broker如果当它是一条普通的消息，那consumer会立刻在long pooling中收到，但实现是不会收到的，是在哪一个环节设置的。\n事务消息，提交（COMMIT）后才生成 ConsumeQueue\n``` java\nclass CommitLogDispatcherBuildConsumeQueue implements CommitLogDispatcher {\n\n    @Override\n    public void dispatch(DispatchRequest request) {\n        final int tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());\n        switch (tranType) {\n            case MessageSysFlag.TRANSACTION_NOT_TYPE:\n            // 虽然所有的状态都会存储到commit log中，只有 TRANSACTION_COMMIT_TYPE 状态才会构建consume queue\n            // 也就是说让consumer进行消费\n            case MessageSysFlag.TRANSACTION_COMMIT_TYPE:\n                DefaultMessageStore.this.putMessagePositionInfo(request);\n                break;\n            case MessageSysFlag.TRANSACTION_PREPARED_TYPE:\n            case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:\n                break;\n        }\n    }\n}\n```","slug":"RocketMQ-Transactional-message","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszq00363iq287wvfb7q","content":"<p><a href=\"https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7\" target=\"_blank\" rel=\"external\">https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7</a></p>\n<p><img src=\"/2017/10/11/RocketMQ-Transactional-message/transaction_rocketmq.gif\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>producer发送half msg时，broker如果当它是一条普通的消息，那consumer会立刻在long pooling中收到，但实现是不会收到的，是在哪一个环节设置的。<br>事务消息，提交（COMMIT）后才生成 ConsumeQueue<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommitLogDispatcherBuildConsumeQueue</span> <span class=\"keyword\">implements</span> <span class=\"title\">CommitLogDispatcher</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(DispatchRequest request)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</div><div class=\"line\">        <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class=\"line\">            <span class=\"comment\">// 虽然所有的状态都会存储到commit log中，只有 TRANSACTION_COMMIT_TYPE 状态才会构建consume queue</span></div><div class=\"line\">            <span class=\"comment\">// 也就是说让consumer进行消费</span></div><div class=\"line\">            <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class=\"line\">                DefaultMessageStore.<span class=\"keyword\">this</span>.putMessagePositionInfo(request);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class=\"line\">            <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7\" target=\"_blank\" rel=\"external\">https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7</a></p>\n<p><img src=\"/2017/10/11/RocketMQ-Transactional-message/transaction_rocketmq.gif\" alt=\"你想输入的替代文字\"></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>producer发送half msg时，broker如果当它是一条普通的消息，那consumer会立刻在long pooling中收到，但实现是不会收到的，是在哪一个环节设置的。<br>事务消息，提交（COMMIT）后才生成 ConsumeQueue<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommitLogDispatcherBuildConsumeQueue</span> <span class=\"keyword\">implements</span> <span class=\"title\">CommitLogDispatcher</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(DispatchRequest request)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</div><div class=\"line\">        <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class=\"line\">            <span class=\"comment\">// 虽然所有的状态都会存储到commit log中，只有 TRANSACTION_COMMIT_TYPE 状态才会构建consume queue</span></div><div class=\"line\">            <span class=\"comment\">// 也就是说让consumer进行消费</span></div><div class=\"line\">            <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class=\"line\">                DefaultMessageStore.<span class=\"keyword\">this</span>.putMessagePositionInfo(request);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class=\"line\">            <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"SourceCode-Future","date":"2017-12-03T03:15:24.000Z","_content":"\n\nFuture和ChannelFuture中的状态对比","source":"_posts/SourceCode-Future.md","raw":"---\ntitle: SourceCode-Future\ndate: 2017-12-03 11:15:24\ntags: 源码分析\n---\n\n\nFuture和ChannelFuture中的状态对比","slug":"SourceCode-Future","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszr00373iq2l573mnlh","content":"<p>Future和ChannelFuture中的状态对比</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Future和ChannelFuture中的状态对比</p>\n"},{"title":"SourceCode-AbstractQueuedSynchronizer","date":"2017-12-03T03:15:58.000Z","_content":"\n\nhttp://guochenglai.com/2016/06/06/java-concurrent5-aqs-code-analysis/\n\n### 基于AQS的公平与非公平锁设计\n\n### fair\n\n严格的先来先到，如果有人来排队，不能插队，一定要排到队尾！！\n\n### nonfair\n\n总体是先来先到，但新来的可以在队头进行插队\n\n``` java\nfinal void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n         acquire(1);\n }\n```\n\n``` java\n/**\n * Releases in exclusive mode.  Implemented by unblocking one or\n * more threads if {@link #tryRelease} returns true.\n * This method can be used to implement method {@link Lock#unlock}.\n *\n * @param arg the release argument.  This value is conveyed to\n *        {@link #tryRelease} but is otherwise uninterpreted and\n *        can represent anything you like.\n * @return the value returned from {@link #tryRelease}\n */\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n\n### 基于AQS的倒计时锁设计\n\n### 基于AQS的semaphore设计\n\n\n\n\n\n### 很好的文章\nhttp://blog.csdn.net/hengyunabc/article/details/28126139\n\npark和unpark的灵活之处\n上面已经提到，unpark函数可以先于park调用，这个正是它们的灵活之处。\n\n一个线程它有可能在别的线程unPark之前，或者之后，或者同时调用了park，那么因为park的特性，它可以不用担心自己的park的时序问题，否则，如果park必须要在unpark之前，那么给编程带来很大的麻烦！！\n\n考虑一下，两个线程同步，要如何处理？\n\n在Java5里是用wait/notify/notifyAll来同步的。wait/notify机制有个很蛋疼的地方是，比如线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。编程的时候就会很蛋疼。\n\n另外，是调用notify，还是notifyAll？\n\nnotify只会唤醒一个线程，如果错误地有两个线程在同一个对象上wait等待，那么又悲剧了。为了安全起见，貌似只能调用notifyAll了。\n\npark/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态。\n\nHotSpot里park/unpark的实现\n\n每个java线程都有一个Parker实例，Parker类是这样定义的：\n\n``` C++ \nclass Parker : public os::PlatformParker {  \nprivate:  \n  volatile int _counter ;  \n  ...  \npublic:  \n  void park(bool isAbsolute, jlong time);  \n  void unpark();  \n  ...  \n}  \nclass PlatformParker : public CHeapObj<mtInternal> {  \n  protected:  \n    pthread_mutex_t _mutex [1] ;  \n    pthread_cond_t  _cond  [1] ;  \n    ...  \n} \n```","source":"_posts/SourceCode-AbstractQueuedSynchronizer.md","raw":"---\ntitle: SourceCode-AbstractQueuedSynchronizer\ndate: 2017-12-03 11:15:58\ntags: 源码分析\n---\n\n\nhttp://guochenglai.com/2016/06/06/java-concurrent5-aqs-code-analysis/\n\n### 基于AQS的公平与非公平锁设计\n\n### fair\n\n严格的先来先到，如果有人来排队，不能插队，一定要排到队尾！！\n\n### nonfair\n\n总体是先来先到，但新来的可以在队头进行插队\n\n``` java\nfinal void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n         acquire(1);\n }\n```\n\n``` java\n/**\n * Releases in exclusive mode.  Implemented by unblocking one or\n * more threads if {@link #tryRelease} returns true.\n * This method can be used to implement method {@link Lock#unlock}.\n *\n * @param arg the release argument.  This value is conveyed to\n *        {@link #tryRelease} but is otherwise uninterpreted and\n *        can represent anything you like.\n * @return the value returned from {@link #tryRelease}\n */\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n\n### 基于AQS的倒计时锁设计\n\n### 基于AQS的semaphore设计\n\n\n\n\n\n### 很好的文章\nhttp://blog.csdn.net/hengyunabc/article/details/28126139\n\npark和unpark的灵活之处\n上面已经提到，unpark函数可以先于park调用，这个正是它们的灵活之处。\n\n一个线程它有可能在别的线程unPark之前，或者之后，或者同时调用了park，那么因为park的特性，它可以不用担心自己的park的时序问题，否则，如果park必须要在unpark之前，那么给编程带来很大的麻烦！！\n\n考虑一下，两个线程同步，要如何处理？\n\n在Java5里是用wait/notify/notifyAll来同步的。wait/notify机制有个很蛋疼的地方是，比如线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。编程的时候就会很蛋疼。\n\n另外，是调用notify，还是notifyAll？\n\nnotify只会唤醒一个线程，如果错误地有两个线程在同一个对象上wait等待，那么又悲剧了。为了安全起见，貌似只能调用notifyAll了。\n\npark/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态。\n\nHotSpot里park/unpark的实现\n\n每个java线程都有一个Parker实例，Parker类是这样定义的：\n\n``` C++ \nclass Parker : public os::PlatformParker {  \nprivate:  \n  volatile int _counter ;  \n  ...  \npublic:  \n  void park(bool isAbsolute, jlong time);  \n  void unpark();  \n  ...  \n}  \nclass PlatformParker : public CHeapObj<mtInternal> {  \n  protected:  \n    pthread_mutex_t _mutex [1] ;  \n    pthread_cond_t  _cond  [1] ;  \n    ...  \n} \n```","slug":"SourceCode-AbstractQueuedSynchronizer","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszs003a3iq2ehvny98o","content":"<p><a href=\"http://guochenglai.com/2016/06/06/java-concurrent5-aqs-code-analysis/\" target=\"_blank\" rel=\"external\">http://guochenglai.com/2016/06/06/java-concurrent5-aqs-code-analysis/</a></p>\n<h3 id=\"基于AQS的公平与非公平锁设计\"><a href=\"#基于AQS的公平与非公平锁设计\" class=\"headerlink\" title=\"基于AQS的公平与非公平锁设计\"></a>基于AQS的公平与非公平锁设计</h3><h3 id=\"fair\"><a href=\"#fair\" class=\"headerlink\" title=\"fair\"></a>fair</h3><p>严格的先来先到，如果有人来排队，不能插队，一定要排到队尾！！</p>\n<h3 id=\"nonfair\"><a href=\"#nonfair\" class=\"headerlink\" title=\"nonfair\"></a>nonfair</h3><p>总体是先来先到，但新来的可以在队头进行插队</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</div><div class=\"line\">        setExclusiveOwnerThread(Thread.currentThread());</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">         acquire(<span class=\"number\">1</span>);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * Releases in exclusive mode.  Implemented by unblocking one or</span></div><div class=\"line\"><span class=\"comment\"> * more threads if &#123;<span class=\"doctag\">@link</span> #tryRelease&#125; returns true.</span></div><div class=\"line\"><span class=\"comment\"> * This method can be used to implement method &#123;<span class=\"doctag\">@link</span> Lock#unlock&#125;.</span></div><div class=\"line\"><span class=\"comment\"> *</span></div><div class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> arg the release argument.  This value is conveyed to</span></div><div class=\"line\"><span class=\"comment\"> *        &#123;<span class=\"doctag\">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></div><div class=\"line\"><span class=\"comment\"> *        can represent anything you like.</span></div><div class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the value returned from &#123;<span class=\"doctag\">@link</span> #tryRelease&#125;</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</div><div class=\"line\">            unparkSuccessor(h);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"基于AQS的倒计时锁设计\"><a href=\"#基于AQS的倒计时锁设计\" class=\"headerlink\" title=\"基于AQS的倒计时锁设计\"></a>基于AQS的倒计时锁设计</h3><h3 id=\"基于AQS的semaphore设计\"><a href=\"#基于AQS的semaphore设计\" class=\"headerlink\" title=\"基于AQS的semaphore设计\"></a>基于AQS的semaphore设计</h3><h3 id=\"很好的文章\"><a href=\"#很好的文章\" class=\"headerlink\" title=\"很好的文章\"></a>很好的文章</h3><p><a href=\"http://blog.csdn.net/hengyunabc/article/details/28126139\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/hengyunabc/article/details/28126139</a></p>\n<p>park和unpark的灵活之处<br>上面已经提到，unpark函数可以先于park调用，这个正是它们的灵活之处。</p>\n<p>一个线程它有可能在别的线程unPark之前，或者之后，或者同时调用了park，那么因为park的特性，它可以不用担心自己的park的时序问题，否则，如果park必须要在unpark之前，那么给编程带来很大的麻烦！！</p>\n<p>考虑一下，两个线程同步，要如何处理？</p>\n<p>在Java5里是用wait/notify/notifyAll来同步的。wait/notify机制有个很蛋疼的地方是，比如线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。编程的时候就会很蛋疼。</p>\n<p>另外，是调用notify，还是notifyAll？</p>\n<p>notify只会唤醒一个线程，如果错误地有两个线程在同一个对象上wait等待，那么又悲剧了。为了安全起见，貌似只能调用notifyAll了。</p>\n<p>park/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态。</p>\n<p>HotSpot里park/unpark的实现</p>\n<p>每个java线程都有一个Parker实例，Parker类是这样定义的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parker</span> :</span> <span class=\"keyword\">public</span> os::PlatformParker &#123;  </div><div class=\"line\"><span class=\"keyword\">private</span>:  </div><div class=\"line\">  <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> _counter ;  </div><div class=\"line\">  ...  </div><div class=\"line\"><span class=\"keyword\">public</span>:  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">park</span><span class=\"params\">(<span class=\"keyword\">bool</span> isAbsolute, jlong time)</span></span>;  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unpark</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">  ...  </div><div class=\"line\">&#125;  </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlatformParker</span> :</span> <span class=\"keyword\">public</span> CHeapObj&lt;mtInternal&gt; &#123;  </div><div class=\"line\">  <span class=\"keyword\">protected</span>:  </div><div class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> _mutex [<span class=\"number\">1</span>] ;  </div><div class=\"line\">    <span class=\"keyword\">pthread_cond_t</span>  _cond  [<span class=\"number\">1</span>] ;  </div><div class=\"line\">    ...  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://guochenglai.com/2016/06/06/java-concurrent5-aqs-code-analysis/\" target=\"_blank\" rel=\"external\">http://guochenglai.com/2016/06/06/java-concurrent5-aqs-code-analysis/</a></p>\n<h3 id=\"基于AQS的公平与非公平锁设计\"><a href=\"#基于AQS的公平与非公平锁设计\" class=\"headerlink\" title=\"基于AQS的公平与非公平锁设计\"></a>基于AQS的公平与非公平锁设计</h3><h3 id=\"fair\"><a href=\"#fair\" class=\"headerlink\" title=\"fair\"></a>fair</h3><p>严格的先来先到，如果有人来排队，不能插队，一定要排到队尾！！</p>\n<h3 id=\"nonfair\"><a href=\"#nonfair\" class=\"headerlink\" title=\"nonfair\"></a>nonfair</h3><p>总体是先来先到，但新来的可以在队头进行插队</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</div><div class=\"line\">        setExclusiveOwnerThread(Thread.currentThread());</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">         acquire(<span class=\"number\">1</span>);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * Releases in exclusive mode.  Implemented by unblocking one or</span></div><div class=\"line\"><span class=\"comment\"> * more threads if &#123;<span class=\"doctag\">@link</span> #tryRelease&#125; returns true.</span></div><div class=\"line\"><span class=\"comment\"> * This method can be used to implement method &#123;<span class=\"doctag\">@link</span> Lock#unlock&#125;.</span></div><div class=\"line\"><span class=\"comment\"> *</span></div><div class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> arg the release argument.  This value is conveyed to</span></div><div class=\"line\"><span class=\"comment\"> *        &#123;<span class=\"doctag\">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></div><div class=\"line\"><span class=\"comment\"> *        can represent anything you like.</span></div><div class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the value returned from &#123;<span class=\"doctag\">@link</span> #tryRelease&#125;</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</div><div class=\"line\">            unparkSuccessor(h);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"基于AQS的倒计时锁设计\"><a href=\"#基于AQS的倒计时锁设计\" class=\"headerlink\" title=\"基于AQS的倒计时锁设计\"></a>基于AQS的倒计时锁设计</h3><h3 id=\"基于AQS的semaphore设计\"><a href=\"#基于AQS的semaphore设计\" class=\"headerlink\" title=\"基于AQS的semaphore设计\"></a>基于AQS的semaphore设计</h3><h3 id=\"很好的文章\"><a href=\"#很好的文章\" class=\"headerlink\" title=\"很好的文章\"></a>很好的文章</h3><p><a href=\"http://blog.csdn.net/hengyunabc/article/details/28126139\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/hengyunabc/article/details/28126139</a></p>\n<p>park和unpark的灵活之处<br>上面已经提到，unpark函数可以先于park调用，这个正是它们的灵活之处。</p>\n<p>一个线程它有可能在别的线程unPark之前，或者之后，或者同时调用了park，那么因为park的特性，它可以不用担心自己的park的时序问题，否则，如果park必须要在unpark之前，那么给编程带来很大的麻烦！！</p>\n<p>考虑一下，两个线程同步，要如何处理？</p>\n<p>在Java5里是用wait/notify/notifyAll来同步的。wait/notify机制有个很蛋疼的地方是，比如线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。编程的时候就会很蛋疼。</p>\n<p>另外，是调用notify，还是notifyAll？</p>\n<p>notify只会唤醒一个线程，如果错误地有两个线程在同一个对象上wait等待，那么又悲剧了。为了安全起见，貌似只能调用notifyAll了。</p>\n<p>park/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态。</p>\n<p>HotSpot里park/unpark的实现</p>\n<p>每个java线程都有一个Parker实例，Parker类是这样定义的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parker</span> :</span> <span class=\"keyword\">public</span> os::PlatformParker &#123;  </div><div class=\"line\"><span class=\"keyword\">private</span>:  </div><div class=\"line\">  <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> _counter ;  </div><div class=\"line\">  ...  </div><div class=\"line\"><span class=\"keyword\">public</span>:  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">park</span><span class=\"params\">(<span class=\"keyword\">bool</span> isAbsolute, jlong time)</span></span>;  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unpark</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">  ...  </div><div class=\"line\">&#125;  </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlatformParker</span> :</span> <span class=\"keyword\">public</span> CHeapObj&lt;mtInternal&gt; &#123;  </div><div class=\"line\">  <span class=\"keyword\">protected</span>:  </div><div class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> _mutex [<span class=\"number\">1</span>] ;  </div><div class=\"line\">    <span class=\"keyword\">pthread_cond_t</span>  _cond  [<span class=\"number\">1</span>] ;  </div><div class=\"line\">    ...  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"SourceCode-Map","date":"2017-11-12T13:54:26.000Z","_content":"\nhttp://www.importnew.com/26049.html\nConcurrentHashMap\n\nJDK ConcurrentHashMap如何提高并发度\nconcurrenthashmap在读写并发的时候，什么时候可见，什么时候不可见\n\nhttp://pettyandydog.com/2016/08/28/HashMap_infinite_loop/#more\nHashMap\n\nHashMap\n\nHashMap的工作原理是什么\nhashmap在 扩容 时为什么是乘以2. newCap = oldCap << 1 ，看看是不是和旧数据在新的Map中是否要产生偏移相关，不然所有的数据都挤在数组的前段。\n内部的数据结构是什么\nHashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？\nHashMap 实现的数据结构是什么？如何实现\nHashMap 和 HashTable、ConcurrentHashMap 的区别\nHashMap的遍历方式及效率\nHashMap、LinkedMap、TreeMap的区别\n如何决定选用HashMap还是TreeMap\n如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办\nHashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等\n\nJDK1.8 中 concurrentHashMap 在扩容的时候是怎么做的，如何提高效率的，什么时候是多线程执行，什么时候单线程执行，如果某个线程正在扩容一个槽里的数据，如何保证后续线程不会重复计算。面蚂蚁金服暑期实习生的时候遇到的。\n\n分段锁\nhttp://guochenglai.com/2016/06/04/java-concurrent4-java-subsection-decompose/\n\n\n\n线程池源码分析： ExecutorService  定时任务怎么实现的？提交给线程池的任务实现runnable，线程执行完它就dead了，怎么做到线程复用的？","source":"_posts/SourceCode-Map.md","raw":"---\ntitle: SourceCode-Map\ndate: 2017-11-12 21:54:26\ntags: 源码分析\n---\n\nhttp://www.importnew.com/26049.html\nConcurrentHashMap\n\nJDK ConcurrentHashMap如何提高并发度\nconcurrenthashmap在读写并发的时候，什么时候可见，什么时候不可见\n\nhttp://pettyandydog.com/2016/08/28/HashMap_infinite_loop/#more\nHashMap\n\nHashMap\n\nHashMap的工作原理是什么\nhashmap在 扩容 时为什么是乘以2. newCap = oldCap << 1 ，看看是不是和旧数据在新的Map中是否要产生偏移相关，不然所有的数据都挤在数组的前段。\n内部的数据结构是什么\nHashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？\nHashMap 实现的数据结构是什么？如何实现\nHashMap 和 HashTable、ConcurrentHashMap 的区别\nHashMap的遍历方式及效率\nHashMap、LinkedMap、TreeMap的区别\n如何决定选用HashMap还是TreeMap\n如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办\nHashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等\n\nJDK1.8 中 concurrentHashMap 在扩容的时候是怎么做的，如何提高效率的，什么时候是多线程执行，什么时候单线程执行，如果某个线程正在扩容一个槽里的数据，如何保证后续线程不会重复计算。面蚂蚁金服暑期实习生的时候遇到的。\n\n分段锁\nhttp://guochenglai.com/2016/06/04/java-concurrent4-java-subsection-decompose/\n\n\n\n线程池源码分析： ExecutorService  定时任务怎么实现的？提交给线程池的任务实现runnable，线程执行完它就dead了，怎么做到线程复用的？","slug":"SourceCode-Map","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszt003b3iq24ls47zc7","content":"<p><a href=\"http://www.importnew.com/26049.html\" target=\"_blank\" rel=\"external\">http://www.importnew.com/26049.html</a><br>ConcurrentHashMap</p>\n<p>JDK ConcurrentHashMap如何提高并发度<br>concurrenthashmap在读写并发的时候，什么时候可见，什么时候不可见</p>\n<p><a href=\"http://pettyandydog.com/2016/08/28/HashMap_infinite_loop/#more\" target=\"_blank\" rel=\"external\">http://pettyandydog.com/2016/08/28/HashMap_infinite_loop/#more</a><br>HashMap</p>\n<p>HashMap</p>\n<p>HashMap的工作原理是什么<br>hashmap在 扩容 时为什么是乘以2. newCap = oldCap &lt;&lt; 1 ，看看是不是和旧数据在新的Map中是否要产生偏移相关，不然所有的数据都挤在数组的前段。<br>内部的数据结构是什么<br>HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？<br>HashMap 实现的数据结构是什么？如何实现<br>HashMap 和 HashTable、ConcurrentHashMap 的区别<br>HashMap的遍历方式及效率<br>HashMap、LinkedMap、TreeMap的区别<br>如何决定选用HashMap还是TreeMap<br>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办<br>HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等</p>\n<p>JDK1.8 中 concurrentHashMap 在扩容的时候是怎么做的，如何提高效率的，什么时候是多线程执行，什么时候单线程执行，如果某个线程正在扩容一个槽里的数据，如何保证后续线程不会重复计算。面蚂蚁金服暑期实习生的时候遇到的。</p>\n<p>分段锁<br><a href=\"http://guochenglai.com/2016/06/04/java-concurrent4-java-subsection-decompose/\" target=\"_blank\" rel=\"external\">http://guochenglai.com/2016/06/04/java-concurrent4-java-subsection-decompose/</a></p>\n<p>线程池源码分析： ExecutorService  定时任务怎么实现的？提交给线程池的任务实现runnable，线程执行完它就dead了，怎么做到线程复用的？</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.importnew.com/26049.html\" target=\"_blank\" rel=\"external\">http://www.importnew.com/26049.html</a><br>ConcurrentHashMap</p>\n<p>JDK ConcurrentHashMap如何提高并发度<br>concurrenthashmap在读写并发的时候，什么时候可见，什么时候不可见</p>\n<p><a href=\"http://pettyandydog.com/2016/08/28/HashMap_infinite_loop/#more\" target=\"_blank\" rel=\"external\">http://pettyandydog.com/2016/08/28/HashMap_infinite_loop/#more</a><br>HashMap</p>\n<p>HashMap</p>\n<p>HashMap的工作原理是什么<br>hashmap在 扩容 时为什么是乘以2. newCap = oldCap &lt;&lt; 1 ，看看是不是和旧数据在新的Map中是否要产生偏移相关，不然所有的数据都挤在数组的前段。<br>内部的数据结构是什么<br>HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？<br>HashMap 实现的数据结构是什么？如何实现<br>HashMap 和 HashTable、ConcurrentHashMap 的区别<br>HashMap的遍历方式及效率<br>HashMap、LinkedMap、TreeMap的区别<br>如何决定选用HashMap还是TreeMap<br>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办<br>HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等</p>\n<p>JDK1.8 中 concurrentHashMap 在扩容的时候是怎么做的，如何提高效率的，什么时候是多线程执行，什么时候单线程执行，如果某个线程正在扩容一个槽里的数据，如何保证后续线程不会重复计算。面蚂蚁金服暑期实习生的时候遇到的。</p>\n<p>分段锁<br><a href=\"http://guochenglai.com/2016/06/04/java-concurrent4-java-subsection-decompose/\" target=\"_blank\" rel=\"external\">http://guochenglai.com/2016/06/04/java-concurrent4-java-subsection-decompose/</a></p>\n<p>线程池源码分析： ExecutorService  定时任务怎么实现的？提交给线程池的任务实现runnable，线程执行完它就dead了，怎么做到线程复用的？</p>\n"},{"title":"Thread-FAQ","date":"2017-10-27T03:07:35.000Z","_content":"\n\n### TODO hexo new Thread-Poolize-thread\n\n```\n假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。\n\n　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；\n\n　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；\n\n　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；\n\n　　然后就将任务也分配给这4个临时工人做；\n\n　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。\n\n　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。\n```\n\n\n### Executor里面的线程是怎么被复用的？\n\n``` java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n### 问题，ExecutorService的submit和execute有什么区别\n\n\n\n\n\n\n\n\nhttp://blog.csdn.net/zhandoushi1982/article/details/5506597\n线程的挂起操作实质上就是使线程进入“非可执行”状态下，在这个状态下CPU不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行。在线程挂起后，可以通过重新唤醒线程来使之恢复运行。\n\n### ThreadLocal\n\n\n### Future\n\n\n### Promise\n\n### Difference between ReentrantLock and sync\n\n### join\n\n### yield\n\n### fork\n\n\n### Java线程面试题\n\n如果用了ReentrantLock，还需要设置自旋锁么？\n\n假如用sync做了线程互斥，A和B两个线程竞争monitor，A拿到了monitor，如果A迟迟不释放，B将永远等待，怎么避免这种情况？\n\nCopyOnWrite\n\n15个Java多线程面试题及回答\n\n1)现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？\n\n这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。\n\n2)在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？\n\nlock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。\n\n3)在java中wait和sleep方法的不同？\n\n通常会在电话面试中经常被问到的Java线程面试问题。最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。\n\n4）用Java实现阻塞队列。\n\n这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用Java线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5中的并发类来再写一次。\n\n5）用Java写代码来解决生产者——消费者问题。\n\n与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。\n\n6）用Java编程一个会导致死锁的程序，你将怎么解决？\n\n这是我最喜欢的Java线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。\n\n7) 什么是原子操作，Java中的原子操作是什么？\n\n非常简单的java线程面试问题，接下来的问题是你需要同步一个原子操作。\n\n8) Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？\n\n自从Java 5和Java内存模型改变以后，基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎样在并发环境中确保可见性。\n\n9) 什么是竞争条件？你怎样发现和解决竞争？\n\n这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于Java竞争条件的文章。在我看来这是最好的java线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or any other race condition。关于这方面最好的书是《Concurrency practices in Java》。\n\n10) 你将如何使用thread dump？你将如何分析Thread dump？\n\n在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。\n\n11) 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\n\n这是另一个非常经典的java多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级Java面试的第一轮被问到。这个问题的回答应该是这样的，当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start与run方法的区别》这篇文章来获得更多信息。\n\n12) Java中你怎样唤醒一个阻塞的线程？\n\n这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。\n\n13)在Java中CycliBarriar和CountdownLatch有什么区别？\n\n这个线程问题主要用来检测你是否熟悉JDK5中的并发包。这两个的区别是CyclicBarrier可以重复使用已经通过的障碍，而CountdownLatch不能重复使用。\n\n14) 什么是不可变对象，它对写并发应用有什么帮助？\n\n另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个java面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么String是不可变的。\n\n15) 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？\n\n多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的Java线程问题。\n\nhttp://www.importnew.com/27105.html","source":"_posts/Thread-FAQ.md","raw":"---\ntitle: Thread-FAQ\ndate: 2017-10-27 11:07:35\ntags: THread\n---\n\n\n### TODO hexo new Thread-Poolize-thread\n\n```\n假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。\n\n　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；\n\n　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；\n\n　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；\n\n　　然后就将任务也分配给这4个临时工人做；\n\n　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。\n\n　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。\n```\n\n\n### Executor里面的线程是怎么被复用的？\n\n``` java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n### 问题，ExecutorService的submit和execute有什么区别\n\n\n\n\n\n\n\n\nhttp://blog.csdn.net/zhandoushi1982/article/details/5506597\n线程的挂起操作实质上就是使线程进入“非可执行”状态下，在这个状态下CPU不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行。在线程挂起后，可以通过重新唤醒线程来使之恢复运行。\n\n### ThreadLocal\n\n\n### Future\n\n\n### Promise\n\n### Difference between ReentrantLock and sync\n\n### join\n\n### yield\n\n### fork\n\n\n### Java线程面试题\n\n如果用了ReentrantLock，还需要设置自旋锁么？\n\n假如用sync做了线程互斥，A和B两个线程竞争monitor，A拿到了monitor，如果A迟迟不释放，B将永远等待，怎么避免这种情况？\n\nCopyOnWrite\n\n15个Java多线程面试题及回答\n\n1)现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？\n\n这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。\n\n2)在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？\n\nlock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。\n\n3)在java中wait和sleep方法的不同？\n\n通常会在电话面试中经常被问到的Java线程面试问题。最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。\n\n4）用Java实现阻塞队列。\n\n这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用Java线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5中的并发类来再写一次。\n\n5）用Java写代码来解决生产者——消费者问题。\n\n与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。\n\n6）用Java编程一个会导致死锁的程序，你将怎么解决？\n\n这是我最喜欢的Java线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。\n\n7) 什么是原子操作，Java中的原子操作是什么？\n\n非常简单的java线程面试问题，接下来的问题是你需要同步一个原子操作。\n\n8) Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？\n\n自从Java 5和Java内存模型改变以后，基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎样在并发环境中确保可见性。\n\n9) 什么是竞争条件？你怎样发现和解决竞争？\n\n这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于Java竞争条件的文章。在我看来这是最好的java线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or any other race condition。关于这方面最好的书是《Concurrency practices in Java》。\n\n10) 你将如何使用thread dump？你将如何分析Thread dump？\n\n在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。\n\n11) 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\n\n这是另一个非常经典的java多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级Java面试的第一轮被问到。这个问题的回答应该是这样的，当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start与run方法的区别》这篇文章来获得更多信息。\n\n12) Java中你怎样唤醒一个阻塞的线程？\n\n这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。\n\n13)在Java中CycliBarriar和CountdownLatch有什么区别？\n\n这个线程问题主要用来检测你是否熟悉JDK5中的并发包。这两个的区别是CyclicBarrier可以重复使用已经通过的障碍，而CountdownLatch不能重复使用。\n\n14) 什么是不可变对象，它对写并发应用有什么帮助？\n\n另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个java面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么String是不可变的。\n\n15) 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？\n\n多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的Java线程问题。\n\nhttp://www.importnew.com/27105.html","slug":"Thread-FAQ","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszv003e3iq2f566n7t5","content":"<h3 id=\"TODO-hexo-new-Thread-Poolize-thread\"><a href=\"#TODO-hexo-new-Thread-Poolize-thread\" class=\"headerlink\" title=\"TODO hexo new Thread-Poolize-thread\"></a>TODO hexo new Thread-Poolize-thread</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</div><div class=\"line\"></div><div class=\"line\">　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</div><div class=\"line\"></div><div class=\"line\">　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</div><div class=\"line\"></div><div class=\"line\">　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</div><div class=\"line\"></div><div class=\"line\">　　然后就将任务也分配给这4个临时工人做；</div><div class=\"line\"></div><div class=\"line\">　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</div><div class=\"line\"></div><div class=\"line\">　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</div></pre></td></tr></table></figure>\n<h3 id=\"Executor里面的线程是怎么被复用的？\"><a href=\"#Executor里面的线程是怎么被复用的？\" class=\"headerlink\" title=\"Executor里面的线程是怎么被复用的？\"></a>Executor里面的线程是怎么被复用的？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</div><div class=\"line\">    Thread wt = Thread.currentThread();</div><div class=\"line\">    Runnable task = w.firstTask;</div><div class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</div><div class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></div><div class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            w.lock();</div><div class=\"line\">            <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></div><div class=\"line\">            <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></div><div class=\"line\">            <span class=\"comment\">// requires a recheck in second case to deal with</span></div><div class=\"line\">            <span class=\"comment\">// shutdownNow race while clearing interrupt</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class=\"line\">                 (Thread.interrupted() &amp;&amp;</div><div class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class=\"line\">                !wt.isInterrupted())</div><div class=\"line\">                wt.interrupt();</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                beforeExecute(wt, task);</div><div class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    task.run();</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</div><div class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</div><div class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</div><div class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    afterExecute(task, thrown);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                task = <span class=\"keyword\">null</span>;</div><div class=\"line\">                w.completedTasks++;</div><div class=\"line\">                w.unlock();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        processWorkerExit(w, completedAbruptly);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"问题，ExecutorService的submit和execute有什么区别\"><a href=\"#问题，ExecutorService的submit和execute有什么区别\" class=\"headerlink\" title=\"问题，ExecutorService的submit和execute有什么区别\"></a>问题，ExecutorService的submit和execute有什么区别</h3><p><a href=\"http://blog.csdn.net/zhandoushi1982/article/details/5506597\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/zhandoushi1982/article/details/5506597</a><br>线程的挂起操作实质上就是使线程进入“非可执行”状态下，在这个状态下CPU不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行。在线程挂起后，可以通过重新唤醒线程来使之恢复运行。</p>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><h3 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h3><h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><h3 id=\"Difference-between-ReentrantLock-and-sync\"><a href=\"#Difference-between-ReentrantLock-and-sync\" class=\"headerlink\" title=\"Difference between ReentrantLock and sync\"></a>Difference between ReentrantLock and sync</h3><h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h3><h3 id=\"fork\"><a href=\"#fork\" class=\"headerlink\" title=\"fork\"></a>fork</h3><h3 id=\"Java线程面试题\"><a href=\"#Java线程面试题\" class=\"headerlink\" title=\"Java线程面试题\"></a>Java线程面试题</h3><p>如果用了ReentrantLock，还需要设置自旋锁么？</p>\n<p>假如用sync做了线程互斥，A和B两个线程竞争monitor，A拿到了monitor，如果A迟迟不释放，B将永远等待，怎么避免这种情况？</p>\n<p>CopyOnWrite</p>\n<p>15个Java多线程面试题及回答</p>\n<p>1)现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</p>\n<p>这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。</p>\n<p>2)在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</p>\n<p>lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。</p>\n<p>3)在java中wait和sleep方法的不同？</p>\n<p>通常会在电话面试中经常被问到的Java线程面试问题。最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</p>\n<p>4）用Java实现阻塞队列。</p>\n<p>这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用Java线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5中的并发类来再写一次。</p>\n<p>5）用Java写代码来解决生产者——消费者问题。</p>\n<p>与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。</p>\n<p>6）用Java编程一个会导致死锁的程序，你将怎么解决？</p>\n<p>这是我最喜欢的Java线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。</p>\n<p>7) 什么是原子操作，Java中的原子操作是什么？</p>\n<p>非常简单的java线程面试问题，接下来的问题是你需要同步一个原子操作。</p>\n<p>8) Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？</p>\n<p>自从Java 5和Java内存模型改变以后，基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎样在并发环境中确保可见性。</p>\n<p>9) 什么是竞争条件？你怎样发现和解决竞争？</p>\n<p>这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于Java竞争条件的文章。在我看来这是最好的java线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or any other race condition。关于这方面最好的书是《Concurrency practices in Java》。</p>\n<p>10) 你将如何使用thread dump？你将如何分析Thread dump？</p>\n<p>在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。</p>\n<p>11) 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</p>\n<p>这是另一个非常经典的java多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级Java面试的第一轮被问到。这个问题的回答应该是这样的，当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start与run方法的区别》这篇文章来获得更多信息。</p>\n<p>12) Java中你怎样唤醒一个阻塞的线程？</p>\n<p>这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。</p>\n<p>13)在Java中CycliBarriar和CountdownLatch有什么区别？</p>\n<p>这个线程问题主要用来检测你是否熟悉JDK5中的并发包。这两个的区别是CyclicBarrier可以重复使用已经通过的障碍，而CountdownLatch不能重复使用。</p>\n<p>14) 什么是不可变对象，它对写并发应用有什么帮助？</p>\n<p>另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个java面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么String是不可变的。</p>\n<p>15) 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？</p>\n<p>多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的Java线程问题。</p>\n<p><a href=\"http://www.importnew.com/27105.html\" target=\"_blank\" rel=\"external\">http://www.importnew.com/27105.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"TODO-hexo-new-Thread-Poolize-thread\"><a href=\"#TODO-hexo-new-Thread-Poolize-thread\" class=\"headerlink\" title=\"TODO hexo new Thread-Poolize-thread\"></a>TODO hexo new Thread-Poolize-thread</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</div><div class=\"line\"></div><div class=\"line\">　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</div><div class=\"line\"></div><div class=\"line\">　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</div><div class=\"line\"></div><div class=\"line\">　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</div><div class=\"line\"></div><div class=\"line\">　　然后就将任务也分配给这4个临时工人做；</div><div class=\"line\"></div><div class=\"line\">　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</div><div class=\"line\"></div><div class=\"line\">　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</div></pre></td></tr></table></figure>\n<h3 id=\"Executor里面的线程是怎么被复用的？\"><a href=\"#Executor里面的线程是怎么被复用的？\" class=\"headerlink\" title=\"Executor里面的线程是怎么被复用的？\"></a>Executor里面的线程是怎么被复用的？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</div><div class=\"line\">    Thread wt = Thread.currentThread();</div><div class=\"line\">    Runnable task = w.firstTask;</div><div class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</div><div class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></div><div class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            w.lock();</div><div class=\"line\">            <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></div><div class=\"line\">            <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></div><div class=\"line\">            <span class=\"comment\">// requires a recheck in second case to deal with</span></div><div class=\"line\">            <span class=\"comment\">// shutdownNow race while clearing interrupt</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class=\"line\">                 (Thread.interrupted() &amp;&amp;</div><div class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class=\"line\">                !wt.isInterrupted())</div><div class=\"line\">                wt.interrupt();</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                beforeExecute(wt, task);</div><div class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    task.run();</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</div><div class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</div><div class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</div><div class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    afterExecute(task, thrown);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                task = <span class=\"keyword\">null</span>;</div><div class=\"line\">                w.completedTasks++;</div><div class=\"line\">                w.unlock();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        processWorkerExit(w, completedAbruptly);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"问题，ExecutorService的submit和execute有什么区别\"><a href=\"#问题，ExecutorService的submit和execute有什么区别\" class=\"headerlink\" title=\"问题，ExecutorService的submit和execute有什么区别\"></a>问题，ExecutorService的submit和execute有什么区别</h3><p><a href=\"http://blog.csdn.net/zhandoushi1982/article/details/5506597\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/zhandoushi1982/article/details/5506597</a><br>线程的挂起操作实质上就是使线程进入“非可执行”状态下，在这个状态下CPU不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行。在线程挂起后，可以通过重新唤醒线程来使之恢复运行。</p>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><h3 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h3><h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><h3 id=\"Difference-between-ReentrantLock-and-sync\"><a href=\"#Difference-between-ReentrantLock-and-sync\" class=\"headerlink\" title=\"Difference between ReentrantLock and sync\"></a>Difference between ReentrantLock and sync</h3><h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h3><h3 id=\"fork\"><a href=\"#fork\" class=\"headerlink\" title=\"fork\"></a>fork</h3><h3 id=\"Java线程面试题\"><a href=\"#Java线程面试题\" class=\"headerlink\" title=\"Java线程面试题\"></a>Java线程面试题</h3><p>如果用了ReentrantLock，还需要设置自旋锁么？</p>\n<p>假如用sync做了线程互斥，A和B两个线程竞争monitor，A拿到了monitor，如果A迟迟不释放，B将永远等待，怎么避免这种情况？</p>\n<p>CopyOnWrite</p>\n<p>15个Java多线程面试题及回答</p>\n<p>1)现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</p>\n<p>这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。</p>\n<p>2)在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</p>\n<p>lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。</p>\n<p>3)在java中wait和sleep方法的不同？</p>\n<p>通常会在电话面试中经常被问到的Java线程面试问题。最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</p>\n<p>4）用Java实现阻塞队列。</p>\n<p>这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用Java线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5中的并发类来再写一次。</p>\n<p>5）用Java写代码来解决生产者——消费者问题。</p>\n<p>与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。</p>\n<p>6）用Java编程一个会导致死锁的程序，你将怎么解决？</p>\n<p>这是我最喜欢的Java线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。</p>\n<p>7) 什么是原子操作，Java中的原子操作是什么？</p>\n<p>非常简单的java线程面试问题，接下来的问题是你需要同步一个原子操作。</p>\n<p>8) Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？</p>\n<p>自从Java 5和Java内存模型改变以后，基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎样在并发环境中确保可见性。</p>\n<p>9) 什么是竞争条件？你怎样发现和解决竞争？</p>\n<p>这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于Java竞争条件的文章。在我看来这是最好的java线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or any other race condition。关于这方面最好的书是《Concurrency practices in Java》。</p>\n<p>10) 你将如何使用thread dump？你将如何分析Thread dump？</p>\n<p>在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。</p>\n<p>11) 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</p>\n<p>这是另一个非常经典的java多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级Java面试的第一轮被问到。这个问题的回答应该是这样的，当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start与run方法的区别》这篇文章来获得更多信息。</p>\n<p>12) Java中你怎样唤醒一个阻塞的线程？</p>\n<p>这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。</p>\n<p>13)在Java中CycliBarriar和CountdownLatch有什么区别？</p>\n<p>这个线程问题主要用来检测你是否熟悉JDK5中的并发包。这两个的区别是CyclicBarrier可以重复使用已经通过的障碍，而CountdownLatch不能重复使用。</p>\n<p>14) 什么是不可变对象，它对写并发应用有什么帮助？</p>\n<p>另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个java面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么String是不可变的。</p>\n<p>15) 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？</p>\n<p>多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的Java线程问题。</p>\n<p><a href=\"http://www.importnew.com/27105.html\" target=\"_blank\" rel=\"external\">http://www.importnew.com/27105.html</a></p>\n"},{"title":"tree-cache-single-thread-event-handler-in-curator","date":"2017-09-20T07:32:22.000Z","_content":"\n\nGenericFutureListener.operationComplete(Future) is directly called by an I/O thread. Therefore, performing a time consuming task or a blocking operation in the handler method can cause an unexpected pause during I/O. If you need to perform a blocking operation on I/O completion, try to execute the operation in a different thread using a thread pool.\n\n``` java\nchannel.writeAndFlush(request).addListener(new ChannelFutureListener() {\n    @Override\n    public void operationComplete(ChannelFuture f) throws Exception {\n        if (f.isSuccess()) {\n            responseFuture.setSendRequestOK(true);\n            return;\n        } else {\n            responseFuture.setSendRequestOK(false);\n        }\n\n        responseTable.remove(opaque);\n        responseFuture.setCause(f.cause());\n        responseFuture.putResponse(null);\n        log.warn(\"send a request command to channel <\" + addr + \"> failed.\");\n    }\n});\n```","source":"_posts/tree-cache-single-thread-event-handler-in-curator.md","raw":"---\ntitle: tree-cache-single-thread-event-handler-in-curator\ndate: 2017-09-20 15:32:22\ntags: Curator\n---\n\n\nGenericFutureListener.operationComplete(Future) is directly called by an I/O thread. Therefore, performing a time consuming task or a blocking operation in the handler method can cause an unexpected pause during I/O. If you need to perform a blocking operation on I/O completion, try to execute the operation in a different thread using a thread pool.\n\n``` java\nchannel.writeAndFlush(request).addListener(new ChannelFutureListener() {\n    @Override\n    public void operationComplete(ChannelFuture f) throws Exception {\n        if (f.isSuccess()) {\n            responseFuture.setSendRequestOK(true);\n            return;\n        } else {\n            responseFuture.setSendRequestOK(false);\n        }\n\n        responseTable.remove(opaque);\n        responseFuture.setCause(f.cause());\n        responseFuture.putResponse(null);\n        log.warn(\"send a request command to channel <\" + addr + \"> failed.\");\n    }\n});\n```","slug":"tree-cache-single-thread-event-handler-in-curator","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszw003f3iq2p08iekn5","content":"<p>GenericFutureListener.operationComplete(Future) is directly called by an I/O thread. Therefore, performing a time consuming task or a blocking operation in the handler method can cause an unexpected pause during I/O. If you need to perform a blocking operation on I/O completion, try to execute the operation in a different thread using a thread pool.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.writeAndFlush(request).addListener(<span class=\"keyword\">new</span> ChannelFutureListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationComplete</span><span class=\"params\">(ChannelFuture f)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (f.isSuccess()) &#123;</div><div class=\"line\">            responseFuture.setSendRequestOK(<span class=\"keyword\">true</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            responseFuture.setSendRequestOK(<span class=\"keyword\">false</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        responseTable.remove(opaque);</div><div class=\"line\">        responseFuture.setCause(f.cause());</div><div class=\"line\">        responseFuture.putResponse(<span class=\"keyword\">null</span>);</div><div class=\"line\">        log.warn(<span class=\"string\">\"send a request command to channel &lt;\"</span> + addr + <span class=\"string\">\"&gt; failed.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>GenericFutureListener.operationComplete(Future) is directly called by an I/O thread. Therefore, performing a time consuming task or a blocking operation in the handler method can cause an unexpected pause during I/O. If you need to perform a blocking operation on I/O completion, try to execute the operation in a different thread using a thread pool.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.writeAndFlush(request).addListener(<span class=\"keyword\">new</span> ChannelFutureListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationComplete</span><span class=\"params\">(ChannelFuture f)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (f.isSuccess()) &#123;</div><div class=\"line\">            responseFuture.setSendRequestOK(<span class=\"keyword\">true</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            responseFuture.setSendRequestOK(<span class=\"keyword\">false</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        responseTable.remove(opaque);</div><div class=\"line\">        responseFuture.setCause(f.cause());</div><div class=\"line\">        responseFuture.putResponse(<span class=\"keyword\">null</span>);</div><div class=\"line\">        log.warn(<span class=\"string\">\"send a request command to channel &lt;\"</span> + addr + <span class=\"string\">\"&gt; failed.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>"},{"title":"TCP-Protocol-Analyzer","date":"2017-12-22T01:54:47.000Z","_content":"\nhttp://blog.csdn.net/q1007729991/article/details/70154359\n\n\n\n","source":"_posts/TCP-Protocol-Analyzer.md","raw":"---\ntitle: TCP-Protocol-Analyzer\ndate: 2017-12-22 09:54:47\ntags: TCP\n---\n\nhttp://blog.csdn.net/q1007729991/article/details/70154359\n\n\n\n","slug":"TCP-Protocol-Analyzer","published":1,"updated":"2018-03-06T08:21:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj3wcszx003h3iq2k4wtfnjt","content":"<p><a href=\"http://blog.csdn.net/q1007729991/article/details/70154359\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/q1007729991/article/details/70154359</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://blog.csdn.net/q1007729991/article/details/70154359\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/q1007729991/article/details/70154359</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock/abnormal.gif","slug":"abnormal.gif","post":"cjj3wcsxe00003iq2gzdelso7","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock/normal.gif","slug":"normal.gif","post":"cjj3wcsxe00003iq2gzdelso7","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Enhance-cobar-driver-with-high-availability/after-cobar-driver.gif","slug":"after-cobar-driver.gif","post":"cjj3wcsxo00053iq26l3j2g45","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Enhance-cobar-driver-with-high-availability/before-cobar-driver.gif","slug":"before-cobar-driver.gif","post":"cjj3wcsxo00053iq26l3j2g45","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock/datasource-swithch-with-zk-event-sender.gif","slug":"datasource-swithch-with-zk-event-sender.gif","post":"cjj3wcsxe00003iq2gzdelso7","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datahost.gif","slug":"datasource-on-datahost.gif","post":"cjj3wcsxm00043iq2c34i3z84","modified":0,"renderable":0},{"_id":"source/_posts/JVM-Lock/light_lock_flow.jpg","slug":"light_lock_flow.jpg","post":"cjj3wcsyv001d3iq2r9wnctq8","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock/zk-distributed-lock.gif","slug":"zk-distributed-lock.gif","post":"cjj3wcsxe00003iq2gzdelso7","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Enhance-cobar-dataSource-with-dataHost/datasource-on-datanode.gif","slug":"datasource-on-datanode.gif","post":"cjj3wcsxm00043iq2c34i3z84","modified":0,"renderable":0},{"_id":"source/_posts/JVM-Lock/biased_lock_flow.jpg","slug":"biased_lock_flow.jpg","post":"cjj3wcsyv001d3iq2r9wnctq8","modified":0,"renderable":0},{"_id":"source/_posts/RocketMQ-Message-send-and-persistence/disc-fall.gif","slug":"disc-fall.gif","post":"cjj3wcszl002y3iq2nubws3qo","modified":0,"renderable":0},{"_id":"source/_posts/Distributed-Transaction/transaction_rocketmq.gif","slug":"transaction_rocketmq.gif","post":"cjj3wcsyp00103iq2ucqi5ypu","modified":0,"renderable":0},{"_id":"source/_posts/Netty-Jemalloc/jemalloc.jpg","slug":"jemalloc.jpg","post":"cjj3wcszc002g3iq23ojidxuk","modified":0,"renderable":0},{"_id":"source/_posts/RocketMQ-Index-service/index-file.gif","slug":"index-file.gif","post":"cjj3wcszh002q3iq23tzaootq","modified":0,"renderable":0},{"_id":"source/_posts/RocketMQ-Transactional-message/transaction_rocketmq.gif","slug":"transaction_rocketmq.gif","post":"cjj3wcszq00363iq287wvfb7q","modified":0,"renderable":0},{"_id":"source/_posts/TCP-Protocol-Analyzer/mySql-handshake.gif","slug":"mySql-handshake.gif","post":"cjj3wcszx003h3iq2k4wtfnjt","modified":0,"renderable":0},{"_id":"source/_posts/Kafka-High-performance-design-with-pagecache/disk_read_write_speed.jpg","slug":"disk_read_write_speed.jpg","post":"cjj3wcsz2001s3iq2vlvq2mg0","modified":0,"renderable":0},{"_id":"source/_posts/Kafka-High-performance-design-with-pagecache/read_write.gif","slug":"read_write.gif","post":"cjj3wcsz2001s3iq2vlvq2mg0","modified":0,"renderable":0},{"_id":"source/_posts/RocketMQ-Netty-imp-sync-and-async-invoke/invokeAsync.png","slug":"invokeAsync.png","post":"cjj3wcszk002v3iq20wk995eu","modified":0,"renderable":0},{"_id":"source/_posts/RocketMQ-Netty-imp-sync-and-async-invoke/invokeSync.png","slug":"invokeSync.png","post":"cjj3wcszk002v3iq20wk995eu","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Database-Scales/backup-and-replay.gif","slug":"backup-and-replay.gif","post":"cjj3wcsxi00023iq2zuhv730g","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Database-Scales/binlog-sync.gif","slug":"binlog-sync.gif","post":"cjj3wcsxi00023iq2zuhv730g","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Database-Scales/cobar-rule-reload.gif","slug":"cobar-rule-reload.gif","post":"cjj3wcsxi00023iq2zuhv730g","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Reactor-design-pattern/CobarReactor.gif","slug":"CobarReactor.gif","post":"cjj3wcsyb000m3iq28hisx8ou","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Reactor-design-pattern/CobarReactorSign.gif","slug":"CobarReactorSign.gif","post":"cjj3wcsyb000m3iq28hisx8ou","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Reactor-design-pattern/NioRegister.gif","slug":"NioRegister.gif","post":"cjj3wcsyb000m3iq28hisx8ou","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Reactor-design-pattern/NioSign.gif","slug":"NioSign.gif","post":"cjj3wcsyb000m3iq28hisx8ou","modified":0,"renderable":0},{"_id":"source/_posts/JVM-Lock/biased_lock_convert_flow.jpg","slug":"biased_lock_convert_flow.jpg","post":"cjj3wcsyv001d3iq2r9wnctq8","modified":0,"renderable":0},{"_id":"source/_posts/JVM-Lock/markword_state.jpg","slug":"markword_state.jpg","post":"cjj3wcsyv001d3iq2r9wnctq8","modified":0,"renderable":0},{"_id":"source/_posts/Cobar-Cluster-datasource-switch-design-with-distributed-lock/sign.gif","slug":"sign.gif","post":"cjj3wcsxe00003iq2gzdelso7","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjj3wcsxo00053iq26l3j2g45","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsxt00083iq2hma8loh3"},{"post_id":"cjj3wcsxe00003iq2gzdelso7","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsxw000a3iq20dptr55l"},{"post_id":"cjj3wcsxq00063iq2xthrhv0u","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsy3000d3iq24p6oi1dk"},{"post_id":"cjj3wcsxu00093iq2dca6d2bp","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsy5000f3iq2wu68ezmx"},{"post_id":"cjj3wcsxi00023iq2zuhv730g","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsy9000h3iq2u59iqzij"},{"post_id":"cjj3wcsxx000b3iq2t3uuz87t","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsya000j3iq2h6bwmter"},{"post_id":"cjj3wcsy3000e3iq29fsbo0i0","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsyb000l3iq2lezk3enn"},{"post_id":"cjj3wcsxm00043iq2c34i3z84","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsyc000n3iq2z32r1dk6"},{"post_id":"cjj3wcsy6000g3iq212o4z0ne","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsyd000p3iq2tejgqj56"},{"post_id":"cjj3wcsy9000i3iq27zsf12m1","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsye000s3iq2ejtkywnl"},{"post_id":"cjj3wcsya000k3iq2rwljv25y","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsyf000u3iq2zkcuey87"},{"post_id":"cjj3wcsyb000m3iq28hisx8ou","tag_id":"cjj3wcsxk00033iq2xnwmdf1r","_id":"cjj3wcsyf000w3iq2rud9ii53"},{"post_id":"cjj3wcsyc000o3iq2moo800ti","tag_id":"cjj3wcsye000r3iq2x00h70fn","_id":"cjj3wcsyp000z3iq2ye1828aj"},{"post_id":"cjj3wcsyd000q3iq2b0608ezy","tag_id":"cjj3wcsyp000y3iq22x7yn21p","_id":"cjj3wcsys00143iq2fqfu7813"},{"post_id":"cjj3wcsye000t3iq2wdmff3j6","tag_id":"cjj3wcsye000r3iq2x00h70fn","_id":"cjj3wcsyt00183iq2a00wj1jb"},{"post_id":"cjj3wcsyf000v3iq2br47vxag","tag_id":"cjj3wcsys00163iq2jq3idxll","_id":"cjj3wcsyv001c3iq2c646fpkl"},{"post_id":"cjj3wcsyg000x3iq2dj9yykcq","tag_id":"cjj3wcsyu001a3iq2onvj0k57","_id":"cjj3wcsyx001g3iq2frwva4un"},{"post_id":"cjj3wcsyp00103iq2ucqi5ypu","tag_id":"cjj3wcsys00163iq2jq3idxll","_id":"cjj3wcsyy001k3iq2ex4i0ida"},{"post_id":"cjj3wcsyq00113iq2fhmdjdlq","tag_id":"cjj3wcsyy001i3iq24hxopdil","_id":"cjj3wcsz0001o3iq2uytnx6bb"},{"post_id":"cjj3wcsyr00133iq28ruqmiy5","tag_id":"cjj3wcsz0001n3iq2z3l8gbxd","_id":"cjj3wcsz2001t3iq2qlj740ue"},{"post_id":"cjj3wcsys00153iq2y5swmh97","tag_id":"cjj3wcsz1001r3iq2xuv5a8t5","_id":"cjj3wcsz4001x3iq27mdjbkr4"},{"post_id":"cjj3wcsyt00173iq2d9knarfl","tag_id":"cjj3wcsz0001n3iq2z3l8gbxd","_id":"cjj3wcsz600213iq2djkecgaw"},{"post_id":"cjj3wcsyv001d3iq2r9wnctq8","tag_id":"cjj3wcsz0001n3iq2z3l8gbxd","_id":"cjj3wcsz800253iq21mlleayn"},{"post_id":"cjj3wcsyw001f3iq2bm65fbv1","tag_id":"cjj3wcsz0001n3iq2z3l8gbxd","_id":"cjj3wcsza00293iq2c96rjg2n"},{"post_id":"cjj3wcsyx001h3iq236xbkaoq","tag_id":"cjj3wcsz0001n3iq2z3l8gbxd","_id":"cjj3wcszb002d3iq26hlno5zg"},{"post_id":"cjj3wcsyy001j3iq2svsv8eib","tag_id":"cjj3wcsz0001n3iq2z3l8gbxd","_id":"cjj3wcszd002h3iq28y6zr2l4"},{"post_id":"cjj3wcsyz001l3iq2xv0kkf5u","tag_id":"cjj3wcsz0001n3iq2z3l8gbxd","_id":"cjj3wcszf002l3iq21qfdtou4"},{"post_id":"cjj3wcsyz001m3iq22f2w8ej8","tag_id":"cjj3wcsze002j3iq2bdgzao49","_id":"cjj3wcszh002p3iq24jmisnrb"},{"post_id":"cjj3wcsz0001p3iq2blqyektp","tag_id":"cjj3wcszg002n3iq2ymjgvnwa","_id":"cjj3wcszj002t3iq24visqgef"},{"post_id":"cjj3wcsz1001q3iq277vqqfxa","tag_id":"cjj3wcszg002n3iq2ymjgvnwa","_id":"cjj3wcszl002x3iq2t6g2b0bj"},{"post_id":"cjj3wcsz2001s3iq2vlvq2mg0","tag_id":"cjj3wcsze002j3iq2bdgzao49","_id":"cjj3wcszo00313iq2uyxlrhwo"},{"post_id":"cjj3wcsz2001u3iq25sb2tc7q","tag_id":"cjj3wcszg002n3iq2ymjgvnwa","_id":"cjj3wcszq00353iq2zty5hzge"},{"post_id":"cjj3wcsz4001w3iq2ekv8tzku","tag_id":"cjj3wcszg002n3iq2ymjgvnwa","_id":"cjj3wcszs00393iq2j3gkjtzx"},{"post_id":"cjj3wcsz4001y3iq21upnlcfx","tag_id":"cjj3wcszg002n3iq2ymjgvnwa","_id":"cjj3wcszv003d3iq22hyi0rb7"},{"post_id":"cjj3wcsz600203iq26rajsf3m","tag_id":"cjj3wcszu003c3iq2m5u7eg52","_id":"cjj3wcszx003i3iq2tlgeox2g"},{"post_id":"cjj3wcszw003f3iq2p08iekn5","tag_id":"cjj3wcsye000r3iq2x00h70fn","_id":"cjj3wcszx003j3iq2yj434epd"},{"post_id":"cjj3wcsz600223iq21j7hapdn","tag_id":"cjj3wcszw003g3iq2ckk9vng7","_id":"cjj3wcszy003l3iq24hslts05"},{"post_id":"cjj3wcsz700243iq2rifp8qvr","tag_id":"cjj3wcszw003g3iq2ckk9vng7","_id":"cjj3wcszy003n3iq2kkn5jr6i"},{"post_id":"cjj3wcsz900283iq2sa3t8x1m","tag_id":"cjj3wcszw003g3iq2ckk9vng7","_id":"cjj3wcszz003p3iq2fhpwygfn"},{"post_id":"cjj3wcsza002a3iq29m143btj","tag_id":"cjj3wcszw003g3iq2ckk9vng7","_id":"cjj3wcszz003r3iq28c7ll772"},{"post_id":"cjj3wcszb002e3iq2xb0uzft0","tag_id":"cjj3wcszw003g3iq2ckk9vng7","_id":"cjj3wct01003t3iq2dtwbomb4"},{"post_id":"cjj3wcszc002g3iq23ojidxuk","tag_id":"cjj3wcszw003g3iq2ckk9vng7","_id":"cjj3wct01003v3iq239vp9muy"},{"post_id":"cjj3wcsze002k3iq2vee6r50k","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct02003x3iq2rp793yxh"},{"post_id":"cjj3wcszf002m3iq2kg8i6lo9","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct02003z3iq2intnz53n"},{"post_id":"cjj3wcszg002o3iq2fon5c2qo","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct0300413iq25ro5qcnc"},{"post_id":"cjj3wcszh002q3iq23tzaootq","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct0300433iq2df8w3qxm"},{"post_id":"cjj3wcszi002r3iq29xlel3d5","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct0400453iq2lchxdws4"},{"post_id":"cjj3wcszj002u3iq2qxnyww2i","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct0400473iq2cls2yuun"},{"post_id":"cjj3wcszk002v3iq20wk995eu","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct0400493iq27e6hnp9y"},{"post_id":"cjj3wcszl002y3iq2nubws3qo","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct05004b3iq2f2vo5ay5"},{"post_id":"cjj3wcszm002z3iq2i3szvgv4","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct05004d3iq2e1b9kana"},{"post_id":"cjj3wcszo00323iq2s7omtwei","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct06004f3iq20ow0dd8h"},{"post_id":"cjj3wcszp00333iq2rvy6nca8","tag_id":"cjj3wct06004e3iq2i5vo2hsf","_id":"cjj3wct06004h3iq2xjs2vtjy"},{"post_id":"cjj3wcszq00363iq287wvfb7q","tag_id":"cjj3wct01003u3iq2x96hq97e","_id":"cjj3wct07004j3iq242gr8exm"},{"post_id":"cjj3wcszr00373iq2l573mnlh","tag_id":"cjj3wct06004i3iq2pj41vdwk","_id":"cjj3wct08004l3iq231bo0ywq"},{"post_id":"cjj3wcszs003a3iq2ehvny98o","tag_id":"cjj3wct06004i3iq2pj41vdwk","_id":"cjj3wct08004n3iq2pkgy8h3l"},{"post_id":"cjj3wcszt003b3iq24ls47zc7","tag_id":"cjj3wct06004i3iq2pj41vdwk","_id":"cjj3wct08004p3iq26purhysj"},{"post_id":"cjj3wcszv003e3iq2f566n7t5","tag_id":"cjj3wct08004o3iq2vlbl8ihe","_id":"cjj3wct09004r3iq2u3tcqdwu"},{"post_id":"cjj3wcszx003h3iq2k4wtfnjt","tag_id":"cjj3wct09004q3iq2cw8gl033","_id":"cjj3wct09004s3iq2yh81u8pp"}],"Tag":[{"name":"Cobar","_id":"cjj3wcsxk00033iq2xnwmdf1r"},{"name":"Curator","_id":"cjj3wcsye000r3iq2x00h70fn"},{"name":"Raft","_id":"cjj3wcsyp000y3iq22x7yn21p"},{"name":"分布式事务","_id":"cjj3wcsys00163iq2jq3idxll"},{"name":"分布式设计","_id":"cjj3wcsyu001a3iq2onvj0k57"},{"name":"Guava","_id":"cjj3wcsyy001i3iq24hxopdil"},{"name":"JVM","_id":"cjj3wcsz0001n3iq2z3l8gbxd"},{"name":"面试","_id":"cjj3wcsz1001r3iq2xuv5a8t5"},{"name":"Kafka","_id":"cjj3wcsze002j3iq2bdgzao49"},{"name":"Linux","_id":"cjj3wcszg002n3iq2ymjgvnwa"},{"name":"MySQL","_id":"cjj3wcszu003c3iq2m5u7eg52"},{"name":"Netty","_id":"cjj3wcszw003g3iq2ckk9vng7"},{"name":"RocketMQ","_id":"cjj3wct01003u3iq2x96hq97e"},{"name":"序列化","_id":"cjj3wct06004e3iq2i5vo2hsf"},{"name":"源码分析","_id":"cjj3wct06004i3iq2pj41vdwk"},{"name":"THread","_id":"cjj3wct08004o3iq2vlbl8ihe"},{"name":"TCP","_id":"cjj3wct09004q3iq2cw8gl033"}]}}
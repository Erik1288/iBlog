---
title: Linux-Swap
date: 2018-09-22 22:12:43
tags:
---


https://www.cnblogs.com/tolimit/p/5447448.html


对于整个内存回收来说，lru链表是关键中的关键，实际上整个内存回收，做的事情就是处理lru链表的收缩，所以这篇文章就先说说系统的lru链表。
内存回收的核心思想，就是如果一些数据能够保存到磁盘，在内存不足时就把这些数据写到磁盘中，这样这些数据占用的内存页就可以作为空闲内存页给予系统使用了。
当内存不足时，系统就必须要将一些页框回收，而哪些页框可以回收呢，之前我们有说过，属于内核的大部分页框是不能够进行回收的，比如内核栈、内核代码段、内核数据段以及大部分内核使用的页框，它们都是不能够进行回收的；而相反，主要由进程使用的页框，比如进程代码段、进程数据段、进程堆栈、进程访问文件时映射的文件页、进程间共享内存使用的页，这些页框都是可以进行回收的。
当明确哪些页框可以回收，哪些页框不能够回收时，针对那些可以回收的页框，从中选择更应该进行回收的页框就变成一件很有必要的事情了，因为选择得好，能够减轻系统的负担，选择得不好，反而拖累了系统，让系统运行起来更艰难。比如：一个非常频繁地被访问的页，这个页可以进行回收，当内存不足时，系统选择对这个页进行回收，将这个页写入磁盘，而由于此页在写入磁盘之后立即又被访问了，系统又要将这个页从磁盘读到内存中，相当于系统进行了一次读写，而页又没有能够进行释放，一个页是这样可以接受，如果是1000个页是这种情况，可想而知，这样会大大拖累的系统，让系统做了非常多无用功。
lru链表在这时候就起到了这个重要作用，它能够让系统在那些可以回收的页框当中，选择到理想的回收页框。lru链表的核心思想就是做假设，如果一个页很久没有被访问到了，那么就假设在下一段时间中，这个页也可能不会被访问到。但是对于系统来说，它永远无法知道哪个页即将被访问，它认定一个页接下来的一段时间不会被访问到，但是有可能此页在下一刻就立刻被访问到了，也就是说，即使使用了lru链表，也不能保证不会发生上述的情况。

### 笨叔叔
mlock(), mlock2(), and mlockall() lock part or all of the calling
process's virtual address space into RAM, preventing that memory from
being paged to the swap area.

这个是mlock的man。说是将某段虚拟内存锁进Ram，防止对应的物理内存swap out。是不是也可以理解为，锁住 vma和pm的 mapping关系，不被删除？

不完全正确
内存 不加入 LRU链表，所以也不会 被 swap out
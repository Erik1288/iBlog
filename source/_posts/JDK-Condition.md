---
title: JDK-Condition
date: 2019-11-26 16:05:19
tags:
---

### 监视器锁的 wait/notify 机制的弊端
通常情况下，调用wait方法，主要是因为一定的条件没有满足，这里把需要满足的事件或条件称作条件谓词。

而另一方面，由synchronized的原理可知，所有调用了wait方法的线程，都会在同一个监视器锁的wait set中等待，这看上去很合理，但是却是该机制的短板所在——所有的线程都等待在同一个notify方法上(notify方法指notify()和notifyAll()两个方法，下同)。每一个调用wait方法的线程可能等待在不同的条件谓词上，但是有时候即使自己等待的条件并没有满足，线程也有可能被“别的线程的”notify方法唤醒，因为大家用的是同一个监视器锁。这就好比一个班上有几个重名的同学(使用相同的监视器锁)，老师喊了这个名字（notify方法），结果这几个同学全都站起来了（等待在监视器锁上的线程都被唤醒了）。

这样一来，即使自己被唤醒后抢到了监视器锁，发现其实条件还是不满足，还是得调用wait方法挂起，就导致了很多无意义的时间和CPU资源的浪费。

这一切的根源就在于在调用wait方法时没有办法来指明究竟是在等待什么样的条件谓词上，因此唤醒时，也不知道该唤醒谁，只能把所有的线程都唤醒了。

因此，最好的方式是，线程在挂起时就指明了在什么样的条件谓词上挂起，同时，在等待的事件发生后，只唤醒等待在这个事件上的线程，而实现了这个思路的就是Condition接口。

有了Condition接口，就可以在同一个锁上创建不同的唤醒条件，从而在一定条件谓词满足后，有针对性的唤醒特定的线程，而不是将所有等待的线程都唤醒。